<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This manual (21 April 2023)
is for Libmarpa 11.0.9.

Copyright (C) 2023 Jeffrey Kegler.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE. -->
<!-- Created by GNU Texinfo 6.5, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Libmarpa 11.0.9</title>

<meta name="description" content="Libmarpa 11.0.9">
<meta name="keywords" content="Libmarpa 11.0.9">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="#Top" rel="start" title="Top">
<link href="#Index-of-terms" rel="index" title="Index of terms">
<link href="#SEC_Contents" rel="contents" title="Table of Contents">
<link href="dir.html#Top" rel="up" title="(dir)">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<h1 class="settitle" align="center">Libmarpa 11.0.9</h1>






<a name="SEC_Contents"></a>
<h2 class="contents-heading">Table of Contents</h2>

<div class="contents">

<ul class="no-bullet">
  <li><a name="toc-License-1" href="#License">1 License</a></li>
  <li><a name="toc-Updates-1" href="#Updates">2 Updates</a></li>
  <li><a name="toc-About-this-document-1" href="#About-this-document">3 About this document</a>
  <ul class="no-bullet">
    <li><a name="toc-How-to-read-this-document-1" href="#How-to-read-this-document">3.1 How to read this document</a></li>
    <li><a name="toc-Prerequisites-1" href="#Prerequisites">3.2 Prerequisites</a></li>
  </ul></li>
  <li><a name="toc-Overview-of-Libmarpa-1" href="#Overview-of-Libmarpa">4 Overview of Libmarpa</a></li>
  <li><a name="toc-Terms_002c-definitions-and-notation" href="#Terms">5 Terms, definitions and notation</a>
  <ul class="no-bullet">
    <li><a name="toc-Miscellaneous-definitions-1" href="#Miscellaneous-definitions">5.1 Miscellaneous definitions</a></li>
    <li><a name="toc-Parsing-theory-preliminaries-1" href="#Parsing-theory-preliminaries">5.2 Parsing theory preliminaries</a></li>
    <li><a name="toc-Rules-1" href="#Rules">5.3 Rules</a></li>
    <li><a name="toc-Derivations-1" href="#Derivations">5.4 Derivations</a></li>
    <li><a name="toc-Nulling-1" href="#Nulling">5.5 Nulling</a></li>
    <li><a name="toc-Useless-rules-1" href="#Useless-rules">5.6 Useless rules</a></li>
    <li><a name="toc-Recursion-and-cycles-1" href="#Recursion-and-cycles">5.7 Recursion and cycles</a></li>
    <li><a name="toc-Trees-1" href="#Trees">5.8 Trees</a></li>
    <li><a name="toc-An-example-tree-1" href="#An-example-tree">5.9 An example tree</a></li>
    <li><a name="toc-Traversal-1" href="#Traversal">5.10 Traversal</a></li>
    <li><a name="toc-Semantics-terms-1" href="#Semantics-terms">5.11 Semantics terms</a></li>
    <li><a name="toc-Ambiguity-1" href="#Ambiguity">5.12 Ambiguity</a></li>
    <li><a name="toc-Earley-items-1" href="#Earley-items">5.13 Earley items</a></li>
    <li><a name="toc-Application-and-diagnostic-behavior-1" href="#Application-and-diagnostic-behavior">5.14 Application and diagnostic behavior</a></li>
  </ul></li>
  <li><a name="toc-Architecture-1" href="#Architecture">6 Architecture</a>
  <ul class="no-bullet">
    <li><a name="toc-Major-objects-1" href="#Major-objects">6.1 Major objects</a></li>
    <li><a name="toc-Time-objects-1" href="#Time-objects">6.2 Time objects</a></li>
    <li><a name="toc-Reference-counting-1" href="#Reference-counting">6.3 Reference counting</a></li>
    <li><a name="toc-Numbered-objects-1" href="#Numbered-objects">6.4 Numbered objects</a></li>
  </ul></li>
  <li><a name="toc-Input-1" href="#Input">7 Input</a>
  <ul class="no-bullet">
    <li><a name="toc-Parse-location-1" href="#Parse-location">7.1 Parse location</a>
    <ul class="no-bullet">
      <li><a name="toc-The-traditional-input-model-1" href="#The-traditional-input-model">7.1.1 The traditional input model</a></li>
      <li><a name="toc-Earlemes-and-Earley-set-IDs-1" href="#Earlemes-and-Earley-set-IDs">7.1.2 Earlemes and Earley set IDs</a></li>
      <li><a name="toc-The-latest-Earley-set-1" href="#The-latest-Earley-set">7.1.3 The latest Earley set</a></li>
      <li><a name="toc-The-latest-earleme-1" href="#The-latest-earleme">7.1.4 The latest earleme</a></li>
      <li><a name="toc-The-current-earleme-1" href="#The-current-earleme">7.1.5 The current earleme</a></li>
      <li><a name="toc-The-furthest-earleme-1" href="#The-furthest-earleme">7.1.6 The furthest earleme</a></li>
    </ul></li>
    <li><a name="toc-The-basic-models-of-input-1" href="#The-basic-models-of-input">7.2 The basic models of input</a>
    <ul class="no-bullet">
      <li><a name="toc-The-standard-model-of-input-1" href="#The-standard-model-of-input">7.2.1 The standard model of input</a></li>
      <li><a name="toc-Ambiguous-input-1" href="#Ambiguous-input">7.2.2 Ambiguous input</a></li>
    </ul></li>
    <li><a name="toc-Terminals-1" href="#Terminals">7.3 Terminals</a></li>
  </ul></li>
  <li><a name="toc-Exhaustion-1" href="#Exhaustion">8 Exhaustion</a></li>
  <li><a name="toc-End-of-parse-1" href="#End-of-parse">9 End of parse</a>
  <ul class="no-bullet">
    <li><a name="toc-Determining-EOP-from-EOI-1" href="#Determining-EOP-from-EOI">9.1 Determining EOP from EOI</a></li>
    <li><a name="toc-Determining-EOP-from-exhaustion-1" href="#Determining-EOP-from-exhaustion">9.2 Determining EOP from exhaustion</a></li>
    <li><a name="toc-Other-ways-of-determining-EOP-1" href="#Other-ways-of-determining-EOP">9.3 Other ways of determining EOP</a></li>
  </ul></li>
  <li><a name="toc-Semantics-1" href="#Semantics">10 Semantics</a></li>
  <li><a name="toc-Threads-1" href="#Threads">11 Threads</a></li>
  <li><a name="toc-Sequence-rules-1" href="#Sequence-rules">12 Sequence rules</a></li>
  <li><a name="toc-Nullability-1" href="#Nullability">13 Nullability</a>
  <ul class="no-bullet">
    <li><a name="toc-Nullability-in-the-valuator-1" href="#Nullability-in-the-valuator">13.1 Nullability in the valuator</a></li>
    <li><a name="toc-Assigning-semantics-to-nulled-symbols-1" href="#Assigning-semantics-to-nulled-symbols">13.2 Assigning semantics to nulled symbols</a></li>
    <li><a name="toc-Evaluating-nulled-symbols-1" href="#Evaluating-nulled-symbols">13.3 Evaluating nulled symbols</a></li>
    <li><a name="toc-Example-of-nulled-symbol-1" href="#Example-of-nulled-symbol">13.4 Example of nulled symbol</a></li>
    <li><a name="toc-Duplicate-nulled-nodes-1" href="#Duplicate-nulled-nodes">13.5 Duplicate nulled nodes</a></li>
  </ul></li>
  <li><a name="toc-Failure-1" href="#Failure">14 Failure</a>
  <ul class="no-bullet">
    <li><a name="toc-Libmarpa_0027s-approach-to-failure-1" href="#Libmarpa_0027s-approach-to-failure">14.1 Libmarpa&rsquo;s approach to failure</a></li>
    <li><a name="toc-User-non_002dconformity-to-specified-behavior-1" href="#User-non_002dconformity-to-specified-behavior">14.2 User non-conformity to specified behavior</a></li>
    <li><a name="toc-Classifying-failure-1" href="#Classifying-failure">14.3 Classifying failure</a></li>
    <li><a name="toc-Memory-allocation-failure-1" href="#Memory-allocation-failure">14.4 Memory allocation failure</a></li>
    <li><a name="toc-Undetected-failure-1" href="#Undetected-failure">14.5 Undetected failure</a></li>
    <li><a name="toc-Irrecoverable-hard-failure-1" href="#Irrecoverable-hard-failure">14.6 Irrecoverable hard failure</a></li>
    <li><a name="toc-Partially-recoverable-hard-failure-1" href="#Partially-recoverable-hard-failure">14.7 Partially recoverable hard failure</a></li>
    <li><a name="toc-Library_002drecoverable-hard-failure-1" href="#Library_002drecoverable-hard-failure">14.8 Library-recoverable hard failure</a></li>
    <li><a name="toc-Ancestry_002drecoverable-hard-failure-1" href="#Ancestry_002drecoverable-hard-failure">14.9 Ancestry-recoverable hard failure</a></li>
    <li><a name="toc-Fully-recoverable-hard-failure-1" href="#Fully-recoverable-hard-failure">14.10 Fully recoverable hard failure</a></li>
    <li><a name="toc-Soft-failure-1" href="#Soft-failure">14.11 Soft failure</a></li>
    <li><a name="toc-Error-codes-1" href="#Error-codes">14.12 Error codes</a></li>
  </ul></li>
  <li><a name="toc-Introduction-to-the-method-descriptions-1" href="#Introduction-to-the-method-descriptions">15 Introduction to the method descriptions</a>
  <ul class="no-bullet">
    <li><a name="toc-About-the-overviews-1" href="#About-the-overviews">15.1 About the overviews</a></li>
    <li><a name="toc-Naming-conventions-1" href="#Naming-conventions">15.2 Naming conventions</a></li>
    <li><a name="toc-Return-values-1" href="#Return-values">15.3 Return values</a></li>
    <li><a name="toc-How-to-read-the-method-descriptions-1" href="#How-to-read-the-method-descriptions">15.4 How to read the method descriptions</a></li>
  </ul></li>
  <li><a name="toc-Static-methods-1" href="#Static-methods">16 Static methods</a></li>
  <li><a name="toc-Configuration-methods-1" href="#Configuration-methods">17 Configuration methods</a></li>
  <li><a name="toc-Grammar-methods-1" href="#Grammar-methods">18 Grammar methods</a>
  <ul class="no-bullet">
    <li><a name="toc-Overview" href="#Grammar-overview">18.1 Overview</a></li>
    <li><a name="toc-Creating-a-new-grammar" href="#Grammar-constructor">18.2 Creating a new grammar</a></li>
    <li><a name="toc-Tracking-the-reference-count-of-the-grammar" href="#Grammar-reference-counting">18.3 Tracking the reference count of the grammar</a></li>
    <li><a name="toc-Symbol-methods-1" href="#Symbol-methods">18.4 Symbol methods</a></li>
    <li><a name="toc-Rule-methods-1" href="#Rule-methods">18.5 Rule methods</a></li>
    <li><a name="toc-Sequence-methods-1" href="#Sequence-methods">18.6 Sequence methods</a></li>
    <li><a name="toc-Rank-methods-1" href="#Rank-methods">18.7 Rank methods</a></li>
    <li><a name="toc-Precomputing-the-Grammar" href="#Grammar-precomputation">18.8 Precomputing the Grammar</a></li>
  </ul></li>
  <li><a name="toc-Recognizer-methods-1" href="#Recognizer-methods">19 Recognizer methods</a>
  <ul class="no-bullet">
    <li><a name="toc-Recognizer-overview-1" href="#Recognizer-overview">19.1 Recognizer overview</a></li>
    <li><a name="toc-Creating-a-new-recognizer-1" href="#Creating-a-new-recognizer">19.2 Creating a new recognizer</a></li>
    <li><a name="toc-Keeping-the-reference-count-of-a-recognizer" href="#Recognizer-reference-counting">19.3 Keeping the reference count of a recognizer</a></li>
    <li><a name="toc-Life-cycle-mutators" href="#Recognizer-life-cycle-mutators">19.4 Life cycle mutators</a></li>
    <li><a name="toc-Location-accessors-1" href="#Location-accessors">19.5 Location accessors</a></li>
    <li><a name="toc-Other-parse-status-methods-1" href="#Other-parse-status-methods">19.6 Other parse status methods</a></li>
  </ul></li>
  <li><a name="toc-Progress-reports-1" href="#Progress-reports">20 Progress reports</a></li>
  <li><a name="toc-Bocage-methods-1" href="#Bocage-methods">21 Bocage methods</a>
  <ul class="no-bullet">
    <li><a name="toc-Overview-1" href="#Bocage-overview">21.1 Overview</a></li>
    <li><a name="toc-Bocage-data-structure-1" href="#Bocage-data-structure">21.2 Bocage data structure</a></li>
    <li><a name="toc-Creating-a-new-bocage" href="#Bocage-constructor">21.3 Creating a new bocage</a></li>
    <li><a name="toc-Reference-counting-2" href="#Bocage-reference-counting">21.4 Reference counting</a></li>
    <li><a name="toc-Accessors" href="#Bocage-accessor">21.5 Accessors</a></li>
  </ul></li>
  <li><a name="toc-Ordering-methods-1" href="#Ordering-methods">22 Ordering methods</a>
  <ul class="no-bullet">
    <li><a name="toc-Overview-2" href="#Ordering-overview">22.1 Overview</a></li>
    <li><a name="toc-Freezing-the-ordering-1" href="#Freezing-the-ordering">22.2 Freezing the ordering</a></li>
    <li><a name="toc-Creating-an-ordering" href="#Ordering-constructor">22.3 Creating an ordering</a></li>
    <li><a name="toc-Reference-counting-3" href="#Ordering-reference-counting">22.4 Reference counting</a></li>
    <li><a name="toc-Accessors-1" href="#Order-accessor">22.5 Accessors</a></li>
    <li><a name="toc-Non_002ddefault-ordering-1" href="#Non_002ddefault-ordering">22.6 Non-default ordering</a></li>
  </ul></li>
  <li><a name="toc-Tree-methods-1" href="#Tree-methods">23 Tree methods</a>
  <ul class="no-bullet">
    <li><a name="toc-Overview-3" href="#Tree-overview">23.1 Overview</a></li>
    <li><a name="toc-Creating-a-new-tree-iterator" href="#Tree-constructor">23.2 Creating a new tree iterator</a></li>
    <li><a name="toc-Reference-counting-4" href="#Tree-reference-counting">23.3 Reference counting</a></li>
    <li><a name="toc-Iterating-through-the-trees-1" href="#Iterating-through-the-trees">23.4 Iterating through the trees</a></li>
  </ul></li>
  <li><a name="toc-Value-methods-1" href="#Value-methods">24 Value methods</a>
  <ul class="no-bullet">
    <li><a name="toc-Overview-4" href="#Value-overview">24.1 Overview</a></li>
    <li><a name="toc-How-to-use-the-valuator-1" href="#How-to-use-the-valuator">24.2 How to use the valuator</a></li>
    <li><a name="toc-Advantages-of-step_002ddriven-valuation-1" href="#Advantages-of-step_002ddriven-valuation">24.3 Advantages of step-driven valuation</a></li>
    <li><a name="toc-Maintaining-the-stack-1" href="#Maintaining-the-stack">24.4 Maintaining the stack</a>
    <ul class="no-bullet">
      <li><a name="toc-Sizing-the-stack-1" href="#Sizing-the-stack">24.4.1 Sizing the stack</a></li>
    </ul></li>
    <li><a name="toc-Creating-a-new-valuator" href="#Valuator-constructor">24.5 Creating a new valuator</a></li>
    <li><a name="toc-Reference-counting-5" href="#Valuator-reference-counting">24.6 Reference counting</a></li>
    <li><a name="toc-Stepping-through-the-valuator-1" href="#Stepping-through-the-valuator">24.7 Stepping through the valuator</a></li>
    <li><a name="toc-Valuator-step-types-1" href="#Valuator-step-types">24.8 Valuator step types</a></li>
    <li><a name="toc-Basic-step-accessors-1" href="#Basic-step-accessors">24.9 Basic step accessors</a></li>
    <li><a name="toc-Step-location-accessors-1" href="#Step-location-accessors">24.10 Step location accessors</a></li>
  </ul></li>
  <li><a name="toc-Events-1" href="#Events">25 Events</a>
  <ul class="no-bullet">
    <li><a name="toc-Overview-5" href="#Events-overview">25.1 Overview</a></li>
    <li><a name="toc-Event-codes-1" href="#Event-codes">25.2 Event codes</a></li>
    <li><a name="toc-Basic-event-accessors-1" href="#Basic-event-accessors">25.3 Basic event accessors</a></li>
    <li><a name="toc-Completion-events-1" href="#Completion-events">25.4 Completion events</a></li>
    <li><a name="toc-Symbol-nulled-events-1" href="#Symbol-nulled-events">25.5 Symbol nulled events</a></li>
    <li><a name="toc-Prediction-events-1" href="#Prediction-events">25.6 Prediction events</a></li>
    <li><a name="toc-Symbol-expected-events-1" href="#Symbol-expected-events">25.7 Symbol expected events</a></li>
    <li><a name="toc-Recognizer-per_002dsymbol-events-1" href="#Recognizer-per_002dsymbol-events">25.8 Recognizer per-symbol events</a></li>
    <li><a name="toc-Tentative-events-1" href="#Tentative-events">25.9 Tentative events</a></li>
    <li><a name="toc-Ambiguous-parses-and-events-1" href="#Ambiguous-parses-and-events">25.10 Ambiguous parses and events</a></li>
    <li><a name="toc-Nulled-subtrees-and-events-1" href="#Nulled-subtrees-and-events">25.11 Nulled subtrees and events</a></li>
    <li><a name="toc-Event-coincidence-of-symbol-instances-1" href="#Event-coincidence-of-symbol-instances">25.12 Event coincidence of symbol instances</a>
    <ul class="no-bullet">
      <li><a name="toc-Nulled-and-completed-symbol-instances-1" href="#Nulled-and-completed-symbol-instances">25.12.1 Nulled and completed symbol instances</a></li>
      <li><a name="toc-Nulled-and-predicted-symbol-instances-1" href="#Nulled-and-predicted-symbol-instances">25.12.2 Nulled and predicted symbol instances</a></li>
      <li><a name="toc-Nulled-and-expected-symbol-instances-1" href="#Nulled-and-expected-symbol-instances">25.12.3 Nulled and expected symbol instances</a></li>
      <li><a name="toc-Completed-and-predicted-symbol-instances-1" href="#Completed-and-predicted-symbol-instances">25.12.4 Completed and predicted symbol instances</a></li>
      <li><a name="toc-Completed-and-expected-symbol-instances-1" href="#Completed-and-expected-symbol-instances">25.12.5 Completed and expected symbol instances</a></li>
      <li><a name="toc-Predicted-and-expected-symbol-instances-1" href="#Predicted-and-expected-symbol-instances">25.12.6 Predicted and expected symbol instances</a></li>
    </ul></li>
    <li><a name="toc-Event-coincidence-of-symbols-1" href="#Event-coincidence-of-symbols">25.13 Event coincidence of symbols</a></li>
    <li><a name="toc-Marker-symbols-1" href="#Marker-symbols">25.14 Marker symbols</a></li>
    <li><a name="toc-Per_002drule-events-1" href="#Per_002drule-events">25.15 Per-rule events</a>
    <ul class="no-bullet">
      <li><a name="toc-Workaround-with-a-dedicated-LHS-symbol-1" href="#Workaround-with-a-dedicated-LHS-symbol">25.15.1 Workaround with a dedicated LHS symbol</a></li>
    </ul></li>
  </ul></li>
  <li><a name="toc-Tracing-and-diagnosing-parses-1" href="#Tracing-and-diagnosing-parses">26 Tracing and diagnosing parses</a>
  <ul class="no-bullet">
    <li><a name="toc-Listing-symbols-1" href="#Listing-symbols">26.1 Listing symbols</a></li>
    <li><a name="toc-Listing-rules-1" href="#Listing-rules">26.2 Listing rules</a></li>
    <li><a name="toc-Listing-Earley-sets-1" href="#Listing-Earley-sets">26.3 Listing Earley sets</a></li>
    <li><a name="toc-Tracing-tokens-1" href="#Tracing-tokens">26.4 Tracing tokens</a></li>
  </ul></li>
  <li><a name="toc-Error-methods_002c-macros-and-codes" href="#Error-methods-macros-and-codes">27 Error methods, macros and codes</a>
  <ul class="no-bullet">
    <li><a name="toc-Error-methods-1" href="#Error-methods">27.1 Error methods</a></li>
    <li><a name="toc-Error-Macros-1" href="#Error-Macros">27.2 Error Macros</a></li>
    <li><a name="toc-External-error-codes-1" href="#External-error-codes">27.3 External error codes</a></li>
    <li><a name="toc-Internal-error-codes-1" href="#Internal-error-codes">27.4 Internal error codes</a></li>
  </ul></li>
  <li><a name="toc-Technical-notes-1" href="#Technical-notes">28 Technical notes</a>
  <ul class="no-bullet">
    <li><a name="toc-Data-types-used-by-Libmarpa-1" href="#Data-types-used-by-Libmarpa">28.1 Data types used by Libmarpa</a></li>
    <li><a name="toc-Why-so-many-time-objects_003f" href="#Why-so-many-time-objects">28.2 Why so many time objects?</a></li>
    <li><a name="toc-Numbered-objects-2" href="#Design-of-numbered-objects">28.3 Numbered objects</a></li>
    <li><a name="toc-Trap-representations-1" href="#Trap-representations">28.4 Trap representations</a></li>
    <li><a name="toc-Out_002dof_002dmemory-handling-1" href="#Out_002dof_002dmemory-handling">28.5 Out-of-memory handling</a></li>
  </ul></li>
  <li><a name="toc-Advanced-input-models-1" href="#Advanced-input-models">29 Advanced input models</a>
  <ul class="no-bullet">
    <li><a name="toc-The-dense-variable_002dlength-token-model-1" href="#The-dense-variable_002dlength-token-model">29.1 The dense variable-length token model</a></li>
    <li><a name="toc-The-fully-general-input-model-1" href="#The-fully-general-input-model">29.2 The fully general input model</a></li>
    <li><a name="toc-The-codepoint_002dper_002dearleme-model-1" href="#The-codepoint_002dper_002dearleme-model">29.3 The codepoint-per-earleme model</a></li>
    <li><a name="toc-Converting-earleme-to-Earley-set-ID-1" href="#Converting-earleme-to-Earley-set-ID">29.4 Converting earleme to Earley set ID</a></li>
  </ul></li>
  <li><a name="toc-Support-1" href="#Support">30 Support</a></li>
  <li><a name="toc-Futures-1" href="#Futures">31 Futures</a>
  <ul class="no-bullet">
    <li><a name="toc-Nulling-versus-nulled-1" href="#Nulling-versus-nulled">31.1 Nulling versus nulled</a></li>
    <li><a name="toc-Document-pre_002dconditions-more-formally-1" href="#Document-pre_002dconditions-more-formally">31.2 Document pre-conditions more formally</a></li>
    <li><a name="toc-Simpler-events-interface-1" href="#Simpler-events-interface">31.3 Simpler events interface</a></li>
    <li><a name="toc-Better-defined-ambiguity-metric-1" href="#Better-defined-ambiguity-metric">31.4 Better defined ambiguity metric</a></li>
    <li><a name="toc-Report-item-traverser-should-be-a-time-object-1" href="#Report-item-traverser-should-be-a-time-object">31.5 Report item traverser should be a time object</a></li>
    <li><a name="toc-Orthogonal-treatment-of-soft-failures-1" href="#Orthogonal-treatment-of-soft-failures">31.6 Orthogonal treatment of soft failures</a></li>
    <li><a name="toc-Orthogonal-treatment-of-exhaustion-1" href="#Orthogonal-treatment-of-exhaustion">31.7 Orthogonal treatment of exhaustion</a></li>
    <li><a name="toc-Furthest-earleme-values-1" href="#Furthest-earleme-values">31.8 Furthest earleme values</a></li>
    <li><a name="toc-Additional-recoverable-failures-in-marpa_005fr_005falternative_0028_0029-1" href="#Additional-recoverable-failures-in-marpa_005fr_005falternative_0028_0029">31.9 Additional recoverable failures in marpa_r_alternative()</a></li>
    <li><a name="toc-Untested-methods-1" href="#Untested-methods">31.10 Untested methods</a>
    <ul class="no-bullet">
      <li><a name="toc-Zero_002dwidth-assertion-methods-1" href="#Zero_002dwidth-assertion-methods">31.10.1 Zero-width assertion methods</a></li>
      <li><a name="toc-Methods-for-revising-parses-1" href="#Methods-for-revising-parses">31.10.2 Methods for revising parses</a></li>
    </ul></li>
  </ul></li>
  <li><a name="toc-Deprecated-techniques-and-methods-1" href="#Deprecated-techniques-and-methods">32 Deprecated techniques and methods</a>
  <ul class="no-bullet">
    <li><a name="toc-LHS-terminals-1" href="#LHS-terminals">32.1 LHS terminals</a>
    <ul class="no-bullet">
      <li><a name="toc-Overview-of-LHS-terminals-1" href="#Overview-of-LHS-terminals">32.1.1 Overview of LHS terminals</a></li>
      <li><a name="toc-Motivation-of-LHS-terminals-1" href="#Motivation-of-LHS-terminals">32.1.2 Motivation of LHS terminals</a></li>
      <li><a name="toc-LHS-terminal-methods-1" href="#LHS-terminal-methods">32.1.3 LHS terminal methods</a></li>
      <li><a name="toc-Precomputation-and-LHS-terminals-1" href="#Precomputation-and-LHS-terminals">32.1.4 Precomputation and LHS terminals</a></li>
      <li><a name="toc-Nulling-terminals-1" href="#Nulling-terminals">32.1.5 Nulling terminals</a></li>
    </ul></li>
    <li><a name="toc-Valued-and-unvalued-symbols-1" href="#Valued-and-unvalued-symbols">32.2 Valued and unvalued symbols</a>
    <ul class="no-bullet">
      <li><a name="toc-What-unvalued-symbols-were-1" href="#What-unvalued-symbols-were">32.2.1 What unvalued symbols were</a></li>
      <li><a name="toc-Grammar-methods-dealing-with-unvalued-symbols-1" href="#Grammar-methods-dealing-with-unvalued-symbols">32.2.2 Grammar methods dealing with unvalued symbols</a></li>
      <li><a name="toc-Registering-semantics-in-the-valuator-1" href="#Registering-semantics-in-the-valuator">32.2.3 Registering semantics in the valuator</a></li>
    </ul></li>
    <li><a name="toc-Cycles-1" href="#Cycles">32.3 Cycles</a></li>
  </ul></li>
  <li><a name="toc-History-of-the-Marpa-algorithm-1" href="#History-of-the-Marpa-algorithm">33 History of the Marpa algorithm</a></li>
  <li><a name="toc-Annotated-bibliography-1" href="#Annotated-bibliography">34 Annotated bibliography</a>
  <ul class="no-bullet">
    <li><a name="toc-Aho-and-Ullman-1972-1" href="#Aho-and-Ullman-1972">34.1 Aho and Ullman 1972</a></li>
    <li><a name="toc-Aycock-and-Horspool-2002-1" href="#Aycock-and-Horspool-2002">34.2 Aycock and Horspool 2002</a></li>
    <li><a name="toc-C89-standard" href="#C89">34.3 C89 standard</a></li>
    <li><a name="toc-C99-standard" href="#C99">34.4 C99 standard</a></li>
    <li><a name="toc-Dominus-2005-1" href="#Dominus-2005">34.5 Dominus 2005</a></li>
    <li><a name="toc-Earley-1970-1" href="#Earley-1970">34.6 Earley 1970</a></li>
    <li><a name="toc-Grune-and-Jacobs-1990-1" href="#Grune-and-Jacobs-1990">34.7 Grune and Jacobs 1990</a></li>
    <li><a name="toc-Grune-and-Jacobs-2008-1" href="#Grune-and-Jacobs-2008">34.8 Grune and Jacobs 2008</a></li>
    <li><a name="toc-Marpa-theory-paper-1" href="#Marpa-theory-paper">34.9 Marpa theory paper</a></li>
    <li><a name="toc-Kegler-2023-1" href="#Kegler-2023">34.10 Kegler 2023</a></li>
    <li><a name="toc-Parsing-timeline-1" href="#Parsing-timeline">34.11 Parsing timeline</a></li>
    <li><a name="toc-Leo-1991-1" href="#Leo-1991">34.12 Leo 1991</a></li>
    <li><a name="toc-Scott-2008-1" href="#Scott-2008">34.13 Scott 2008</a></li>
    <li><a name="toc-Wikipedia-BNF-article-1" href="#Wikipedia-BNF-article">34.14 Wikipedia BNF article</a></li>
  </ul></li>
  <li><a name="toc-Acknowledgements-1" href="#Acknowledgements">35 Acknowledgements</a>
  <ul class="no-bullet">
    <li><a name="toc-An-apology-1" href="#An-apology">35.1 An apology</a></li>
  </ul></li>
  <li><a name="toc-Index-of-terms-1" href="#Index-of-terms">Index of terms</a></li>
</ul>
</div>


<a name="Top"></a>
<div class="header">
<p>
Next: <a href="#License" accesskey="n" rel="next">License</a>, Previous: <a href="dir.html#Top" accesskey="p" rel="prev">(dir)</a>, Up: <a href="dir.html#Top" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Libmarpa_003a-The-Marpa-low_002dlevel-library"></a>
<h1 class="top">Libmarpa: The Marpa low-level library</h1>
<p>This manual (21 April 2023)
is for Libmarpa 11.0.9.
</p>
<p>Copyright &copy; 2023 Jeffrey Kegler.
</p>
<blockquote>
<p>Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the &ldquo;Software&rdquo;),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:
</p>
<p>The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.
</p>
<p>THE SOFTWARE IS PROVIDED &ldquo;AS IS&rdquo;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
</p></blockquote>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#License" accesskey="1">License</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Updates" accesskey="2">Updates</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#About-this-document" accesskey="3">About this document</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Overview-of-Libmarpa" accesskey="4">Overview of Libmarpa</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Terms" accesskey="5">Terms</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Architecture" accesskey="6">Architecture</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Input" accesskey="7">Input</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Exhaustion" accesskey="8">Exhaustion</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#End-of-parse" accesskey="9">End of parse</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Semantics">Semantics</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Threads">Threads</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Sequence-rules">Sequence rules</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Nullability">Nullability</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Failure">Failure</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Introduction-to-the-method-descriptions">Introduction to the method descriptions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Static-methods">Static methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Configuration-methods">Configuration methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Grammar-methods">Grammar methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Recognizer-methods">Recognizer methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Progress-reports">Progress reports</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Bocage-methods">Bocage methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Ordering-methods">Ordering methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Tree-methods">Tree methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Value-methods">Value methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Events">Events</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Tracing-and-diagnosing-parses">Tracing and diagnosing parses</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Error-methods-macros-and-codes">Error methods macros and codes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Technical-notes">Technical notes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Advanced-input-models">Advanced input models</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Support">Support</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Futures">Futures</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Deprecated-techniques-and-methods">Deprecated techniques and methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#History-of-the-Marpa-algorithm">History of the Marpa algorithm</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Annotated-bibliography">Annotated bibliography</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Acknowledgements">Acknowledgements</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Index-of-terms">Index of terms</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

</pre></th></tr><tr><th colspan="3" align="left" valign="top"><pre class="menu-comment"> &mdash; The Detailed Node Listing &mdash;

About this document

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#How-to-read-this-document">How to read this document</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Prerequisites">Prerequisites</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Terms, definitions and notation

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Miscellaneous-definitions">Miscellaneous definitions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Rules">Rules</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Derivations">Derivations</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Nulling">Nulling</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Useless-rules">Useless rules</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Recursion-and-cycles">Recursion and cycles</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Trees">Trees</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#An-example-tree">An example tree</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Traversal">Traversal</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Semantics-terms">Semantics terms</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Ambiguity">Ambiguity</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Earley-items">Earley items</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Application-and-diagnostic-behavior">Application and diagnostic behavior</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Architecture

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Major-objects">Major objects</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Time-objects">Time objects</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Reference-counting">Reference counting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Numbered-objects">Numbered objects</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Input

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Parse-location">Parse location</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-basic-models-of-input">The basic models of input</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Terminals">Terminals</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Parse location

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#The-traditional-input-model">The traditional input model</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Earlemes-and-Earley-set-IDs">Earlemes and Earley set IDs</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-latest-Earley-set">The latest Earley set</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-latest-earleme">The latest earleme</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-current-earleme">The current earleme</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-furthest-earleme">The furthest earleme</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

The basic models of input

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#The-standard-model-of-input">The standard model of input</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Ambiguous-input">Ambiguous input</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

End of parse

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Determining-EOP-from-EOI">Determining EOP from EOI</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Determining-EOP-from-exhaustion">Determining EOP from exhaustion</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Other-ways-of-determining-EOP">Other ways of determining EOP</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Nullability

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Nullability-in-the-valuator">Nullability in the valuator</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Assigning-semantics-to-nulled-symbols">Assigning semantics to nulled symbols</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Evaluating-nulled-symbols">Evaluating nulled symbols</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Example-of-nulled-symbol">Example of nulled symbol</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Duplicate-nulled-nodes">Duplicate nulled nodes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Failure

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Libmarpa_0027s-approach-to-failure">Libmarpa's approach to failure</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#User-non_002dconformity-to-specified-behavior">User non-conformity to specified behavior</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Classifying-failure">Classifying failure</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Memory-allocation-failure">Memory allocation failure</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Undetected-failure">Undetected failure</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Irrecoverable-hard-failure">Irrecoverable hard failure</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Partially-recoverable-hard-failure">Partially recoverable hard failure</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Library_002drecoverable-hard-failure">Library-recoverable hard failure</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Ancestry_002drecoverable-hard-failure">Ancestry-recoverable hard failure</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Fully-recoverable-hard-failure">Fully recoverable hard failure</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Soft-failure">Soft failure</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Error-codes">Error codes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Introduction to the method descriptions

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#About-the-overviews">About the overviews</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Naming-conventions">Naming conventions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Return-values">Return values</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#How-to-read-the-method-descriptions">How to read the method descriptions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Grammar methods

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Grammar-overview">Grammar overview</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Grammar-constructor">Grammar constructor</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Grammar-reference-counting">Grammar reference counting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Symbol-methods">Symbol methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Rule-methods">Rule methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Sequence-methods">Sequence methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Rank-methods">Rank methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Grammar-precomputation">Grammar precomputation</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Recognizer methods

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Recognizer-overview">Recognizer overview</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Creating-a-new-recognizer">Creating a new recognizer</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Recognizer-reference-counting">Recognizer reference counting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Recognizer-life-cycle-mutators">Recognizer life cycle mutators</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Location-accessors">Location accessors</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Other-parse-status-methods">Other parse status methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Bocage methods

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Bocage-overview">Bocage overview</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Bocage-data-structure">Bocage data structure</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Bocage-constructor">Bocage constructor</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Bocage-reference-counting">Bocage reference counting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Bocage-accessor">Bocage accessor</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Ordering methods

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Ordering-overview">Ordering overview</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Freezing-the-ordering">Freezing the ordering</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Ordering-constructor">Ordering constructor</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Ordering-reference-counting">Ordering reference counting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Order-accessor">Order accessor</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Non_002ddefault-ordering">Non-default ordering</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Tree methods

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Tree-overview">Tree overview</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Tree-constructor">Tree constructor</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Tree-reference-counting">Tree reference counting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Iterating-through-the-trees">Iterating through the trees</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Value methods

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Value-overview">Value overview</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#How-to-use-the-valuator">How to use the valuator</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Advantages-of-step_002ddriven-valuation">Advantages of step-driven valuation</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Maintaining-the-stack">Maintaining the stack</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Valuator-constructor">Valuator constructor</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Valuator-reference-counting">Valuator reference counting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Stepping-through-the-valuator">Stepping through the valuator</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Valuator-step-types">Valuator step types</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Basic-step-accessors">Basic step accessors</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Step-location-accessors">Step location accessors</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Maintaining the stack

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Sizing-the-stack">Sizing the stack</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Events

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Events-overview">Events overview</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Event-codes">Event codes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Basic-event-accessors">Basic event accessors</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Completion-events">Completion events</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Symbol-nulled-events">Symbol nulled events</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Prediction-events">Prediction events</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Symbol-expected-events">Symbol expected events</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Recognizer-per_002dsymbol-events">Recognizer per-symbol events</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Tentative-events">Tentative events</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Ambiguous-parses-and-events">Ambiguous parses and events</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Nulled-subtrees-and-events">Nulled subtrees and events</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Event-coincidence-of-symbol-instances">Event coincidence of symbol instances</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Event-coincidence-of-symbols">Event coincidence of symbols</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Marker-symbols">Marker symbols</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Per_002drule-events">Per-rule events</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Event coincidence of symbol instances

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Nulled-and-completed-symbol-instances">Nulled and completed symbol instances</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Nulled-and-predicted-symbol-instances">Nulled and predicted symbol instances</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Nulled-and-expected-symbol-instances">Nulled and expected symbol instances</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Completed-and-predicted-symbol-instances">Completed and predicted symbol instances</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Completed-and-expected-symbol-instances">Completed and expected symbol instances</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Predicted-and-expected-symbol-instances">Predicted and expected symbol instances</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Per-rule events

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Workaround-with-a-dedicated-LHS-symbol">Workaround with a dedicated LHS symbol</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Tracing and diagnosing parses

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Listing-symbols">Listing symbols</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Listing-rules">Listing rules</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Listing-Earley-sets">Listing Earley sets</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Tracing-tokens">Tracing tokens</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Error methods, macros and codes

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Error-methods">Error methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Error-Macros">Error Macros</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#External-error-codes">External error codes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Internal-error-codes">Internal error codes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Technical notes

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Data-types-used-by-Libmarpa">Data types used by Libmarpa</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Why-so-many-time-objects">Why so many time objects</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Design-of-numbered-objects">Design of numbered objects</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Trap-representations">Trap representations</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Out_002dof_002dmemory-handling">Out-of-memory handling</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Advanced input models

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#The-dense-variable_002dlength-token-model">The dense variable-length token model</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-fully-general-input-model">The fully general input model</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-codepoint_002dper_002dearleme-model">The codepoint-per-earleme model</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Converting-earleme-to-Earley-set-ID">Converting earleme to Earley set ID</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Futures

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Nulling-versus-nulled">Nulling versus nulled</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Document-pre_002dconditions-more-formally">Document pre-conditions more formally</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Simpler-events-interface">Simpler events interface</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Better-defined-ambiguity-metric">Better defined ambiguity metric</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Report-item-traverser-should-be-a-time-object">Report item traverser should be a time object</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Orthogonal-treatment-of-soft-failures">Orthogonal treatment of soft failures</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Orthogonal-treatment-of-exhaustion">Orthogonal treatment of exhaustion</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Furthest-earleme-values">Furthest earleme values</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Additional-recoverable-failures-in-marpa_005fr_005falternative_0028_0029">Additional recoverable failures in marpa_r_alternative()</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Untested-methods">Untested methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Untested methods

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Zero_002dwidth-assertion-methods">Zero-width assertion methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Methods-for-revising-parses">Methods for revising parses</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Deprecated techniques and methods

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#LHS-terminals">LHS terminals</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Valued-and-unvalued-symbols">Valued and unvalued symbols</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Cycles">Cycles</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

LHS terminals

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Overview-of-LHS-terminals">Overview of LHS terminals</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Motivation-of-LHS-terminals">Motivation of LHS terminals</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#LHS-terminal-methods">LHS terminal methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Precomputation-and-LHS-terminals">Precomputation and LHS terminals</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Nulling-terminals">Nulling terminals</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Valued and unvalued symbols

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#What-unvalued-symbols-were">What unvalued symbols were</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Grammar-methods-dealing-with-unvalued-symbols">Grammar methods dealing with unvalued symbols</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Registering-semantics-in-the-valuator">Registering semantics in the valuator</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Annotated bibliography

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#Aho-and-Ullman-1972">Aho and Ullman 1972</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Aycock-and-Horspool-2002">Aycock and Horspool 2002</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#C89">C89</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#C99">C99</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Dominus-2005">Dominus 2005</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Earley-1970">Earley 1970</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Grune-and-Jacobs-1990">Grune and Jacobs 1990</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Grune-and-Jacobs-2008">Grune and Jacobs 2008</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Marpa-theory-paper">Marpa theory paper</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Kegler-2023">Kegler 2023</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Parsing-timeline">Parsing timeline</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Leo-1991">Leo 1991</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Scott-2008">Scott 2008</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Wikipedia-BNF-article">Wikipedia BNF article</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

Acknowledgements

</pre></th></tr><tr><td align="left" valign="top">&bull; <a href="#An-apology">An apology</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><th colspan="3" align="left" valign="top"><pre class="menu-comment">

</pre></th></tr></table>

<hr>
<a name="License"></a>
<div class="header">
<p>
Next: <a href="#Updates" accesskey="n" rel="next">Updates</a>, Previous: <a href="#Top" accesskey="p" rel="prev">Top</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="License-1"></a>
<h2 class="chapter">1 License</h2>

<p>This manual (21 April 2023)
is for Libmarpa 11.0.9.
</p>
<p>Copyright &copy; 2023 Jeffrey Kegler.
</p>
<blockquote>
<p>Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the &ldquo;Software&rdquo;),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:
</p>
<p>The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.
</p>
<p>THE SOFTWARE IS PROVIDED &ldquo;AS IS&rdquo;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
</p></blockquote>


<hr>
<a name="Updates"></a>
<div class="header">
<p>
Next: <a href="#About-this-document" accesskey="n" rel="next">About this document</a>, Previous: <a href="#License" accesskey="p" rel="prev">License</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Updates-1"></a>
<h2 class="chapter">2 Updates</h2>

<p>For important information
that has changed since the last stable release,
there is an &ldquo;updates&rdquo; document
(<a href="https://github.com/jeffreykegler/libmarpa/blob/updated/UPDATES.md">https://github.com/jeffreykegler/libmarpa/blob/updated/UPDATES.md</a>).
The updates document includes
</p><ul>
<li> descriptions of bugs in the latest stable release;
</li><li> notices which are useful to current users,
but which do not justify a full new stable distribution; and
</li><li> other information that we want to be able to update
without issuing a new stable release.
</li></ul>

<p>To allow that information to be kept current
without issuing a new stable release,
we describe how to obtain
support in the updates document.
See <a href="#Support">Support</a>.
</p>
<hr>
<a name="About-this-document"></a>
<div class="header">
<p>
Next: <a href="#Overview-of-Libmarpa" accesskey="n" rel="next">Overview of Libmarpa</a>, Previous: <a href="#Updates" accesskey="p" rel="prev">Updates</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="About-this-document-1"></a>
<h2 class="chapter">3 About this document</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#How-to-read-this-document" accesskey="1">How to read this document</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Prerequisites" accesskey="2">Prerequisites</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="How-to-read-this-document"></a>
<div class="header">
<p>
Next: <a href="#Prerequisites" accesskey="n" rel="next">Prerequisites</a>, Previous: <a href="#About-this-document" accesskey="p" rel="prev">About this document</a>, Up: <a href="#About-this-document" accesskey="u" rel="up">About this document</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="How-to-read-this-document-1"></a>
<h3 class="section">3.1 How to read this document</h3>

<p>This is essentially a reference document,
but its early chapters lay out concepts
essential to the others.
Readers will usually want to read the
chapters up and including
<a href="#Introduction-to-the-method-descriptions">Introduction to the method descriptions</a>
in order.
Otherwise, they should follow their interests.
</p>
<hr>
<a name="Prerequisites"></a>
<div class="header">
<p>
Previous: <a href="#How-to-read-this-document" accesskey="p" rel="prev">How to read this document</a>, Up: <a href="#About-this-document" accesskey="u" rel="up">About this document</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Prerequisites-1"></a>
<h3 class="section">3.2 Prerequisites</h3>

<p>This document is very far from self-contained.
It assumes the following:
</p><ul>
<li> The reader knows the C programming language
at least well
enough to understand function prototypes and return values.
</li><li> The reader
has read the documents for one of Libmarpa&rsquo;s upper layers.
As of this writing, the only such layer is <code>Marpa::R2</code>
or <code>Marpa::R3</code>,
in Perl.
</li><li> The reader knows some parsing theory.
See <a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a>.
</li></ul>

<hr>
<a name="Overview-of-Libmarpa"></a>
<div class="header">
<p>
Next: <a href="#Terms" accesskey="n" rel="next">Terms</a>, Previous: <a href="#About-this-document" accesskey="p" rel="prev">About this document</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Overview-of-Libmarpa-1"></a>
<h2 class="chapter">4 Overview of Libmarpa</h2>

<p>This chapter contains a quick overview of Libmarpa,
using standard parsing terminology.
It is intended to help a prospective reader of
the whole document to know what to
expect.
Details and careful definitions will be provided
in later chapters.
</p>
<p>Libmarpa implements the Marpa parsing algorithm.
Marpa is named
after the legendary 11th century Tibetan translator,
Marpa Lotsawa.
In creating Marpa,
we depended heavily on previous work by Jay Earley,
Joop Leo,
John Aycock and Nigel Horspool.
</p>
<p>Marpa parses any language whose grammar can be written in BNF. That
includes recursive grammars, ambiguous grammars, infinitely ambiguous
grammars and grammars with useless or empty productions. Marpa does both
left- and right-recursion in linear time &ndash; in fact if a grammar is in
any class currently in practical use, Marpa will parse it in linear time.
See <a href="#Marpa-theory-paper">Marpa theory paper</a>.
</p>
<p>Libmarpa implements the entire Marpa algorithm.
This library does
the necessary grammar preprocessing, recognizes the input,
and produces
a &ldquo;bocage&rdquo;, which is
an optimized parse forest.
Libmarpa also supports the ordering, iteration
and evaluation of the parse trees in the bocage.
</p>
<p>Libmarpa is very low-level.
For example, it has no strings.
Rules, symbols, and token values are all represented
by integers.
This, of course, will not suffice for many applications.
Users will very often want
names for the symbols, non-integer values for
tokens, or both.
Typically, applications will use arrays to
translate Libmarpa&rsquo;s integer ID&rsquo;s to strings or other
values as required.
</p>
<p>Libmarpa also does <strong>not</strong> implement most of the semantics.
Libmarpa does have an evaluator (called a &ldquo;valuator&rdquo;),
but it does <strong>not</strong>
manipulate the stack directly.
Instead, Libmarpa,
based on its traversal of the parse tree,
passes optimized step by step stack manipulation
instructions to the upper layer.
These instructions indicate the token or rule involved,
and the proper location for the true token value or
the result of the rule evaluation.
For rule evaluations, the instructions include the stack location
of the arguments.
</p>
<p>Marpa requires most semantics to be
implemented in the application.
This allows the application total flexibility.
It also puts
the application is in a much better position to prevent errors,
to catch errors at runtime or,
failing all else,
to successfully debug the logic.
</p>
<hr>
<a name="Terms"></a>
<div class="header">
<p>
Next: <a href="#Architecture" accesskey="n" rel="next">Architecture</a>, Previous: <a href="#Overview-of-Libmarpa" accesskey="p" rel="prev">Overview of Libmarpa</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Terms_002c-definitions-and-notation"></a>
<h2 class="chapter">5 Terms, definitions and notation</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Miscellaneous-definitions" accesskey="1">Miscellaneous definitions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Parsing-theory-preliminaries" accesskey="2">Parsing theory preliminaries</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Rules" accesskey="3">Rules</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Derivations" accesskey="4">Derivations</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Nulling" accesskey="5">Nulling</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Useless-rules" accesskey="6">Useless rules</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Recursion-and-cycles" accesskey="7">Recursion and cycles</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Trees" accesskey="8">Trees</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#An-example-tree" accesskey="9">An example tree</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Traversal">Traversal</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Semantics-terms">Semantics terms</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Ambiguity">Ambiguity</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Earley-items">Earley items</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Application-and-diagnostic-behavior">Application and diagnostic behavior</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Miscellaneous-definitions"></a>
<div class="header">
<p>
Next: <a href="#Parsing-theory-preliminaries" accesskey="n" rel="next">Parsing theory preliminaries</a>, Previous: <a href="#Terms" accesskey="p" rel="prev">Terms</a>, Up: <a href="#Terms" accesskey="u" rel="up">Terms</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Miscellaneous-definitions-1"></a>
<h3 class="section">5.1 Miscellaneous definitions</h3>

<ul>
<li> <a name="index-application"></a>
<em>Application</em> means an &ldquo;application&rdquo; of Libmarpa.
In this document,
a Libmarpa application is not necessarily an application program.
For our purposes, an &ldquo;application&rdquo;
might be another library that uses Libmarpa.
</li><li> The components of the
<a name="index-application-environment"></a>
<a name="index-environment_002c-application"></a>
<em>application environment</em>
are the system components other than Libmarpa and
the application itself.
Application environments vary,
but their components often include an operating system,
system libraries,
a C compiler and its libraries,
and hardware.
</li><li> A
<a name="index-value_002c-boolean"></a>
<a name="index-boolean"></a>
<a name="index-boolean-value"></a>
<em>boolean</em> value, or <em>boolean</em>,
is an integer that is 0 or 1.
</li><li> An
<a name="index-application-environment-limit"></a>
<a name="index-limit_002c-application-environment"></a>
<em>application environment limit</em>,
more often called simply an
<a name="index-environment-limit"></a>
<a name="index-limit_002c-environment"></a>
<em>environment limit</em>,
is a limit imposed by the application
enviroment.
For our purposes, the most important environment limit
is usually available memory.
</li><li> <a name="index-iff"></a>
The lexeme <em>iff</em> is an abbreviation for &ldquo;if and only if&rdquo;.
</li><li> <a name="index-max_0028x_002cy_0029"></a>
<code>max(x,y)</code> is the maximum of
<code>x</code> and <code>y</code>,
where <code>x</code> and <code>y</code> are two numbers.
</li><li> <a name="index-method"></a>
<em>Libmarpa method</em>, or just <em>method</em>, means a C function
or a function-like macro of the Libmarpa library.
</li><li> <a name="index-user"></a>
<em>User</em> means a &ldquo;user&rdquo; of the Libmarpa library.
A user of the library is also a programmer,
so that in this document, &ldquo;user&rdquo;
and &ldquo;programmer&rdquo; are essentially synonyms.
</li><li> <a name="index-we"></a>
<a name="index-us"></a>
<a name="index-our"></a>
<em>We</em> (as well as &ldquo;us&rdquo; and &rdquo;our&rdquo;) refers to the authors,
but is also intended to suggest that the reader
is joining the authors
on the millenia-old voyage of discovery
into mathematics and language.
As of this writing, there is a one primary author.
</li></ul>

<p>The following terms are used in a way that is consistent
with their use in the C99 standard:
</p><ul>
<li> <a name="index-indeterminate-value"></a>
An <em>indeterminate value</em>
is either an unspecified value or a trap value.
</li><li> <a name="index-trap-value"></a>
A <em>trap value</em>,
also called a <em>trap representation</em>,
is a value that when accessed causes undefined behavior.
See <a href="#Trap-representations">Trap representations</a>.
</li><li> <a name="index-undefined-behavior"></a>
An <em>undefined behavior</em>
is a behavior that this document does not specify.
One implication is that this behavior might be problematic.
</li><li> <a name="index-unspecified-behavior"></a>
An <em>unspecified behavior</em>
is a behavior that, within a range of possibilities,
is not further specified by this document.
This is usually not problematic.
</li><li> <a name="index-unspecified-value"></a>
An <em>unspecified value</em>
is a value on which this document imposes no restrictions,
except that it cannot be a trap value.
</li></ul>

<hr>
<a name="Parsing-theory-preliminaries"></a>
<div class="header">
<p>
Next: <a href="#Rules" accesskey="n" rel="next">Rules</a>, Previous: <a href="#Miscellaneous-definitions" accesskey="p" rel="prev">Miscellaneous definitions</a>, Up: <a href="#Terms" accesskey="u" rel="up">Terms</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Parsing-theory-preliminaries-1"></a>
<h3 class="section">5.2 Parsing theory preliminaries</h3>

<p>This document assumes the reader is familiar with parsing
theory.
The following exposition is <strong>not</strong> intended
as either an introduction or a reference.
Instead, it is intended to serve as a guide to the definitions
of parsing terms as used in this document.
</p>
<p>The definitions given are intended to be applicable within Libmarpa,
rather than to reflect general usage.
For example,
Marpa sometimes uses a standard term
with a definition that is different from
the standard definition.
&ldquo;Ambiguous grammar&rdquo; is one example:
See <a href="#Ambiguity">Ambiguity</a>.
The term &ldquo;terminal&rdquo; is
another.
See <a href="#Terminals">Terminals</a>.
When a standard term is defined in a non-standard way.
this is explicitly pointed out.
</p>
<p>Readers who want a textbook or tutorial in parsing theory
can look at
Mark Jason Dominus&rsquo;s
excellent chapter on parsing in the Perl context.
See <a href="#Dominus-2005">Dominus 2005</a>.
It is available on-line.
Wikipedia is also an excellent place to start.
See <a href="#Wikipedia-BNF-article">Wikipedia BNF article</a>.
</p>
<p>A
<a name="index-grammar"></a>
<em>grammar</em>
is a set of
<a name="index-rule"></a>
<em>rules</em>,
associated with a set of symbols,
one of which is distinguished as the start symbol.
A
<a name="index-symbol-string"></a>
<em>symbol string</em>,
or simply
<a name="index-string"></a>
<em>string</em>
where the meaning is clear,
is an ordered series of symbols.
The
<a name="index-length"></a>
<em>length</em>
of a string is the number of symbols in it.
A symbol string is also called a
<a name="index-sentential-form"></a>
<em>sentential form</em>.
</p>
<p>Some of the symbols are terminals.
For the the moment, we will say that a terminal is a symbol
which may occur in an input to a parse of a grammar.
A careful definition appropriate specifically to Marpa
is below (see <a href="#Terminals">Terminals</a>).
In a parse, an input is either accepted or rejected.
A potential input string,
that is, a sentential form which is made up entirely of terminal symbols,
is called a
<a name="index-sentence"></a>
<em>sentence</em>.
The set of sentences that a grammar accepts is the
<a name="index-language"></a>
<em>language</em>
of the grammar.
</p>
<p>It is important to note that the term language, as it is
used in parsing theory, means something very different
from what it means in ordinary use.
The meaning of the strings is an essential part
of the ordinary idea of what a language is.
In parsing terminology, meaning (or
<a name="index-semantics"></a>
<em>semantics</em>
as it is
called) is a separate issue.
For parsing theory a
language is exactly a set of strings &ndash;
that and nothing more.
</p>
<p>A
<a name="index-recognizer"></a>
<em>recognizer</em>
is a program that determines whether its
<a name="index-input"></a>
<em>input</em>
is in the language of a grammar.
A
<a name="index-parser"></a>
<em>parser</em>
is a program which finds the structure of that input.
</p>
<p>Parsers often use a
<a name="index-lexical-analyzer"></a>
<em>lexical analyzer</em>
to convert
<a name="index-raw-input"></a>
<em>raw input</em>,
usually
<a name="index-input-text"></a>
<em>input text</em>,
into a
<a name="index-token-stream"></a>
<em>token stream</em>,
which is a series of
<a name="index-tokens"></a>
<em>tokens</em>.
Each token represents one or more
<a name="index-symbol"></a>
<em>symbols</em>
of the grammar and has a
<a name="index-value"></a>
<em>value</em>.
(Libmarpa tokens may be ambiguous.
See <a href="#Ambiguous-input">Ambiguous input</a>.)
A token is also sometimes called a
<a name="index-lexeme"></a>
<em>lexeme</em>.
A lexical analyzer is often called a
<a name="index-lexer"></a>
<em>lexer</em>
or a
<a name="index-scanner"></a>
<em>scanner</em>,
and
<a name="index-lexical-analysis"></a>
<em>lexical analysis</em>
is often called
<a name="index-lexing"></a>
<em>lexing</em>
or
<a name="index-scanning"></a>
<em>scanning</em>.
</p>
<p>The series of symbols represented by the series of tokens
becomes the
<a name="index-symbol-string-input"></a>
<em>symbol string input</em>
seen by the recognizer.
The
<a name="index-symbol-string-input-1"></a>
<em>symbol string input</em>
is more often called the
<a name="index-input-sentence"></a>
<em>input sentence</em>,
or simply the
<a name="index-input-1"></a>
<em>input</em>.
</p>
<hr>
<a name="Rules"></a>
<div class="header">
<p>
Next: <a href="#Derivations" accesskey="n" rel="next">Derivations</a>, Previous: <a href="#Parsing-theory-preliminaries" accesskey="p" rel="prev">Parsing theory preliminaries</a>, Up: <a href="#Terms" accesskey="u" rel="up">Terms</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Rules-1"></a>
<h3 class="section">5.3 Rules</h3>

<p>A standard way of describing rules is Backus-Naur Form, or
<a name="index-BNF"></a>
<em>BNF</em>.
In one common way of writing BNF, a rule looks like this:
</p>
<pre class="verbatim">    Expression ::= Term Factor
</pre>
<p>In the rule above, <code>Expression</code>, <code>Term</code> and <code>Factor</code> are symbols.
A rule consists of a
<a name="index-left-hand-side"></a>
<em>left hand side</em>
and a
<a name="index-right-hand-side"></a>
<em>right hand side</em>.
In a
<a name="index-context_002dfree-grammar"></a>
<em>context-free grammar</em>,
like those Marpa parses,
the left hand side of a rule
is always a symbol string of length 1.
The right hand side of a rule is a symbol string of zero or more symbols.
In the example, <code>Expression</code> is the left hand side, and
<code>Term</code> and <code>Factor</code> are right hand side symbols.
</p>
<p>Left hand side and right hand side are often abbreviated as
<a name="index-RHS"></a>
<em>RHS</em>
and
<a name="index-LHS"></a>
<em>LHS</em>.
If the RHS of a rule has no symbols,
the rule is called an
<a name="index-empty-rule"></a>
<em>empty rule</em>
or an
<a name="index-empty-rule-1"></a>
<em>empty rule</em>.
</p>
<p>The
<a name="index-rule-length"></a>
<a name="index-length_002c-rule"></a>
<em>length</em>
of a rule is the length of its RHS string.
This implies that the length of an empty rule
is zero.
</p>
<p>In a standard grammar, all rules are BNF rules,
as just described.
Marpa grammars differ from standard grammars
in allowing a second kind of rule: a
<a name="index-sequence-rule"></a>
<em>sequence rule</em>.
The RHS of a sequence rule is a single symbol,
which is repeated zero or more times.
Libmarpa allows the application to specify other parameters
for sequence rules,
including a separator symbol.
See <a href="#Sequence-rules">Sequence rules</a>.
</p>
<hr>
<a name="Derivations"></a>
<div class="header">
<p>
Next: <a href="#Nulling" accesskey="n" rel="next">Nulling</a>, Previous: <a href="#Rules" accesskey="p" rel="prev">Rules</a>, Up: <a href="#Terms" accesskey="u" rel="up">Terms</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Derivations-1"></a>
<h3 class="section">5.4 Derivations</h3>

<p>A
<a name="index-step"></a>
<em>step</em>
of a derivation, or
<a name="index-derivation-step"></a>
<em>derivation step</em>, is a change made to a symbol string
by applying one of the rules from the grammar.
The rule must be one of those with a LHS that occurs in the symbol string.
The result of the derivation step is another symbol string,
one in which an occurrence of the LHS symbol from the rule is
replaced by the RHS of the rule.
<a name="derivation_002dexample"></a>For example, if <var>A</var>, <var>B</var>, <var>C</var>, <var>D</var>, and <var>X</var> are symbols,
and
</p>
<pre class="verbatim">    X ::= B C
</pre>
<p>is a rule, then
</p>
<pre class="verbatim">    A X D -&gt; A B C D
</pre>
<p>is a derivation step,
</p><ul>
<li> with &ldquo;<code>A X D</code>&rdquo; as its beginning,
</li><li> &ldquo;<code>A B C D</code>&rdquo; as its end or result, and
</li><li> <tt>X ::= B C</tt> as its rule.
</li></ul>
<p>A
<a name="index-derivation"></a>
<em>derivation</em>
is a sequence of derivation steps.
The
<a name="index-length-1"></a>
<em>length</em>
of a derivation is its length in steps.
</p>
<ul>
<li> A string <var>X</var>
<a name="index-derives"></a>
<em>derives</em>
a string <var>Y</var>
iff
there is a derivation of zero or more steps
which begins with the string
<var>X</var> and ends in the string <var>Y</var>.
In the example above (see <a href="#derivation_002dexample">derivation-example</a>),
we say that the symbol string &ldquo;<code>A X D</code>&rdquo;
derives
the symbol string
&ldquo;<code>A B C D</code>&rdquo; in one step.
</li><li> We say that
a first symbol string
<a name="index-directly-derives"></a>
<a name="index-derives_002c-directly"></a>
<em>directly derives</em>
a second symbol string iff there is a derivation of length 1 from the first symbol
string to the second symbol string.
In the example above (see <a href="#derivation_002dexample">derivation-example</a>),
we say that the symbol string &ldquo;<code>A X D</code>&rdquo;
directly derives
the symbol string
&ldquo;<code>A B C D</code>&rdquo;.
</li><li> Every symbol string is said to derive itself in a derivation
of length 0.  A zero length derivation is a
<a name="index-trivial-derivation"></a>
<em>trivial derivation</em>.
</li><li> A derivation which is not trivial
(that is,
a derivation which has one or more steps)
is a
<a name="index-non_002dtrivial"></a>
<em>non-trivial</em>
derivation.
</li><li> If a derivation is not trivial or direct, that is, if it has more than one step,
then it is an
<a name="index-indirect"></a>
<em>indirect</em>
derivation.
</li></ul>

<p>Pedantically, a symbol <var>X</var> and a string
that consists of only that symbol
are two different things.
But we often say &ldquo;the symbol <var>X</var>&rdquo;,
or &ldquo;<var>X</var>&rdquo;,
as shorthand for &ldquo;the string
of length 1
whose only symbol is <var>X</var>&rdquo;.
For example, if the string containing only the
symbol <var>X</var> derives a string <var>Y</var>,
we will usually say simply that &ldquo;<var>X</var> derives <var>Y</var>&rdquo;.
</p>
<p>Wherever symbol or string <var>X</var> derives <var>Y</var>,
we may also say <var>X</var>
<a name="index-produces"></a>
<em>produces</em>
<var>Y</var>.
Derivations are often described as symbol matches.
Wherever symbol or string <var>X</var> derives <var>Y</var>,
we may also say that <var>Y</var>
<a name="index-matches"></a>
<em>matches</em>
<var>X</var>
or that <var>X</var>
<a name="index-matches-1"></a>
<em>matches</em>
<var>Y</var>.
It is particularly common to say that
<var>X</var> matches <var>Y</var> when <var>Y</var> is a sentence.
</p>
<p>The parse of an input by a grammar is
<a name="index-successful"></a>
<em>successful</em>
iff, according to the grammar,
the start symbol produces the input sentence.
The set of all input sentences that
a grammar
will successfully parse is
the
<a name="index-language-1"></a>
<em>language</em>
of
the grammar.
</p>
<hr>
<a name="Nulling"></a>
<div class="header">
<p>
Next: <a href="#Useless-rules" accesskey="n" rel="next">Useless rules</a>, Previous: <a href="#Derivations" accesskey="p" rel="prev">Derivations</a>, Up: <a href="#Terms" accesskey="u" rel="up">Terms</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Nulling-1"></a>
<h3 class="section">5.5 Nulling</h3>

<p>The zero length symbol string is called the
<a name="index-empty-string"></a>
<em>empty string</em>.
The empty string can be considered to be a sentence, in which
case it is the
<a name="index-empty-sentence"></a>
<em>empty sentence</em>.
A string of one or more symbols is
<a name="index-non_002dempty"></a>
<em>non-empty</em>.
A derivation which produces the empty string is a
<a name="index-null-derivation"></a>
<em>null derivation</em>.
A derivation from the start symbol which produces the empty string
is a
<a name="index-null-parse"></a>
<em>null parse</em>.
</p>
<p>If a symbol produces the empty string,
it is a
<a name="index-nullable-symbol"></a>
<em>nullable symbol</em>.
If
the only sentence produced by a symbol is the empty sentence,
it is a
<a name="index-nulling-symbol"></a>
<em>nulling symbol</em>.
All nulling symbols are nullable symbols.
</p>
<p>If a symbol is not nullable, it is
<a name="index-non_002dnullable"></a>
<em>non-nullable</em>.
If a symbol is not nulling, it is
<a name="index-non_002dnulling"></a>
<em>non-nulling</em>.
</p>
<p>A rule is
<a name="index-nullable-rule"></a>
<a name="index-rule_002c-nullable"></a>
<em>nullable</em>
iff it is the rule of the first step of
a null derivation.
A rule is
nullable iff its LHS symbol is nullable.
</p>
<p>A rule <var>r</var> is
<a name="index-nulling-rule"></a>
<a name="index-rule_002c-nulling"></a>
<em>nulling</em>
iff every derivation whose first step has <var>r</var>
as its rule is a null derivation.
A rule is
nulling iff its LHS symbol is nulling.
</p>
<p>If a rule is not nullable, it is
<a name="index-non_002dnullable-1"></a>
<em>non-nullable</em>.
If a rule is not nulling, it is
<a name="index-non_002dnulling-1"></a>
<em>non-nulling</em>.
</p>
<hr>
<a name="Useless-rules"></a>
<div class="header">
<p>
Next: <a href="#Recursion-and-cycles" accesskey="n" rel="next">Recursion and cycles</a>, Previous: <a href="#Nulling" accesskey="p" rel="prev">Nulling</a>, Up: <a href="#Terms" accesskey="u" rel="up">Terms</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Useless-rules-1"></a>
<h3 class="section">5.6 Useless rules</h3>

<p>If any derivation from the start symbol uses a rule,
that rule is called
<a name="index-reachable-rule"></a>
<a name="index-rule_002c-reachable"></a>
<em>reachable</em>
or
<a name="index-accessible-rule"></a>
<a name="index-rule_002c-accessible"></a>
<em>accessible</em>.
A rule that is not accessible
is called
<a name="index-unreachable-rule"></a>
<a name="index-rule_002c-unreachable"></a>
<em>unreachable</em>
or
<a name="index-inaccessible-rule"></a>
<a name="index-rule_002c-inaccessible"></a>
<em>inaccessible</em>.
A symbol is
<a name="index-reachable-symbol"></a>
<a name="index-symbol_002c-reachable"></a>
<em>reachable</em>
or
<a name="index-accessible-symbol"></a>
<a name="index-symbol_002c-accessible"></a>
<em>accessible</em>
iff it appears in a accessible rule.
If a symbol is not accessible, it is
<a name="index-unreachable-symbol"></a>
<a name="index-symbol_002c-unreachable"></a>
<a name="index-unreachable"></a>
<em>unreachable</em>
or
<a name="index-inaccessible-symbol"></a>
<a name="index-symbol_002c-inaccessible"></a>
<em>inaccessible</em>.
</p>
<p>If any derivation which results in a sentence uses a rule,
that rule is said to be
<a name="index-productive-rule"></a>
<a name="index-rule_002c-productive"></a>
<em>productive</em>.
A rule that is not productive is called
<a name="index-unproductive-rule"></a>
<a name="index-rule_002c-unproductive"></a>
<em>unproductive</em>.
A rule is productive iff every symbol on
its RHS is productive.
An empty rule is productive, vacuously.
</p>
<p>A symbol is
<a name="index-productive-symbol"></a>
<a name="index-symbol_002c-productive"></a>
<em>productive</em>
iff
it is a terminal or it is the LHS of a productive rule.
A symbol that is not productive is called
<a name="index-unproductive-symbol"></a>
<a name="index-symbol_002c-unproductive"></a>
<em>unproductive</em>.
</p>
<p>These definitions imply that all nullable rules are productive.
They also imply that every nullable symbol is productive,
because every nullable symbol must be on the LHS of a nullable rule.
</p>
<p>A rule which is inaccessible or unproductive is called a
<a name="index-useless-rule"></a>
<a name="index-rule_002c-useless"></a>
<em>useless</em>
rule.
A symbol which is inaccessible or unproductive is called a
<a name="index-useless-symbol"></a>
<a name="index-symbol_002c-useless"></a>
<em>useless</em>
symbol.
Marpa can handle grammars with useless rules and symbols.
</p>
<hr>
<a name="Recursion-and-cycles"></a>
<div class="header">
<p>
Next: <a href="#Trees" accesskey="n" rel="next">Trees</a>, Previous: <a href="#Useless-rules" accesskey="p" rel="prev">Useless rules</a>, Up: <a href="#Terms" accesskey="u" rel="up">Terms</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Recursion-and-cycles-1"></a>
<h3 class="section">5.7 Recursion and cycles</h3>

<p>If any symbol in the grammar non-trivially produces a symbol string containing itself,
the grammar is said to be
<a name="index-recursive"></a>
<em>recursive</em>.
If any symbol non-trivially produces a symbol string in which it is the leftmost symbol,
the grammar is said to be
<a name="index-left_002drecursive"></a>
<em>left-recursive</em>.
If any symbol non-trivially produces a symbol string in which it is the rightmost symbol,
the grammar is said to be
<a name="index-right_002drecursive"></a>
<em>right-recursive</em>.
Marpa can handle all recursive grammars,
including
grammars which are left-recursive,
grammars which are right-recursive,
and grammars
which contain both left- and right-recursion.
</p>
<p>A
<a name="index-cycle"></a>
<em>cycle</em>
is a non-trivial derivation
of a string of symbols from itself.
If it is not possible for any derivation using a grammar
to contain a cycle,
then that grammar is said to be
<a name="index-cycle_002dfree"></a>
<em>cycle-free</em>.
Traditionally, a grammar is
considered useless
if it is not cycle-free.
</p>
<p>The traditional deprecation of cycles is well-founded.
A cycle is
the parsing equivalent of an infinite loop.
Once a cycle appears, it can be
repeated over and over again.
Even a very short input sentence can have an
infinite number of parses when the grammar is not
cycle-free.
</p>
<p>For that reason,
a grammar which contains a cycle is also
called
<a name="index-infinitely-ambiguous"></a>
<em>infinitely ambiguous</em>.
Marpa can parse with grammars which are not
cycle-free,
but use of this feature is deprecated.
See <a href="#Cycles">Cycles</a>.
</p>
<hr>
<a name="Trees"></a>
<div class="header">
<p>
Next: <a href="#An-example-tree" accesskey="n" rel="next">An example tree</a>, Previous: <a href="#Recursion-and-cycles" accesskey="p" rel="prev">Recursion and cycles</a>, Up: <a href="#Terms" accesskey="u" rel="up">Terms</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Trees-1"></a>
<h3 class="section">5.8 Trees</h3>

<p>In this document,
unless otherwise stated,
</p><ul>
<li> by
<a name="index-tree"></a>
<em>tree</em>,
we mean a
<a name="index-labeled-ordered-tree"></a>
<a name="index-tree_002c-labeled-ordered"></a>
<em>labeled ordered tree</em>; and
</li><li> by
<a name="index-tree-node"></a>
<em>tree node</em>,
we mean a
<a name="index-labeled-ordered-tree-node"></a>
<a name="index-node_002c-labeled-ordered-tree"></a>
<a name="index-tree-node_002c-labeled-ordered"></a>
<em>labeled ordered tree node</em>.
</li></ul>
<p>For brevity,
in contexts where the meaning is clear,
we refer to a tree node simply as a
<a name="index-node-_0028of-a-tree_0029"></a>
<em>node</em>.
A node is a pair:
</p><ul>
<li> The first element of a node is
a &ldquo;label tuple&rdquo;.
The label tuple is a triple
of symbol ID,
start Earley set ID, and
end Earley set ID.
For more about the Earley set IDs,
see <a href="#Input">Input</a>.
</li><li> The second element of a node is
a sequence of nodes.
Our definition of a tree node is therefore recursive.
</li></ul>

<p>When looked at from the point of view
of its labels,
a node
is often called an
<a name="index-instance"></a>
<em>instance</em>.
In the following list of definitions and assertions, let
</p><pre class="verbatim">     nd = &lt; &lt; sym, start, end &gt;, children &gt;
</pre><p>be a tree node.
</p><ul>
<li> We say that
<code>sym</code> is the symbol of <code>nd</code>.
</li><li> We say that <code>nd</code> is an
<a name="index-instance-_0028of-a-symbol_0029"></a>
<em>instance</em> of the symbol with ID <code>sym</code>
starting at <code>start</code> and ending at <code>end</code>.
We often write this as
<a name="index-_0040_002dnotation-for-symbol-instance"></a>
<code>sym</code>@<code>start</code>-<code>end</code>.
</li><li> We say that <code>nd</code> is an
<a name="index-instance-_0028of-a-symbol_0029-1"></a>
<em>instance</em> of the symbol with ID <code>sym</code> at location <code>end</code>.
</li><li> We say that the
<a name="index-length-_0028of-a-node_0029"></a>
<a name="index-node-length"></a>
<em>length</em> of <code>nd</code> is the
difference between its start and end,
that is <code>end-start</code>.
</li><li> The length of <code>nd</code> is zero iff
<code>start</code> is the same as <code>end</code>.
Put another way,
the length of <code>nd</code> is zero iff
<code>start = end</code>.
</li><li> We say that the elements of <code>children</code>
are the
<a name="index-children-_0028of-a-node_0029"></a>
<em>children</em>
of <code>nd</code>.
</li><li> We say that every element of <code>children</code>
is a
<a name="index-child-_0028of-a-node_0029"></a>
<em>child</em>
of <code>nd</code>.
</li><li> For brevity, we say
that the symbol <code>sym</code> is
<a name="index-at-_0028a-location_002c-wrt-a-symbol_0029"></a>
<em>at</em>
<code>end</code>.
We note that this means we consider the location of a symbol
to be where it ends.
</li><li> <code>nd</code> is a
<a name="index-leaf-node"></a>
<em>leaf node</em> iff <code>children</code>
is the empty list.
A leaf node is also called a
<a name="index-leaf-_0028node_0029"></a>
<em>leaf</em>.
</li><li> <code>nd</code> is a
<a name="index-rule-node"></a>
<em>rule node</em> iff it is not a leaf node.
</li><li> Every node is either a leaf node or a rule node.
No node is both a leaf and a rule node.
</li><li> We say that <code>nd</code> is a
<a name="index-terminal-node"></a>
<em>terminal node</em>
iff <code>nd</code> is a leaf node
and <code>sym</code> is a terminal.
A terminal node is also called a
<a name="index-token-node"></a>
<em>token node</em>.
</li><li> We say that <code>nd</code> is a
<a name="index-nulled-node"></a>
<em>nulled node</em>
iff <code>nd</code> is a leaf node
and <code>sym</code> is <strong>not</strong> a terminal.
A nulled node is also called a
<a name="index-nulling-node"></a>
<em>nulling node</em>.
</li><li> Every leaf node is either a nulled node or a terminal node.
But, because nullable LHS terminals are not allowed,
no node is both nulled and terminal.
</li><li> We say that <code>nd</code>
is a
<a name="index-BNF-node"></a>
<em>BNF node</em>
iff
<code>nd</code> is not a terminal node
and <code>sym</code> is the LHS of a BNF rule.
</li><li> We say that <code>nd</code>
is a
<a name="index-sequence-node"></a>
<em>sequence node</em>
iff
<code>nd</code> is not a terminal node
and <code>sym</code> is the LHS of a sequence rule.
</li><li> Every node is a terminal node, a BNF node
or a sequence node.
But no node is more
than one of the these three.
This is because sequence rules never share a
LHS with a BNF rule,
and no BNF node or sequence node is a terminal node.
</li><li> If <code>nd</code> is a rule node, its
<a name="index-LHS-_0028of-a-rule-node_0029"></a>
<em>LHS</em> is <code>sym</code>.
</li><li> If <code>nd</code> is a rule node, its
<a name="index-RHS-_0028of-a-rule-node_0029"></a>
<em>RHS</em> is the concatenation,
from first to last,
of the symbols of the nodes in <code>children</code>.
</li><li> All nulled nodes are zero-length.
No terminal node is zero-length.
</li><li> We say that <code>nd</code> is an instance of
<code>sym</code> starting at <code>start</code> and ending
at <code>end</code>.
We also say that <code>nd</code> is an instance of
<code>sym</code> at <code>end</code> or, simply,
that <code>nd</code> is an instance of <code>sym</code>.
</li><li> Let <var>r</var> be the BNF rule whose LHS
is equal to the LHS of <code>nd</code>,
and whose RHS is equal to the RHS of <code>nd</code>.
If <code>nd</code> is a BNF rule node,
there must be such a rule.
In that case,
we say that <code>nd</code> is an instance of
<var>r</var> starting at <code>start</code> and ending
at <code>end</code>.
We often write this as
<a name="index-_0040_002dnotation-for-rule-instance"></a>
<code>r</code>@<code>start</code>-<code>end</code>.
We also say that <code>nd</code> is an instance of
<var>r</var> at <code>end</code> or, simply,
that <code>nd</code> is an instance of <var>r</var>.
</li><li> Let <var>r</var> be the sequence rule whose LHS
is equal to the LHS of <code>nd</code>.
If <code>nd</code> is a sequence rule node,
there must be such a rule.
In that case,
we say that <code>nd</code> is an instance of
<var>r</var> starting at <code>start</code> and ending
at <code>end</code>.
We often write this as
<a name="index-_0040_002dnotation-for-sequence-instance"></a>
<code>r</code>@<code>start</code>-<code>end</code>.
We also say that <code>nd</code> is an instance of
<var>r</var> at <code>end</code> or, simply,
that <code>nd</code> is an instance of <var>r</var>.
</li><li> <a name="index-nulled-symbol-instance"></a>
<a name="index-symbol-instance_002c-nulled"></a>
If <code>nd</code> is a nulled instance,
we say that <code>sym</code> is
<a name="index-nulled-_0028of-a-symbol_0029"></a>
<em>nulled</em> at location <code>end</code> or, simply,
that the symbol <code>sym</code> is nulled.
We can write this as
<a name="index-_0040_002dnotation-for-nulled-instance"></a>
<code>nulled</code>@<code>end</code>-<code>end</code>.
</li></ul>

<p>Let <var>nd1</var> and <var>nd2</var> be two nodes.
If <var>nd2</var> is a child of <var>nd1</var>,
then <var>nd1</var> is the
<a name="index-parent-_0028wrt-a-node_0029"></a>
<em>parent</em> of <var>nd2</var>.
</p>
<p>We define
<a name="index-ancestor"></a>
<em>ancestor</em>
recursively
such that
<var>nd1</var> is the ancestor
of a node <var>nd2</var>
iff one of the following are true:
</p><ul>
<li> <var>nd1</var> and <var>nd2</var> are the same node.
In this case we say that <var>nd1</var> is the
<a name="index-trivial-ancestor"></a>
<a name="index-ancestor_002c-trivial"></a>
<em>trivial ancestor</em>
of <var>nd2</var>.
</li><li> <var>nd1</var> is the parent of an ancestor of <var>nd2</var>.
In this case we say that <var>nd1</var> is a
<a name="index-proper-ancestor"></a>
<a name="index-ancestor_002c-proper"></a>
<em>proper ancestor</em>
of <var>nd2</var>.
</li></ul>

<p>Simlarly, we define
<a name="index-descendant"></a>
<em>descendant</em>
recursively
such that
<var>nd1</var> is the descendant
of a node <var>nd2</var>
iff one of the following are true:
</p><ul>
<li> <var>nd1</var> and <var>nd2</var> are the same node.
In this case we say that <var>nd1</var> is the
<a name="index-trivial-descendant"></a>
<a name="index-descendant_002c-trivial"></a>
<em>trivial descendant</em>
of <var>nd2</var>.
</li><li> <var>nd1</var> is the parent of an descendant of <var>nd2</var>.
In this case we say that <var>nd1</var> is a
<a name="index-proper-descendant"></a>
<a name="index-descendant_002c-proper"></a>
<em>proper descendant</em>
of <var>nd2</var>.
</li></ul>

<p>A tree is its own
<a name="index-root-node"></a>
<a name="index-node_002c-root"></a>
<em>root node</em>.
That implies that, in fact, tree and node are just two different terms for the
same thing.
We usually speak of trees when we are thinking of the nodes/trees
as a collection of nodes,
and we
speak of nodes when we are more focused on the individual nodes.
</p>
<p>We sometimes call a root node, a
<a name="index-node_002c-start"></a>
<a name="index-start-node"></a>
<em>start node</em>.
We do this especially in contexts where a tree is &ldquo;top-level&rdquo;,
that is, not the child of any other tree under discussion.
</p>
<p>If <code>t1</code> and <code>t2</code> are trees,
and <code>t2</code> (considered as a node) is a descendant
of <code>t1</code>,
then we say <code>t2</code> is a
<a name="index-subtree"></a>
<em>subtree</em>
of <code>t1</code>.
By this definition, every tree is a subtree
of itself.
</p>
<p>A
<a name="index-parse-_0028forest_0029"></a>
<a name="index-parse-forest"></a>
<a name="index-forest"></a>
<em>parse forest</em>
is a set of one or more
parse trees.
</p>
<p>We use &ldquo;parse&rdquo; as a noun in several senses.
Depending on context a
<a name="index-parse-_0028aka-parse-run_0029"></a>
<a name="index-parse-_0028aka-parse-tree_0029"></a>
<a name="index-parse-_0028aka-parse-forest_0029"></a>
<em>parse</em>
may be
</p><ul>
<li> a parse run, that is, an instance of running a parser on
an input using a grammar;
</li><li> a parse tree; or
</li><li> a parse forest.
</li></ul>
<p>When the meaning of &ldquo;parse&rdquo; is not clear in context,
we will be explicit about which sense is intended.
</p>
<hr>
<a name="An-example-tree"></a>
<div class="header">
<p>
Next: <a href="#Traversal" accesskey="n" rel="next">Traversal</a>, Previous: <a href="#Trees" accesskey="p" rel="prev">Trees</a>, Up: <a href="#Terms" accesskey="u" rel="up">Terms</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="An-example-tree-1"></a>
<h3 class="section">5.9 An example tree</h3>

<pre class="verbatim">     &lt; &lt; &quot;S&quot;, 0, 7 &gt;, [
         &lt; &lt; &quot;A&quot;, 0, 2 &gt;, [
             &lt; &lt; &quot;T&quot;, 0, 1 &gt;, [ ] &gt;,
             &lt; &lt; &quot;U&quot;, 1, 2 &gt;, [ ] &gt;
         ] &gt;,
         &lt; &lt; &quot;B&quot;, 2, 2 &gt;, [ ] &gt;,
         &lt; &lt; &quot;C&quot;, 2, 3 &gt;, [
             &lt; &lt; &quot;V&quot;, 2, 3 &gt;, [ ] &gt;
         ] &gt;,
         &lt; &lt; &quot;D&quot;, 3, 5 &gt;, [
             &lt; &lt; &quot;W&quot;, 3, 4 &gt;, [ ] &gt;,
             &lt; &lt; &quot;X&quot;, 4, 5 &gt;, [ ] &gt;
         ] &gt;,
         &lt; &lt; &quot;E&quot;, 5, 7 &gt;, [
             &lt; &lt; &quot;Y&quot;, 5, 6 &gt;, [ ] &gt;,
             &lt; &lt; &quot;Z&quot;, 6, 7 &gt;, [ ] &gt;
         ] &gt;
      ] &gt;
</pre>
<p>In the tree above, we use symbol names (for example, <code>&quot;S&quot;</code>)
as symbol IDs.
Since we have not used the same symbol twice, we will be able to
refer to a node by its symbol name.
In practical parse trees, symbols usually occur many times.
</p>
<p>Node <code>S</code> has 5 children.
Node <code>A</code> has 2 children.
Node <code>B</code> has no children and is a nulled node.
Nodes <code>T</code>, <code>U</code>, <code>V</code>, <code>W</code>, <code>X</code>,
<code>Y</code>, and <code>Z</code>
are terminal nodes.
Nodes
<code>S</code>,
<code>A</code>,
<code>C</code>,
<code>D</code>, and
<code>E</code>
are BNF rule nodes.
The tree implies a grammar with at least
the following rules:
</p><pre class="verbatim">    S ::= A B C D E
    A ::= T U
    B ::=
    C ::= V
    D ::= W X
    E ::= Y Z
</pre>
<p>The tree derives the sentence
</p><pre class="verbatim">      T U V W X Y X
</pre><p>and can do so in several ways.
One is these is its rightmost derviation:
</p><pre class="verbatim">    S -&gt; A B C D E
      -&gt; A B C D Y Z
      -&gt; A B C W X Y Z
      -&gt; A B V W X Y Z
      -&gt; A V W X Y Z
      -&gt; T U V W X Y Z
</pre><p>This is called the
<a name="index-rightmost-derivation"></a>
<a name="index-derivation_002c-rightmost"></a>
<em>rightmost derviation</em>
because,
at each derivation step,
the symbol that is expanded is the rightmost symbol possible.
There is also a
<a name="index-leftmost-derivation"></a>
<a name="index-derivation_002c-leftmost"></a>
<em>leftmost derivation</em>:
</p><pre class="verbatim">    S -&gt; A B C D E
      -&gt; T U B C D E
      -&gt; T U C D E
      -&gt; T U V D E
      -&gt; T U V W X E
      -&gt; T U V W X Y Z
</pre>

<hr>
<a name="Traversal"></a>
<div class="header">
<p>
Next: <a href="#Semantics-terms" accesskey="n" rel="next">Semantics terms</a>, Previous: <a href="#An-example-tree" accesskey="p" rel="prev">An example tree</a>, Up: <a href="#Terms" accesskey="u" rel="up">Terms</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Traversal-1"></a>
<h3 class="section">5.10 Traversal</h3>

<p>We often want to &ldquo;visit&rdquo; all the nodes of a tree in a sequence,
or
<a name="index-traverse"></a>
<em>traverse</em>
the tree.
In the semantics phase,
it is often necessary to visit all the children of a node
before the node itself.
We can do this using a
<a name="index-postorder-traversal"></a>
<em>postorder traversal</em>
traversal.
Here is a recursive procedure for a postorder traversal
of the tree <code>nd</code>:
</p><pre class="verbatim">         If nd is not well-defined, return
         Traverse the children of nd, in order
         Visit nd
</pre><p>A postorder traversal is also often called a
<a name="index-depth_002dfirst-traversal"></a>
<em>depth-first traversal</em>,
or a
<a name="index-bottom_002dup-traversal"></a>
<em>bottom-up traversal</em>.
A postorder traversal of our example tree (see <a href="#An-example-tree">An example tree</a>)
visits the nodes in the following order:
</p><pre class="verbatim">    T U A B V C W X D Y Z E S
</pre>
<hr>
<a name="Semantics-terms"></a>
<div class="header">
<p>
Next: <a href="#Ambiguity" accesskey="n" rel="next">Ambiguity</a>, Previous: <a href="#Traversal" accesskey="p" rel="prev">Traversal</a>, Up: <a href="#Terms" accesskey="u" rel="up">Terms</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Semantics-terms-1"></a>
<h3 class="section">5.11 Semantics terms</h3>

<p>Rarely is an application interested only in the tree.
Traditionally and most often, the tree
is an intermediate step in producing the &ldquo;value&rdquo; of the parse run.
A value of a parse run is a &ldquo;meaning&rdquo; of the input string.
</p>
<p>Grammars almost always have a
<a name="index-semantics-1"></a>
<em>semantics</em>
associated with them.
The purpose of parsing is to use the
grammar and its semantics to find the
<a name="index-value-1"></a>
<em>value</em>
of the input string.
Finding the value of a parse tree
is called
<a name="index-evaluate-_0028a-tree_0029"></a>
<em>evaluating a tree</em>.
More loosely,
we also speak of
<a name="index-evaluate-_0028a-parse-run_0029"></a>
<em>evaluating the parse run</em>,
or
<a name="index-evaluate-_0028an-input-string_0029"></a>
<em>evaluating the input string</em>.
</p>
<p>We recall that Libmarpa provides instructions for stack manipulation.
See <a href="#Value-methods">Value methods</a>.
Libmarpa does not directly do evaluation
because Libmarpa is usually used
together with a higher-level language,
and the semantics is first known,
and the evaluation is most easily performed,
in the higher-level language.
</p>
<p>In the most common method of evaluating a parse tree,
every node
has a value associated with it.
An application might determine the value of a terminal node from
</p><ul>
<li> the node&rsquo;s symbol;
</li><li> a &ldquo;token value&rdquo;, which Libmarpa allows the user
to specify for
each input symbol at the time the input symbol is recognized;
</li><li> context information, including the node&rsquo;s location information; or
</li><li> any combination of the above.
</li></ul>

<p>In determining the value of nulled nodes, the application may also
consider the node&rsquo;s symbol and context information.
Libmarpa prunes nulled subtrees back to their root,
which usually is what the application expects.
The evaluation of nulled nodes is discussed in detail
in the chapter on nullability.
See <a href="#Nullability">Nullability</a>.
</p>
<p>To find the value of a rule node, an application
may use the rule, context information, and the values of the
rule node&rsquo;s children.
Let <code>nd</code> be a rule node,
and let <code>childCount</code> be the number of children of <code>nd</code>.
Frequently, the semantics of <code>nd</code> is implemented as
a &ldquo;semantic function&rdquo;.
The arguments of the semantic function are typically a scratchpad variable, call it <code>scratch</code>,
followed by the values of the children of <code>nd</code>,
so that the number of arguments for the function is <code>childCount+1</code>.
The return value of the semantic function becomes the value of <code>nd</code>.
</p>
<p>Semantic functions often have side effects.
For example, a grammar for a language often wants its semantic functions
to build and refer to a symbol table.
The <code>scratch</code> variable allows for this.
</p>
<p>Implementing this traditional method of tree evaluation requires
a bottom-up traversal of the parse tree.
In the final step of a bottom-up traversal,
the start node is evaluated,
and the value of the start node becomes the value of the parse run.
</p>
<hr>
<a name="Ambiguity"></a>
<div class="header">
<p>
Next: <a href="#Earley-items" accesskey="n" rel="next">Earley items</a>, Previous: <a href="#Semantics-terms" accesskey="p" rel="prev">Semantics terms</a>, Up: <a href="#Terms" accesskey="u" rel="up">Terms</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Ambiguity-1"></a>
<h3 class="section">5.12 Ambiguity</h3>

<p>In our discussion of evaluation above
(see <a href="#Semantics-terms">Semantics terms</a>),
we spoke of evaluating trees.
In fact, the result of a successful Libmarpa parse run is a parse forest.
We say that a Libmarpa parse run is
<a name="index-ambiguous"></a>
<em>ambiguous</em>
iff the parse run returns
a forest containing more than one parse tree.
We say that a succcessful Libmarpa parse run is
<a name="index-unambiguous"></a>
<em>unambiguous</em>
iff
it contains exactly one parse tree.
</p>
<p>Most applications care only about one parse tree.
An application is free to decide what to do in case a parse
forest is ambiguous.
Among the application&rsquo;s options are picking one tree and evaluating that tree;
iterating through the parse trees;
or treating the ambiguity as an error.
</p>
<p>Libmarpa&rsquo;s treatment of ambiguity differs somewhat
from the traditional one, for two reasons.
First, Libmarpa allows ambiguous tokens.
Second, Libmarpa prunes nulled subtrees back to their topmost
nulled symbol.
</p>
<p>An ambiguous token occurs when the same lexeme can be
recognized as more than one token symbol.
Traditionally, parsers do not allow this,
but it is the most natural way of parsing some real-life applications.
For example, natural languages often allow words to be
used as more than one part of speech.
In this document, the English word &ldquo;parse&rdquo;
is used as an adjective, a verb, and a noun,
and each of these uses is common.
Ambiguous tokens are
a source of ambiguity not present in traditional
parsing.
See <a href="#Ambiguous-input">Ambiguous input</a>.
</p>
<p>On the other hand, the pruning of nulled subtrees
eliminates a source of ambiguity
that is present in traditional parsing.
Multiple nulled subtrees may share their topmost nulled symbol.
When the subtrees are pruned to their shared root,
ambiguity is removed.
See <a href="#Nullability">Nullability</a>.
</p>
<hr>
<a name="Earley-items"></a>
<div class="header">
<p>
Next: <a href="#Application-and-diagnostic-behavior" accesskey="n" rel="next">Application and diagnostic behavior</a>, Previous: <a href="#Ambiguity" accesskey="p" rel="prev">Ambiguity</a>, Up: <a href="#Terms" accesskey="u" rel="up">Terms</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Earley-items-1"></a>
<h3 class="section">5.13 Earley items</h3>

<p>We assume knowledge of Earley&rsquo;s algorithm.
This section is intended as a reminder,
and to set out our choices for notation and
terminology.
</p>
<p>A
<a name="index-dotted-rule"></a>
<em>dotted rule</em>
is a duple of rule and
position in the rule.
The position must be an non-negative integer
that is not greater than the length of the rule.
For example,
</p><div class="display">
<pre class="display">     [ [ A ::= X Y Z ], 2 ]      (DR1)
</pre></div>
<p>is a dotted rule
whose rule is
<code>[ A ::= X Y Z ]</code> and whose position is 2.
More often a dotted rule is written
with the position marked in the RHS of the rule.
Here we use &ldquo;&bull;&rdquo; as our marker, so that
in <code>(DR1)</code> the &ldquo;&bull;&rdquo; would come after
the 2nd symbol on the RHS,
and <code>(DR1)</code> would be written
</p><div class="display">
<pre class="display">     [ A ::= X Y &bull; Z ].
</pre></div>
<p>Traditionally the marker is a raised dot,
and this is where the term &ldquo;dotted rule&rdquo;
comes from.
The position of the dotted rule is almost always
called the
<a name="index-dot-position"></a>
<em>dot position</em>.
</p>
<p>An
<a name="index-Earley-item"></a>
<em>Earley item</em>
is a triple of dotted rule, origin
and current parse location.<a name="DOCF1" href="#FOOT1"><sup>1</sup></a>
The Earley item makes a statement about the progress
of a parse.
The
<a name="index-origin-_0028in-an-Earley-item_0029"></a>
<em>origin</em>
is the parse location where recognition of the
dotted rule begins.
The
<a name="index-current-location-_0028in-an-Earley-item_0029"></a>
<em>current location</em>
is the parse location which recognition of the dotted rule
has reached.
Symbols before the dot position of the dotted rule have been
recognized,
and symbols after the dot position of the dotted rule have yet
to be recognized.
</p>
<p>For example,
in the Earley item
</p><div class="display">
<pre class="display">     [ [ A ::= X Y &bull; Z ], 7, 42],
</pre></div>
<p>the dotted rule <code>[ A ::= X Y &bull; Z ]</code> was recognized
as far as the dot position, starting at parse location 7
and ending at parse location 42.
More precisely,
</p><ul>
<li> the rule <code>[ A ::= X Y Z ]</code> was expected
    beginning at parse location 7;
</li><li> the string of symbols &ldquo;<code>X Y</code>&rdquo; has been recognized
    starting at parse location 7,
    which implies that the symbol <code>X</code> has been recognized
    starting at parse location 7;
</li><li> the string of symbols &ldquo;<code>X Y</code>&rdquo; has been recognized
    ending at parse location 42,
    which implies that the symbol <code>Y</code> has been recognized
    ending at parse location 42; and
</li><li> the symbol <code>Z</code> has yet to recognized,
    but is expected starting at parse location 42.
</li></ul>

<p>The Earley set at location <code>j</code>
is the set of Earley items whose current location is <code>j</code>.
For example, the Earley item
<code>[ [ A ::= X Y &bull; Z ], 7, 42]</code>
is in the Earley set at location 42.
</p>
<p>We say that a dotted rule is
<a name="index-completed-dotted-rule"></a>
<em>completed</em>
iff its dot position is after the last symbol.
We say that an Earley item is
<a name="index-completed-Earley-item"></a>
<em>completed</em>
iff its dotted rule is completed.
For example, the Earley item
</p><div class="display">
<pre class="display">     [ [ A ::= X Y Z &bull; ], 7, 50],
</pre></div>
<p>is completed.
A completed dotted rule is also called a
<a name="index-completion-_0028dotted-rule_0029"></a>
<em>completion</em>.
Similarly, a completed Earley item is also called a
<a name="index-completion-_0028Earley-item_0029"></a>
<em>completion</em>.
</p>
<p>We say that a dotted rule is
<a name="index-predicted-dotted-rule"></a>
<em>predicted</em>
iff its dot position is before the first symbol.
We say that an Earley item is
<a name="index-predicted-Earley-item"></a>
<em>predicted</em>
iff its dotted rule is predicted.
For example, the Earley item
</p><div class="display">
<pre class="display">     [ [ A ::= &bull; X Y Z ], 7, 7],
</pre></div>
<p>is predicted.
A predicted dotted rule is also called a
<a name="index-prediction-_0028dotted-rule_0029"></a>
<em>prediction</em>.
Similarly, a predicted Earley item is also called a
<a name="index-prediction-_0028Earley-item_0029"></a>
<em>prediction</em>.
</p>
<p>The
<a name="index-postdot-symbol-_0028of-a-dotted-rule_0029"></a>
<em>postdot symbol</em>
of a dotted rule is the RHS symbol after the
dot position.
For example, in the dotted rule,
</p><div class="display">
<pre class="display">     [ A ::= X Y &bull; Z ]
</pre></div>
<p>the postdot symbol is <code>Z</code>.
If the dotted rule is a completion,
its postdot symbol is not defined.
</p>
<p>The
<a name="index-postdot-symbol-_0028of-an-Earley-item_0029"></a>
<em>postdot symbol</em>
of an Earley item
is the postdot symbol of its dotted rule.
The postdot symbol of an Earley item is an
<a name="index-expected-symbol"></a>
<em>expected symbol</em>
at its current location.
For example,
the Earley item
</p><div class="display">
<pre class="display">     [ [ A ::= X Y &bull; Z ], 7, 42],
</pre></div>
<p>indicates that the symbol <code>Z</code>
is expected at location 42.
</p>
<p>Let <code>sym</code> be a symbol,
and let <code>j</code> be a parse location.
Unless <code>sym</code> is expected at <code>j</code>,
that is, unless <code>sym</code> is a postdot symbol of some Earley
item in the Earley set at <code>j</code>,
<code>sym</code> will be rejected by the
<code>marpa_r_alternative()</code> method
at current location <code>j</code>.
See <a href="#marpa_005fr_005falternative">marpa_r_alternative</a>.
</p>
<hr>
<a name="Application-and-diagnostic-behavior"></a>
<div class="header">
<p>
Previous: <a href="#Earley-items" accesskey="p" rel="prev">Earley items</a>, Up: <a href="#Terms" accesskey="u" rel="up">Terms</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Application-and-diagnostic-behavior-1"></a>
<h3 class="section">5.14 Application and diagnostic behavior</h3>

<p>An
<a name="index-application-behavior"></a>
<a name="index-behavior_002c-application"></a>
<em>application behavior</em>
is a behavior on which it is intended that
the design of applications
will be based.
In this document,
a behavior is an application behavior unless otherwise stated.
We sometimes say that &ldquo;applications may expect&rdquo; a certain behavior
to emphasize that that behavior is an application behavior.
</p>
<p>After an irrecoverable failure, the behavior of a Libmarpa application
is undefined,
so that there are no behaviors that can be relied on for normal
application processing,
and therefore, there are no application behaviors.
In this circumstance,
some of the application behaviors become
diagnostic behaviors.
A
<a name="index-diagnostic-behavior"></a>
<a name="index-behavior_002c-diagnostic"></a>
<em>diagnostic behavior</em>
is a behavior that this document suggests
that the programmer may attempt in the face of an irrecoverable failure,
for purposes of testing, diagnostics and debugging.
Diagnostic behaviors are hoped for, rather than expected,
and intended
to allow the programmer to deal with irrecoverable
failures as smoothly as possible.
(See <a href="#Failure">Failure</a>.)
</p>
<p>In this document,
a behavior is a diagnostic behavior only if that is specifically
indicated.
Applications should not be designed to rely
on diagnostic behaviors.
We sometimes say that the application &ldquo;may attempt&rdquo; a certain behavior
to emphasize that that behavior is a diagnostic behavior.
</p>
<hr>
<a name="Architecture"></a>
<div class="header">
<p>
Next: <a href="#Input" accesskey="n" rel="next">Input</a>, Previous: <a href="#Terms" accesskey="p" rel="prev">Terms</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Architecture-1"></a>
<h2 class="chapter">6 Architecture</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Major-objects" accesskey="1">Major objects</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Time-objects" accesskey="2">Time objects</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Reference-counting" accesskey="3">Reference counting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Numbered-objects" accesskey="4">Numbered objects</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Major-objects"></a>
<div class="header">
<p>
Next: <a href="#Time-objects" accesskey="n" rel="next">Time objects</a>, Previous: <a href="#Architecture" accesskey="p" rel="prev">Architecture</a>, Up: <a href="#Architecture" accesskey="u" rel="up">Architecture</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Major-objects-1"></a>
<h3 class="section">6.1 Major objects</h3>

<p>The classes of
Libmarpa&rsquo;s object system fall into two types:
major and numbered.
These are the Libmarpa&rsquo;s major classes,
in sequence.
</p>
<ul>
<li> Configuration:
A configuration object is
a thread-safe way to hold configuration variables,
as well as the return code from failed attempts
to create grammar objects.
</li><li> Grammar:
A grammar object contains rules and symbols,
with their properties.
</li><li> Recognizer:
A recognizer object reads input.
</li><li> Bocage:
A bocage object is a collection of
parse trees, as found by a recognizer.
A bocage is a way of representing a parse forest.
</li><li> Ordering:
An ordering object
is an ordering of the trees
in a bocage.
</li><li> Tree:
A tree object is a bocage iterator.
</li><li> Value:
A value object is a tree iterator.
Iteration of a tree using a value object
produces &ldquo;steps&rdquo;.
These &ldquo;steps&rdquo; are
instructions to
the application on how
to evaluate the semantics,
and how to manipulate the stack.
</li></ul>


<p>The major objects have one letter abbreviations,
which are used frequently.
These are, in the standard sequence,
</p>
<ul>
<li> Configuration:  C
</li><li> Grammar:  G
</li><li> Recognizer: R
</li><li> Bocage: B
</li><li> Ordering: O
</li><li> Tree: T
</li><li> Value: V
</li></ul>

<hr>
<a name="Time-objects"></a>
<div class="header">
<p>
Next: <a href="#Reference-counting" accesskey="n" rel="next">Reference counting</a>, Previous: <a href="#Major-objects" accesskey="p" rel="prev">Major objects</a>, Up: <a href="#Architecture" accesskey="u" rel="up">Architecture</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Time-objects-1"></a>
<h3 class="section">6.2 Time objects</h3>

<p>All of Libmarpa&rsquo;s major classes,
except the configuration class,
are <em>time classes</em>.
An object in a time class is a <em>time object</em>.
Except for objects in the grammar class,
all time objects are created from a time object
of the class before it in the sequence.
A recognizer cannot be created without a precomputed grammar;
a bocage cannot be created without a recognizer;
and so on.
</p>
<p>When one time object is used to create a second
time object,
the first time object is the
<a name="index-parent-objectparent-object-_0028of-a-time-object_0029"></a>
<em>parent object</em>
and the second time object is the
<a name="index-child-objectchild-object-_0028of-a-time-object_0029"></a>
<em>child object</em>.
For example, when a bocage is created from a
recognizer,
the recognizer is the parent object,
and the bocage is the child object.
</p>
<p>Grammars have no parent object.
Every other time object has exactly one parent object.
Value objects have no child objects.
All other time objects can have any number of children,
from zero up to a maximum determined by memory availability
or some other environment limit.
</p>
<p>An object is the
<a name="index-ancestor-_0028object_0029"></a>
<em>ancestor</em>
of another object if it is the parent of
that object,
or if it is the parent of an ancestor of that object.
An object is the
<a name="index-descendant-_0028object_0029"></a>
<em>descendant</em>
of another object if it is the child of
that object,
or if it is the child of an descendant of that object.
The following three statements are mutually exclusive:
</p><ul>
<li> Object <code>X</code> is of class <code>C</code>.
</li><li> Object <code>X</code> has an ancestor of class <code>C</code>.
</li><li> Object <code>X</code> has a descendant of class <code>C</code>.
</li></ul>
<p>It follows from the definitions of &ldquo;parent&rdquo; and &ldquo;ancestor&rdquo; that,
for any time object class, an
object can have at most one ancestor of that class.
On the other hand, if an object has descendants in a class,
there can be many of them.
</p>
<p>An object is a
<a name="index-base-_0028object_0029"></a>
<em>base</em>
of another object, if it is that object,
or if it is the ancestor of the object.
For each time object class, an object has at most one base object.
For example, a recognizer is its own base recognizer,
and has exactly one base grammar.
</p>
<p>The
<a name="index-base-grammarbase-grammar-_0028of-a-time-object_0029"></a>
<em>base grammar</em>
of a time object is of special importance.
Every time object has a base grammar.
A grammar object is its own base grammar.
The base grammar of a recognizer is its parent grammar,
the one that it was created with.
The base grammar of any other time object is the base
grammar of its parent object.
For example,
the base grammar of a bocage is the base
grammar of the recognizer that it was created
with.
</p>
<hr>
<a name="Reference-counting"></a>
<div class="header">
<p>
Next: <a href="#Numbered-objects" accesskey="n" rel="next">Numbered objects</a>, Previous: <a href="#Time-objects" accesskey="p" rel="prev">Time objects</a>, Up: <a href="#Architecture" accesskey="u" rel="up">Architecture</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Reference-counting-1"></a>
<h3 class="section">6.3 Reference counting</h3>

<p>Every object in a &ldquo;time&rdquo; class
has its own, distinct, lifetime,
which is controlled by the object&rsquo;s reference count.
Reference counting follows the usual practice.
Contexts that take a share of the
&ldquo;ownership&rdquo; of an object
increase the reference count by 1.
When a context relinquishes its share of
the ownership of an object, it decreases the reference
count by 1.
</p>
<p>Each class of time object has a &ldquo;ref&rdquo; and an &ldquo;unref&rdquo;
method, to be used by those contexts that need to
explicitly increment and decrement the reference count.
For example, the &ldquo;ref&rdquo; method for the grammar class is
<code>marpa_g_ref()</code>
and the &ldquo;unref&rdquo; method for the grammar class is
<code>marpa_g_unref()</code>.
</p>
<p>Time objects do not have explicit destructors.
When the reference count of a time object reaches
0, that time object is destroyed.
</p>
<p>Much of the necessary reference counting
is performed automatically.
The context calling the constructor of a time object
does not need to explicitly increase the reference
count, because
Libmarpa time objects are
always created with a reference count of 1.
</p>
<p>Child objects &ldquo;own&rdquo; their parents,
and when a child object is successfully created,
the reference count of its parent object is
automatically incremented to reflect this.
When a child object is destroyed, it
automatically decrements the reference count of its parent.
</p>
<p>In a typical application, a calling context needs only
to remember
to &ldquo;unref&rdquo; each time object that it creates,
once it is finished with that time object.
All other reference decrements and increments are taken
care of automatically.
The typical application never needs to explicitly
call one of the &ldquo;ref&rdquo; methods.
</p>
<p>More complex applications may find it convenient
to have one or more contexts share ownership of objects
created in another context.
These more complex situations
are the only cases in which the &ldquo;ref&rdquo; methods
will be needed.
</p>
<hr>
<a name="Numbered-objects"></a>
<div class="header">
<p>
Previous: <a href="#Reference-counting" accesskey="p" rel="prev">Reference counting</a>, Up: <a href="#Architecture" accesskey="u" rel="up">Architecture</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Numbered-objects-1"></a>
<h3 class="section">6.4 Numbered objects</h3>

<p>In addition to its major, &ldquo;time&rdquo; objects, Libmarpa also has
numbered objects.
Numbered objects do not have lifetimes of their own.
Every numbered object belongs to a time object,
and is destroyed with it.
Rules and symbols are numbered objects.
Token values are another class of numbered
objects.
</p>
<hr>
<a name="Input"></a>
<div class="header">
<p>
Next: <a href="#Exhaustion" accesskey="n" rel="next">Exhaustion</a>, Previous: <a href="#Architecture" accesskey="p" rel="prev">Architecture</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Input-1"></a>
<h2 class="chapter">7 Input</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Parse-location" accesskey="1">Parse location</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-basic-models-of-input" accesskey="2">The basic models of input</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Terminals" accesskey="3">Terminals</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Parse-location"></a>
<div class="header">
<p>
Next: <a href="#The-basic-models-of-input" accesskey="n" rel="next">The basic models of input</a>, Previous: <a href="#Input" accesskey="p" rel="prev">Input</a>, Up: <a href="#Input" accesskey="u" rel="up">Input</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Parse-location-1"></a>
<h3 class="section">7.1 Parse location</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#The-traditional-input-model" accesskey="1">The traditional input model</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Earlemes-and-Earley-set-IDs" accesskey="2">Earlemes and Earley set IDs</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-latest-Earley-set" accesskey="3">The latest Earley set</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-latest-earleme" accesskey="4">The latest earleme</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-current-earleme" accesskey="5">The current earleme</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-furthest-earleme" accesskey="6">The furthest earleme</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="The-traditional-input-model"></a>
<div class="header">
<p>
Next: <a href="#Earlemes-and-Earley-set-IDs" accesskey="n" rel="next">Earlemes and Earley set IDs</a>, Previous: <a href="#Parse-location" accesskey="p" rel="prev">Parse location</a>, Up: <a href="#Parse-location" accesskey="u" rel="up">Parse location</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="The-traditional-input-model-1"></a>
<h4 class="subsection">7.1.1 The traditional input model</h4>

<p>In traditional Earley parsers, the concept of location is very simple.
Locations are numbered from 0 to <var>n</var>, where <var>n</var> is the length of
the input.
Every location has an Earley set, and vice versa.
Location 0 is the start location.
Every location after the start location has exactly one input token
associated with it.
</p>
<p>Some applications
do not fit this traditional input model &mdash;
natural language processing requires ambiguous tokens,
for example.
Libmarpa allows a wide variety of alternative input models.
</p>
<hr>
<a name="Earlemes-and-Earley-set-IDs"></a>
<div class="header">
<p>
Next: <a href="#The-latest-Earley-set" accesskey="n" rel="next">The latest Earley set</a>, Previous: <a href="#The-traditional-input-model" accesskey="p" rel="prev">The traditional input model</a>, Up: <a href="#Parse-location" accesskey="u" rel="up">Parse location</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Earlemes-and-Earley-set-IDs-1"></a>
<h4 class="subsection">7.1.2 Earlemes and Earley set IDs</h4>

<p>Libmarpa&rsquo;s idea of parse location,
is the
<a name="index-earleme"></a>
<em>earleme</em>,
but Libmarpa also tracks Earley sets by
ordinal number.
In Libmarpa&rsquo;s basic input models,
the earleme of an Earley set
is always equal to
the ordinal of the Earley set,
so the distinction between Earley set ordinal
and earleme is pedantic.
But Libmarpa&rsquo;s advanced input models allow
sparse input and,
when sparse input is in use,
an Earley set&rsquo;s ordinal and its
earleme may differ.
See <a href="#The-fully-general-input-model">The fully general input model</a>.
</p>
<p>The earlemes are
assigned consecutive non-negative integers, starting at 0.
The highest valued earleme is called the
furthest earleme.
See <a href="#The-furthest-earleme">The furthest earleme</a>.
The other important earleme values are
the latest earleme (see <a href="#The-latest-earleme">The latest earleme</a>)
and
the current earleme (see <a href="#The-current-earleme">The current earleme</a>).
Latest, current and furthest earleme,
when they have specified values,
obey a lexical order in this sense:
The latest earleme is always at or before the current earleme,
and the current earleme is always at or before the furthest earleme.
</p>
<p>The Earley set ordinal
is also known as the
<a name="index-ID-_0028of-an-Earley-set_0029"></a>
<em>ID of the Earley set</em>, or
<a name="index-Earley-set-ID"></a>
<em>Earley set ID</em>.
Earley set IDs are
consecutive non-negative integers, starting at 0.
The highest valued Earley set ID is that of the
latest Earley set.
See <a href="#The-latest-Earley-set">The latest Earley set</a>
</p>
<hr>
<a name="The-latest-Earley-set"></a>
<div class="header">
<p>
Next: <a href="#The-latest-earleme" accesskey="n" rel="next">The latest earleme</a>, Previous: <a href="#Earlemes-and-Earley-set-IDs" accesskey="p" rel="prev">Earlemes and Earley set IDs</a>, Up: <a href="#Parse-location" accesskey="u" rel="up">Parse location</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="The-latest-Earley-set-1"></a>
<h4 class="subsection">7.1.3 The latest Earley set</h4>

<p>The
<a name="index-Earley-set_002c-latest"></a>
<a name="index-latest-Earley-set"></a>
<em>latest Earley set</em>
is the Earley set completed most recently.
This is initially the Earley set at location 0.
The latest Earley set is always the Earley set with the highest ID,
and the Earley set with the highest earleme location.
</p>
<p>The latest Earley set is set implicitly
by the <code>marpa_start_input()</code>
(see <a href="#marpa_005fr_005fstart_005finput">marpa_r_start_input</a>) and
<code>marpa_r_earleme_complete()</code>
(see <a href="#marpa_005fr_005fearleme_005fcomplete">marpa_r_earleme_complete</a>) methods.
Applications can access its value via
the
<code>marpa_r_latest_earley_set()</code> method.
See <a href="#marpa_005fr_005flatest_005fearley_005fset">marpa_r_latest_earley_set</a>.
</p>
<hr>
<a name="The-latest-earleme"></a>
<div class="header">
<p>
Next: <a href="#The-current-earleme" accesskey="n" rel="next">The current earleme</a>, Previous: <a href="#The-latest-Earley-set" accesskey="p" rel="prev">The latest Earley set</a>, Up: <a href="#Parse-location" accesskey="u" rel="up">Parse location</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="The-latest-earleme-1"></a>
<h4 class="subsection">7.1.4 The latest earleme</h4>

<p>The
<a name="index-earleme_002c-latest"></a>
<em>latest earleme</em> is the earleme of the latest Earley set.
If there is an Earley set at the current earleme,
it is the latest Earley set and the latest earleme
is equal to the current earleme.
There is never an Earley set after the current earleme,
and therefore the latest Earley set is never after the
current earleme.
</p>
<p>The latest earleme is different from the current earleme if and only if
there is no Earley set at the current earleme.
A different end of parse can be specified,
but by default, parsing is of the input
in the range
from earleme 0 to the latest earleme.
See <a href="#End-of-parse">End of parse</a>.
</p>
<p>The latest earleme is set implicitly
by the <code>marpa_start_input()</code>
(see <a href="#marpa_005fr_005fstart_005finput">marpa_r_start_input</a>) and
<code>marpa_r_earleme_complete()</code>
(see <a href="#marpa_005fr_005fearleme_005fcomplete">marpa_r_earleme_complete</a>) methods.
Applications can access the value of the latest earleme
by first calling the
<code>marpa_r_latest_earley_set()</code> method
(see <a href="#marpa_005fr_005flatest_005fearley_005fset">marpa_r_latest_earley_set</a>),
then converting its return value with the
<code>marpa_r_earleme()</code> method
(see <a href="#marpa_005fr_005fearleme">marpa_r_earleme</a> method).
</p>
<hr>
<a name="The-current-earleme"></a>
<div class="header">
<p>
Next: <a href="#The-furthest-earleme" accesskey="n" rel="next">The furthest earleme</a>, Previous: <a href="#The-latest-earleme" accesskey="p" rel="prev">The latest earleme</a>, Up: <a href="#Parse-location" accesskey="u" rel="up">Parse location</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="The-current-earleme-1"></a>
<h4 class="subsection">7.1.5 The current earleme</h4>

<p>The
<a name="index-earleme_002c-current"></a>
<em>current earleme</em>
is the earleme that Libmarpa is currently working on.
More specifically, it is the one at which new tokens will <strong>start</strong>.
Since tokens are never zero length, a new token will always end after the
current earleme.
<code>marpa_r_start_input()</code>
initializes the current earleme to 0,
and every call to
<code>marpa_r_earleme_complete()</code>
advances the
current earleme by 1.
</p>
<p>The current earleme is set implicitly
by the <code>marpa_start_input()</code>
(see <a href="#marpa_005fr_005fstart_005finput">marpa_r_start_input</a>) and
<code>marpa_r_earleme_complete()</code>
(see <a href="#marpa_005fr_005fearleme_005fcomplete">marpa_r_earleme_complete</a>) methods.
Applications can access the value of the current earleme
via the
<code>marpa_r_current_earleme()</code> method
(see <a href="#marpa_005fr_005fcurrent_005fearleme">marpa_r_current_earleme</a>).
</p>
<hr>
<a name="The-furthest-earleme"></a>
<div class="header">
<p>
Previous: <a href="#The-current-earleme" accesskey="p" rel="prev">The current earleme</a>, Up: <a href="#Parse-location" accesskey="u" rel="up">Parse location</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="The-furthest-earleme-1"></a>
<h4 class="subsection">7.1.6 The furthest earleme</h4>

<p>Loosely speaking,
the
<a name="index-earleme_002c-furthest"></a>
<em>furthest earleme</em>
is the furthest earleme reached by the parse.
More precisely,
it is the highest numbered
earleme at which a token ends
and is 0 if there are no tokens.
The furthest earleme is 0 when a recognizer is
created.
With every call to
<code>marpa_r_alternative()</code>, the end of the token
it adds is calculated.
A token ends at the earleme location <var>current</var>+<var>length</var>,
where <var>current</var> is the current earleme,
and <var>length</var> is the length of the newly added token.
If <code>old_f</code> is the furthest earleme before
a call to
<code>marpa_r_alternative()</code>,
the furthest earleme after the call
is <code>max(old_f, current+length)</code>.
</p>
<p>The furthest earleme is set implicitly by
the <code>marpa_r_new()</code> (see <a href="#marpa_005fr_005fnew">marpa_r_new</a>) and
the <code>marpa_r_alternative()</code> (see <a href="#marpa_005fr_005falternative">marpa_r_alternative</a>)
methods.
Applications can access the value of the furthest earleme
via the
<code>marpa_r_furthest_earleme()</code> method
(see <a href="#marpa_005fr_005ffurthest_005fearleme">marpa_r_furthest_earleme</a>).
</p>
<p>In the basic input models,
where every token has length 1,
calling
<code>marpa_r_earleme_complete()</code>
after each
<code>marpa_r_alternative()</code>
call is sufficient to process
all inputs,
and the furthest earleme&rsquo;s value
can be ignored.
In alternative input models,
where tokens have lengths greater than 1,
calling <code>marpa_r_earleme_complete()</code>
once after the last token
is read may not be enough to ensure that all tokens have been processed.
To ensure that all tokens have been processed,
an application must advance the current earleme
by calling
<code>marpa_r_earleme_complete()</code>,
until the current earleme is equal to the furthest earleme.
</p>
<hr>
<a name="The-basic-models-of-input"></a>
<div class="header">
<p>
Next: <a href="#Terminals" accesskey="n" rel="next">Terminals</a>, Previous: <a href="#Parse-location" accesskey="p" rel="prev">Parse location</a>, Up: <a href="#Input" accesskey="u" rel="up">Input</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="The-basic-models-of-input-1"></a>
<h3 class="section">7.2 The basic models of input</h3>

<p>For the purposes of presentation,
we (somewhat arbitrarily)
divide Libmarpa&rsquo;s input models
into two groups:
basic and advanced.
In the
<a name="index-basic-models-of-input"></a>
<a name="index-models-of-input_002c-basic"></a>
<a name="index-input_002c-basic-models-of"></a>
<em>basic input models of input</em>,
every token is exactly one earleme long.
This implies that, in a basic model of input,
</p><ul>
<li> every token is the same length,
</li><li> the ordinal of an Earley set
will always be the same as its earleme location, and
</li><li> the latest earleme and the current earleme are always equal.
</li></ul>

<p>In the
<a name="index-advanced-models-of-input"></a>
<a name="index-models-of-input_002c-advanced"></a>
<a name="index-input_002c-advanced-models-of"></a>
<em>advanced models of input</em>,
tokens may have a length other than 1.
Most applications use the basic input models.
The details of the advanced models of input are
presented in a later chapter.
See <a href="#Advanced-input-models">Advanced input models</a>.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#The-standard-model-of-input" accesskey="1">The standard model of input</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Ambiguous-input" accesskey="2">Ambiguous input</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="The-standard-model-of-input"></a>
<div class="header">
<p>
Next: <a href="#Ambiguous-input" accesskey="n" rel="next">Ambiguous input</a>, Previous: <a href="#The-basic-models-of-input" accesskey="p" rel="prev">The basic models of input</a>, Up: <a href="#The-basic-models-of-input" accesskey="u" rel="up">The basic models of input</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="The-standard-model-of-input-1"></a>
<h4 class="subsection">7.2.1 The standard model of input</h4>

<p>In the standard model of input,
there is exactly one successful
<code>marpa_r_alternative()</code> call
immediately previous
to every
<code>marpa_r_earleme_complete()</code> call.
A <code>marpa_r_alternative()</code> call is
<a name="index-previous-_0028to-a-marpa_005fr_005fearleme_005fcomplete_0028_0029-call_0029_002c-immediately"></a>
<a name="index-immediately-previous-_0028to-a-marpa_005fr_005fearleme_005fcomplete_0028_0029-call_0029"></a>
<em>immediately previous</em> to a
<code>marpa_r_earleme_complete()</code> call
iff
that <code>marpa_r_earleme_complete()</code> call is
the first
<code>marpa_r_earleme_complete()</code> call after
the <code>marpa_r_alternative()</code> call.
</p>
<p>Recall that, since the standard model is
a basic model,
the token length in every successful call to <code>marpa_r_alternative()</code>
will be one.
For an input of length <var>n</var>, there will be
exactly <var>n</var> <code>marpa_r_earleme_complete()</code> calls,
and all but the last call
to <code>marpa_r_earleme_complete()</code>
must be successful.
</p>
<p>In the standard model,
after a successful call
to
<code>marpa_r_alternative()</code>,
if <var>c</var> is the value  of the current earleme before the call,
</p><ul>
<li> the current earleme will remain unchanged and therefore
  will be <var>c</var>; and
</li><li> the furthest earleme will be <var>c</var>+1.
</li></ul>

<p>In the standard model,
a call to
<code>marpa_r_earleme_complete()</code>
follows a successful call of
<code>marpa_r_alternative()</code>,
so that the value of the furthest earleme before the call to
<code>marpa_r_earleme_complete()</code> will be <code>c+1</code>,
where <var>c</var> is the value of the current earleme.
After a successful call to
<code>marpa_r_earleme_complete()</code>,
</p><ul>
<li> the current earleme will be advanced to <code>c+1</code>; and
</li><li> the furthest earleme will be <var>c+1</var>, and therefore equal
to the current earleme.
</li></ul>

<p>Recall that, in the basic models of input,
the latest earleme is always equal to the current earleme.
</p>
<hr>
<a name="Ambiguous-input"></a>
<div class="header">
<p>
Previous: <a href="#The-standard-model-of-input" accesskey="p" rel="prev">The standard model of input</a>, Up: <a href="#The-basic-models-of-input" accesskey="u" rel="up">The basic models of input</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Ambiguous-input-1"></a>
<h4 class="subsection">7.2.2 Ambiguous input</h4>

<p>We can loosen the standard model to
allow more than one successful call to
<code>marpa_r_alternative()</code>
immediately previous to each call to
<code>marpa_r_earleme_complete()</code>.
This change will mean that multiple tokens become possible
at each earleme &mdash;
in other words, that the input becomes ambiguous.
We continue to require that there be
at least one successful call to
<code>marpa_r_alternative()</code>
before each call to
<code>marpa_r_earleme_complete()</code>.
And we recall that,
since this is a basic input model,
all tokens must have a length of 1.
</p>
<p>In the ambiguous input model, the behavior of the current,
latest and furthest earlemes are exactly
as described for the standard model.
See <a href="#The-standard-model-of-input">The standard model of input</a>.
</p>
<hr>
<a name="Terminals"></a>
<div class="header">
<p>
Previous: <a href="#The-basic-models-of-input" accesskey="p" rel="prev">The basic models of input</a>, Up: <a href="#Input" accesskey="u" rel="up">Input</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Terminals-1"></a>
<h3 class="section">7.3 Terminals</h3>

<p>Traditionally,
a terminal symbol is a symbol that
may appear in the input.
Traditional grammars
divide all symbols sharply into terminals
and non-terminals:
A terminal symbol must <strong>always</strong> be used as a terminal.
A non-terminal symbol can <strong>never</strong> be used as a terminal.
</p>
<p>In Libmarpa, by default, a symbol is a terminal,
and therefore may appear in the input iff
both of the following are true:
</p><ul>
<li> The symbol is non-nulling.
It is a logical contradiction for a nulling symbol
to appear in the input.
For this reason, Marpa does not allow it.
</li><li> The symbol does not appear on the
LHS of any rule.
</li></ul>

<p>Marpa&rsquo;s default behavior follows tradition.
A now-deprecated feature of
Marpa allowed for LHS terminals.
See <a href="#LHS-terminals">LHS terminals</a>.
Most readers will want to stick to
Marpa&rsquo;s default behavior,
and can and should ignore the possibility
of LHS terminals.
Even when LHS terminals are allowed,
terminals can never be zero length.
</p>
<p>In Libmarpa,
every terminal instance has a token value associated with it.
Token values are <code>int</code>&rsquo;s.
Libmarpa does nothing with token values except accept
them from the application and return them during
parse evaluation.
</p>
<hr>
<a name="Exhaustion"></a>
<div class="header">
<p>
Next: <a href="#End-of-parse" accesskey="n" rel="next">End of parse</a>, Previous: <a href="#Input" accesskey="p" rel="prev">Input</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Exhaustion-1"></a>
<h2 class="chapter">8 Exhaustion</h2>

<p>A parse is
<a name="index-exhausted-parse"></a>
<a name="index-parse_002c-exhausted"></a>
<em>exhausted</em> when it cannot accept any further input.
A parse is
<a name="index-active-parse"></a>
<a name="index-parse_002c-active"></a>
<em>active</em> iff it is not exhausted.
For a parse to be exhausted,
the furthest earleme and the current earleme
must be equal.
However, the converse is not always the case:
if more tokens can be read at the current earleme,
then it is possible for
the furthest earleme and the current earleme
to be equal in an active parse.
</p>
<p>Parse exhaustion always has a location.
That is, if a parse is exhausted it is exhausted at some earleme location <code>X</code>.
If a parse is exhausted at location <code>X</code>, then
</p><ul>
<li> There may be valid parses at <code>X</code>.
</li><li> The parse was active at all locations earlier than <code>X</code>.
</li><li> There may be valid parses at locations before <code>X</code>.
</li><li> There will be no valid parses at locations after <code>X</code>.
</li><li> No tokens can start at location <code>X</code>.
</li><li> No tokens can end at a location after <code>X</code>.
</li><li> No tokens can start at any location after <code>X</code>.
</li><li> No tokens will be accepted by an exhausted parser.
    It is an irrecoverable hard failure to call <code>marpa_r_alternative()</code>
    after a parser has become exhausted.
</li><li> No Earley sets will be at any location after <code>X</code>.
</li><li> No earlemes are completed by, and no Earley sets are created by, an exhausted parser.
    It is an irrecoverable hard failure to call <code>marpa_r_earleme_complete()</code>
    after a parser has become exhausted.
</li></ul>

<p>Users sometimes assume that parse exhaustion means parse failure.
But other users sometimes assume that parse exhaustion means parse success.
For many grammars,
there are strong associations between parse exhaustion
and parse success,
but the strong association can go either way,
Both exhaustion-loving and exhaustion-hating
grammars are very common in
practical application.
</p>
<p>In an
<a name="index-exhaustion_002dhating-applications"></a>
<a name="index-applications_002c-exhaustion_002dhating"></a>
<em>exhaustion-hating</em>
application,
parse exhaustion typically means parse failure.
C programs, Perl scripts and most programming languages
are exhaustion-hating applications.
If a C program is well-formed,
it is always possible to read more input.
The same is true of a Perl program that does not have a <code>__DATA__</code> section.
</p>
<p>In an
<a name="index-exhaustion_002dloving-applications"></a>
<a name="index-applications_002c-exhaustion_002dloving"></a>
<em>exhaustion-loving</em>
application
parse exhaustion means parse success.
A toy example of an exhaustion-loving
application is the language consisting of balanced parentheses.
When the parentheses come into perfect balance the parse is exhausted,
because any further input would unbalance the brackets.
And the parse succeeds when the parentheses come into perfect balance.
Exhaustion means success.
Any language that balances start and end indicators will tend to
be exhaustion-loving.
HTML and XML, with their start and end tags, can be seen
as exhaustion-loving languages.
</p>
<p>One common form of exhaustion-loving parsing
occurs in lexers that look for longest matches.
Exhaustion will indicate that the longest match has been found.
</p>
<p>It is possible for a language to be
exhaustion-loving at some points
and exhaustion-hating at others.
We mentioned Perl&rsquo;s <code>__DATA__</code> as a complication in a
basically exhaustion-hating language.
</p>
<p><code>marpa_r_earleme_complete()</code> and
<code>marpa_r_start_input</code> are the only methods
that may encounter parse exhaustion.
See <a href="#marpa_005fr_005fearleme_005fcomplete">marpa_r_earleme_complete()</a>, and
<a href="#marpa_005fr_005fstart_005finput">marpa_r_start_input()</a>.
When the <code>marpa_r_start_input</code> or
<code>marpa_r_earleme_complete()</code> methods
exhaust the parse,
they trigger a <code>MARPA_EVENT_EXHAUSTED</code> event.
Applications
can also query
parse exhaustion status directly
with the
<code>marpa_r_is_exhausted()</code> method.
See <a href="#marpa_005fr_005fis_005fexhausted">marpa_r_is_exhausted()</a>.
</p>
<p>Parse exhaustion can be triggered on method success
by either the <code>marpa_r_earleme_complete()</code> or
the <code>marpa_r_start_input</code> method.
Parse exhaustion can be triggered on method failure
by the <code>marpa_r_earleme_complete()</code> method.
Parse exhaustion triggered on method success is called
<a name="index-parse-exhaustion-on-success"></a>
<em>parse exhaustion on success</em> or
<a name="index-exhaustion-on-success"></a>
<em>exhaustion on success</em>.
Parse exhaustion triggered on method failure is called
<a name="index-parse-exhaustion-on-failure"></a>
<em>parse exhaustion on failure</em> or
<a name="index-exhaustion-on-failure"></a>
<em>exhaustion on failure</em>.
</p>
<hr>
<a name="End-of-parse"></a>
<div class="header">
<p>
Next: <a href="#Semantics" accesskey="n" rel="next">Semantics</a>, Previous: <a href="#Exhaustion" accesskey="p" rel="prev">Exhaustion</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="End-of-parse-1"></a>
<h2 class="chapter">9 End of parse</h2>

<p>Users accustomed to certain applications
may believe that the question of when to end parsing
is almost too trivial to ask.
And, for many applications this is the case.
But the general question of determining the end of parse is
decidedly non-trivial.
For a broad theoretical overview,
see &quot;When are we done parsing?&quot;,
pp. 93-94 in the 2nd edition of
Grune and Jacobs,
(see <a href="#Grune-and-Jacobs-2008">Grune and Jacobs 2008</a>).
This chapter discusses determination of the
<a name="index-end-of-parse"></a>
<em>end of parse</em>
<a name="index-EOP"></a>
(<em>EOP</em>)
from the Libmarpa point of view.
</p>
<p>EOP-handling and exhaustion-handling are intertwined.
It may be useful to review the section on exhaustion at this
point.
See <a href="#Exhaustion">Exhaustion</a>.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Determining-EOP-from-EOI" accesskey="1">Determining EOP from EOI</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Determining-EOP-from-exhaustion" accesskey="2">Determining EOP from exhaustion</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Other-ways-of-determining-EOP" accesskey="3">Other ways of determining EOP</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Determining-EOP-from-EOI"></a>
<div class="header">
<p>
Next: <a href="#Determining-EOP-from-exhaustion" accesskey="n" rel="next">Determining EOP from exhaustion</a>, Previous: <a href="#End-of-parse" accesskey="p" rel="prev">End of parse</a>, Up: <a href="#End-of-parse" accesskey="u" rel="up">End of parse</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Determining-EOP-from-EOI-1"></a>
<h3 class="section">9.1 Determining EOP from EOI</h3>

<p>In many applications the EOP is always the
<a name="index-end-of-input"></a>
<em>end of input</em>
<a name="index-EOI"></a>
(<em>EOI</em>).
That is, parsing ends at a known parse location.
The length of the input may be known
because it was fixed in advance;
there may be an
<a name="index-end-of-file"></a>
<em>end of file</em>
<a name="index-EOF"></a>
(<em>EOF</em>) indication;
there may be an
<a name="index-end-of-string"></a>
<em>end of string</em>
<a name="index-EOS"></a>
(<em>EOS</em>) indication; or
the application may have some other means of knowing
that is has hit the EOI.
</p>
<p>If the EOI is the EOP, the following is typically the case:
</p><ul>
<li> The application will treat exhaustion on failure
as a parse error.
</li><li> The application will treat exhaustion before the EOI,
even on success, as a parse error.
</li></ul>

<p>How parse exhaustion on success
at the EOI is handled will
depend on the application.
Here are a few of the many possible ways:
</p><ul>
<li> Exhaustion might be ignored.
Very often this will be what the application wants to do.
</li><li> Exhaustion might be,
if the application is exhaustion-loving,
required,
so that it is treated as an error if the parse is still active
at the EOI.
</li><li> An application, if it is exhaustion-hating in the extreme,
may wish to treat exhaustion,
even exhaustion on success at the EOI,
as an error.
</li></ul>

<hr>
<a name="Determining-EOP-from-exhaustion"></a>
<div class="header">
<p>
Next: <a href="#Other-ways-of-determining-EOP" accesskey="n" rel="next">Other ways of determining EOP</a>, Previous: <a href="#Determining-EOP-from-EOI" accesskey="p" rel="prev">Determining EOP from EOI</a>, Up: <a href="#End-of-parse" accesskey="u" rel="up">End of parse</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Determining-EOP-from-exhaustion-1"></a>
<h3 class="section">9.2 Determining EOP from exhaustion</h3>

<p>An exhaustion-loving application that does not know the length of
its input may want to terminate the parse in case of exhaustion on success,
in effect treating exhaustion as an end-of-input indicator.
These applications will usually want to treat exhaustion on failure
as an error.
</p>
<p>An example of such an application would be the language consisting entirely
of strings of balanced parentheses.
HTML might also be treated as an exhaustion-loving language,
with the parse terminating at the <code>/html</code> tag.
</p>
<hr>
<a name="Other-ways-of-determining-EOP"></a>
<div class="header">
<p>
Previous: <a href="#Determining-EOP-from-exhaustion" accesskey="p" rel="prev">Determining EOP from exhaustion</a>, Up: <a href="#End-of-parse" accesskey="u" rel="up">End of parse</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Other-ways-of-determining-EOP-1"></a>
<h3 class="section">9.3 Other ways of determining EOP</h3>

<p>Occasionally, an exhaustion-hating application may not know
the length of its input in advance.
Since these applications will not know from the length of the input,
or from exhaustion, that they are at end of input,
they will need some other way of determining this.
One way they may do this is with a
<code>MARPA_EVENT_SYMBOL_COMPLETED</code> event.
</p>
<p>An example of such an application that has seen much use is
the <code>Marpa::R2</code> lexer.
The <code>Marpa::R2</code> lexer looks for one of a set of &ldquo;lexemes&rdquo;,
seeking the longest one.
It does this by declaring
a <code>MARPA_EVENT_SYMBOL_COMPLETED</code> event
for each lexeme, and recording the most recent location
at which one of these completion events occurs.
The <code>Marpa::R2</code> lexer stops looking for the longest lexeme on parse exhaustion,
and at that point treats the parse location of the most recent
<code>MARPA_EVENT_SYMBOL_COMPLETED</code> event
as the EOP.
If no <code>MARPA_EVENT_SYMBOL_COMPLETED</code> event occurred,
the <code>Marpa::R2</code> lexer failed to find a lexeme,
and reports a lexing error.
</p>
<hr>
<a name="Semantics"></a>
<div class="header">
<p>
Next: <a href="#Threads" accesskey="n" rel="next">Threads</a>, Previous: <a href="#End-of-parse" accesskey="p" rel="prev">End of parse</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Semantics-1"></a>
<h2 class="chapter">10 Semantics</h2>

<p>Libmarpa handling of semantics is unusual.
Most semantics are left up to the application,
but Libmarpa guides them.
Specifically, the application is expected to maintain the evaluation
stack.
Libmarpa&rsquo;s valuator provides instructions on how to handle the stack.
Libmarpa&rsquo;s stack handling instructions
are called &ldquo;steps&rdquo;.
For example, a Libmarpa step might tell the application that the value
of a token needs to go into a certain stack position.
Or a Libmarpa step might tell the application that a rule is to be evaluated.
For rule evaluation, Libmarpa will tell the application where the operands
are to be found,
and where the result must go.
</p>
<p>The detailed discussion of
Libmarpa&rsquo;s handling of semantics is in the reference chapters
of this document,
under the appropriate methods and classes.
The most extensive discussion of the semantics
is in the section that deals with the methods of the value time class
(<a href="#Value-methods">Value methods</a>).
</p>
<hr>
<a name="Threads"></a>
<div class="header">
<p>
Next: <a href="#Sequence-rules" accesskey="n" rel="next">Sequence rules</a>, Previous: <a href="#Semantics" accesskey="p" rel="prev">Semantics</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Threads-1"></a>
<h2 class="chapter">11 Threads</h2>

<p>Libmarpa is thread-safe,
given circumstances as described below.
The Libmarpa methods are not reentrant.
</p>
<p>Libmarpa is C89-compliant.
See <a href="#C89">C89</a>.
It uses no global data,
and calls only the routines
that are defined in the C89 standard
and that can be made thread-safe.
In most modern implementations,
the default C89 implementation is thread-safe
to the extent possible.
But the C89 standard does not require thread-safety,
and even most modern environments allow the user
to turn thread safety off.
To be thread-safe, Libmarpa must be compiled
and linked in an environment that provides
thread-safety.
</p>
<p>While Libmarpa can be used safely across
multiple threads,
a Libmarpa grammar cannot be.
Further, a Libmarpa time object can
only be used safely in the same thread
as its base grammar.
This is because all
time objects with the same base grammar share data
from that base grammar.
</p>
<p>To work around this limitation,
the same grammar definition can be
used to a create a new
Libmarpa grammar
time object in each thread.
If there is sufficient interest, future versions of
Libmarpa could allow thread-safe
cloning of grammars and other
time objects.
</p>
<hr>
<a name="Sequence-rules"></a>
<div class="header">
<p>
Next: <a href="#Nullability" accesskey="n" rel="next">Nullability</a>, Previous: <a href="#Threads" accesskey="p" rel="prev">Threads</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sequence-rules-1"></a>
<h2 class="chapter">12 Sequence rules</h2>

<p>Traditionally, grammars only allow BNF rules.
Libmarpa allows sequence rules, which express sequences
by allowing
a single RHS symbol to be repeated.
</p>
<p>A sequence rule consists of a LHS and a RHS symbol.
Additionally, the application must indicate the minimum number
of repetitions.
The minimum count must be 0 or 1.
</p>
<p>Optionally, a separator symbol may be specified.
For example, a comma-separated sequence of numbers
</p><pre class="verbatim">     1,42,7192,711,
</pre><p>may be recognized
by specifying the rule <tt>Seq ::= num</tt> and
the separator <tt>comma ::= ','</tt>.
By default, an optional final separator,
as shown in the example above,
is recognized,
but &ldquo;proper separation&rdquo; may also be specified.
In proper separation separators must,
in fact,
come between (&ldquo;separate&rdquo;) items of the sequence.
A final separator is not a separator in the strict sense,
and therefore is not recognized when proper separation is in effect.
For more on specifying sequence rules,
see <a href="#marpa_005fg_005fsequence_005fnew">marpa_g_sequence_new</a>.
</p>
<p>Sequence rules are &ldquo;sugar&rdquo; &mdash;
their presence in the Libmarpa interface does not extend its power.
Every Libmarpa grammar that can be written using sequence rules
can be rewritten as a grammar without sequence rules.
</p>
<p>The RHS symbol and the separator, if there is one,
must not be nullable.
This is because it is not completely clear what
an application intends
when it asks for a sequence of items,
some of which are nullable &mdash;
the most natural interpretation of this usually results in a highly
ambiguous grammar.
</p>
<p>Libmarpa allows highly ambiquous grammars
and a programmer who wants a grammar
with sequences containing nullable items or separators
can write that grammar using BNF rules.
The use of BNF rules
make it clearer that ambiguity is what the programmer
intended, and allows the programmer more flexibility.
</p>
<p>A sequence rule must have a dedicated LHS &mdash;
that is, the LHS of a sequence rule must not be the LHS of
any other rule.
This implies that the LHS of a sequence rule can
never be the LHS of a BNF rule.
</p>
<p>The requirement that the LHS of a sequence rule be
unique is imposed for reasons similar to those
for the
prohibition against RHS and separator nullables.
Often reuse of the LHS of a sequence rule
is simply a mistake.
Even when deliberate,
reuse of the LHS results in a complex grammar,
one which often parses in ways that the programmer
did not intend.
</p>
<p>A programmer who believes they know what they
are doing, and really does want alternative sequences starting
at the same input location, can specify this behavior indirectly.
They can do this by creating two sequence rules with distinct LHS&rsquo;s:
</p><pre class="verbatim">     Seq1 ::= Item1
     Seq2 ::= Item2
</pre><p>and adding a new &ldquo;parent&rdquo; LHS which recognizes the sequences as alternatives.
</p><pre class="verbatim">     SeqChoice ::= Seq1
     SeqChoice ::= Seq2
</pre>
<hr>
<a name="Nullability"></a>
<div class="header">
<p>
Next: <a href="#Failure" accesskey="n" rel="next">Failure</a>, Previous: <a href="#Sequence-rules" accesskey="p" rel="prev">Sequence rules</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Nullability-1"></a>
<h2 class="chapter">13 Nullability</h2>

<p>In Libmarpa,
there is no direct way to mark a symbol nullable or nulling.
All Libmarpa&rsquo;s terminal symbols are non-nullable.
By default,
Libmarpa&rsquo;s non-terminal symbols are nullable or nulling depending
on the rules in which they appear on the LHS.
The default behavior for non-terminals can be changed
(see <a href="#LHS-terminals">LHS terminals</a>),
but this is deprecated.
</p>
<p>To make a symbol <var>x</var> nullable,
a user must create an nulling rule whose LHS is <var>x</var>.
The empty rule is nulling,
so that one way a user can ensure <var>x</var> is nullable
is by making it the LHS of an empty rule.
If every rule with <var>x</var> on the LHS is nulling,
<var>x</var> will be not just nullable,
but nulling as well.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Nullability-in-the-valuator" accesskey="1">Nullability in the valuator</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Assigning-semantics-to-nulled-symbols" accesskey="2">Assigning semantics to nulled symbols</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Evaluating-nulled-symbols" accesskey="3">Evaluating nulled symbols</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Example-of-nulled-symbol" accesskey="4">Example of nulled symbol</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Duplicate-nulled-nodes" accesskey="5">Duplicate nulled nodes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Nullability-in-the-valuator"></a>
<div class="header">
<p>
Next: <a href="#Assigning-semantics-to-nulled-symbols" accesskey="n" rel="next">Assigning semantics to nulled symbols</a>, Previous: <a href="#Nullability" accesskey="p" rel="prev">Nullability</a>, Up: <a href="#Nullability" accesskey="u" rel="up">Nullability</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Nullability-in-the-valuator-1"></a>
<h3 class="section">13.1 Nullability in the valuator</h3>

<p>In the valuator,
every nulling tree is pruned back to its
topmost nulling symbol.
This means that there are no nulling rules in the valuator,
only nulling symbols.
For an example of how this works,
see <a href="#Example-of-nulled-symbol">Example of nulled symbol</a>.
</p>
<p>While this may sound draconian,
the &ldquo;lost&rdquo; semantics of the
nulled rules and
non-topmost nulled symbols
are almost never missed.
Nulled subtrees cannot contain input,
and therefore do not contain token symbols.
So no token values are lost when
nulled subtrees are pruned,
and we are dealing with the semantics
of the empty string.
See <a href="#Evaluating-nulled-symbols">Evaluating nulled symbols</a>.
</p>
<hr>
<a name="Assigning-semantics-to-nulled-symbols"></a>
<div class="header">
<p>
Next: <a href="#Evaluating-nulled-symbols" accesskey="n" rel="next">Evaluating nulled symbols</a>, Previous: <a href="#Nullability-in-the-valuator" accesskey="p" rel="prev">Nullability in the valuator</a>, Up: <a href="#Nullability" accesskey="u" rel="up">Nullability</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Assigning-semantics-to-nulled-symbols-1"></a>
<h3 class="section">13.2 Assigning semantics to nulled symbols</h3>

<p>Libmarpa leaves the semantics to an upper layer,
so that we usually treat
semantics as outside the scope of this document.
But most upper layers will find that
nulled symbols are a corner case
for their semantics,
and we therefore
offer the writers of upper layers
some hints.
</p>
<p>Typically, upper layers will assign semantics to
a LHS symbol based on the rule instance
in which the LHS occurs.
All nulled symbols are LHS symbols,
but the valuator prunes all nulled rules,
forcing the application to determine the semantics
of a nulled symbol instance based on its symbol.
One method of making this determination
is the one which is implemented in <code>Marpa::R2</code>.
Let <var>g</var> be a grammar;
and let <var>x</var> be a symbol that
is nulled in a parse that uses <var>g</var>.
Call a rule in <var>g</var> with <var>x</var> on its LHS,
an &ldquo;<var>x</var> LHS rule&rdquo;.
<code>Marpa::R2</code> assigns a semantics to <var>x</var>
using the first of following guidelines that applies:
</p><ul>
<li> If every <var>x</var> LHS rule in <var>g</var>
has the same semantics,
<code>Marpa::R2</code> assigns that shared semantics to <var>x</var>.
</li><li> If there is an empty <var>x</var> LHS rule in <var>g</var>,
<code>Marpa::R2</code>
assigns the semantics of that empty rule to <var>x</var>.
</li><li> If none of the previous guidelines apply,
<code>Marpa::R2</code> reports an error.
</li></ul>

<hr>
<a name="Evaluating-nulled-symbols"></a>
<div class="header">
<p>
Next: <a href="#Example-of-nulled-symbol" accesskey="n" rel="next">Example of nulled symbol</a>, Previous: <a href="#Assigning-semantics-to-nulled-symbols" accesskey="p" rel="prev">Assigning semantics to nulled symbols</a>, Up: <a href="#Nullability" accesskey="u" rel="up">Nullability</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Evaluating-nulled-symbols-1"></a>
<h3 class="section">13.3 Evaluating nulled symbols</h3>

<p>In theory, the semantics of nulled symbols,
like any semantics,
can be arbitrarily complex.
In practice,
we are dealing with the semantics of the empty string,
which is literally the &ldquo;semantics of nothing&rdquo;.
If what we are dealing with truly is primarily a parsing problem,
we can usually expect that the semantics of nothing will be simple.
</p>
<p>The possible subtrees below a nulled symbol can be seen
as a set,
and that set is a constant that depends on the grammar.
Since the input corresponding to the nulled symbol
is also a constant (the empty string),
the semantics of a nulled symbol will also be constant,
unless one of the following is true:
</p><ul>
<li> The semantics is non-deterministic.
</li><li> The semantics takes into account, not just the input, but its context.
For example, the semantics might depend on parse location,
in which case the nulled symbol instance
of <var>x</var> at location 5
might mean something different
from an nulled instance of <var>x</var> at location 50.
</li></ul>
<p>Both of these exceptions are unusual.
When they do occur, the upper layer can
implement the semantics of the nulled
symbols with
a function or a closure.
</p>
<hr>
<a name="Example-of-nulled-symbol"></a>
<div class="header">
<p>
Next: <a href="#Duplicate-nulled-nodes" accesskey="n" rel="next">Duplicate nulled nodes</a>, Previous: <a href="#Evaluating-nulled-symbols" accesskey="p" rel="prev">Evaluating nulled symbols</a>, Up: <a href="#Nullability" accesskey="u" rel="up">Nullability</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Example-of-nulled-symbol-1"></a>
<h3 class="section">13.4 Example of nulled symbol</h3>

<p>As already stated,
Marpa prunes every null subtree back to its topmost
null symbol.
Here is an example grammar, with <var>S</var> as the start
symbol.
</p>
<pre class="verbatim">        S ::= L R
        L ::= A B X
        L ::=
        R ::= A B Y
        R ::=
        A ::=
        B ::=
        X ::=
        X ::= &quot;x&quot;
        Y ::=
        Y ::= &quot;y&quot;
</pre>
<p>If we let the input be &lsquo;<samp>x</samp>&rsquo;,
we can write the unpruned parse tree
in preorder (depth-first), indenting children
below their parents, like this:
</p>
<pre class="verbatim">
        0: Visible Rule: S := L R
             1: Visible Rule L := A B X
                 1.1: Nulled Symbol A
                 1.2: Nulled Symbol B
                 1.3: Token, Value is &quot;x&quot;
             2: Nulled Rule, Rule R := A B Y
                 2.1: Nulled Symbol A
                 2.2: Nulled Symbol B
                 2.3: Nulled Symbol Y

</pre>
<p>In this example, five symbols and a rule are nulled.
The nulled rule and three of the nulled symbols
are in a nulled subtree: 2, 2.1, 2.2 and 2.3.
Marpa prunes every null subtree back to its topmost symbol,
which in this case is the LHS of the rule numbered 2.
The pruned tree looks like this:
</p>
<pre class="verbatim">
         0: Visible Rule: S := L R
              1: Visible Rule L := A B X
                  1.1: Nulled Symbol A
                  1.2: Nulled Symbol B
                  1.3: Token, Value is &quot;x&quot;
              2: LHS of Nulled Rule, Symbol R

</pre>
<p>Nulled nodes 1.1, 1.2 and 2 were all kept, because they are topmost in their
nulled subtree.
All the other nulled nodes were discarded.
</p>
<hr>
<a name="Duplicate-nulled-nodes"></a>
<div class="header">
<p>
Previous: <a href="#Example-of-nulled-symbol" accesskey="p" rel="prev">Example of nulled symbol</a>, Up: <a href="#Nullability" accesskey="u" rel="up">Nullability</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Duplicate-nulled-nodes-1"></a>
<h3 class="section">13.5 Duplicate nulled nodes</h3>

<p>A non-nulled node can never appear twice in the same tree.
But duplicate nulled nodes in the same tree are quite possible.
The start and end locations of a nulled node are the same,
and other nodes can share the same start and end locations,
so location information does not necessarily made a nulled node
unique.
Since a nulled node also always has no children,
if two nulled nodes at the same location differ,
they must differ in the symbol.
</p>
<p>It is quite possible in a grammar to allow sequences of the
same nulled symbol.
All the nodes in this sequence will be equal to each other.
These nodes represent multiple nulled symbol instances.
The context (specifically, the position of the nulled node in the tree)
is required to distinguish these instances.
</p>
<p>Libmarpa could distinguish nulled nodes by including a &ldquo;instance number&rdquo;
in the node and,
from a set-theoretic point of view,
this would be more appropriate.
But, in the implementation, the context of a node is always
available, and allowing for an &ldquo;instance number&rdquo; with each node
would consume a considerable amount of space.
</p>
<hr>
<a name="Failure"></a>
<div class="header">
<p>
Next: <a href="#Introduction-to-the-method-descriptions" accesskey="n" rel="next">Introduction to the method descriptions</a>, Previous: <a href="#Nullability" accesskey="p" rel="prev">Nullability</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Failure-1"></a>
<h2 class="chapter">14 Failure</h2>

<p>As a reminder,
no language in this chapter
(or, for that matter, in this document)
should be read as providing,
or suggesting the existence of,
a warranty.
See <a href="#License">License</a>.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Libmarpa_0027s-approach-to-failure" accesskey="1">Libmarpa's approach to failure</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#User-non_002dconformity-to-specified-behavior" accesskey="2">User non-conformity to specified behavior</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Classifying-failure" accesskey="3">Classifying failure</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Memory-allocation-failure" accesskey="4">Memory allocation failure</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Undetected-failure" accesskey="5">Undetected failure</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Irrecoverable-hard-failure" accesskey="6">Irrecoverable hard failure</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Partially-recoverable-hard-failure" accesskey="7">Partially recoverable hard failure</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Library_002drecoverable-hard-failure" accesskey="8">Library-recoverable hard failure</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Ancestry_002drecoverable-hard-failure" accesskey="9">Ancestry-recoverable hard failure</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Fully-recoverable-hard-failure">Fully recoverable hard failure</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Soft-failure">Soft failure</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Error-codes">Error codes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Libmarpa_0027s-approach-to-failure"></a>
<div class="header">
<p>
Next: <a href="#User-non_002dconformity-to-specified-behavior" accesskey="n" rel="next">User non-conformity to specified behavior</a>, Previous: <a href="#Failure" accesskey="p" rel="prev">Failure</a>, Up: <a href="#Failure" accesskey="u" rel="up">Failure</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Libmarpa_0027s-approach-to-failure-1"></a>
<h3 class="section">14.1 Libmarpa&rsquo;s approach to failure</h3>

<p>Libmarpa is a C language library,
and inherits the traditional C language approach to
avoiding and handling application programming errors.
The burden this C tradition
puts on the application programmer
might strike readers unfamiliar with that tradition
as appallingly large.
</p>
<p>But in the early 1970&rsquo;s, when the C language first stabilized,
the alternative,
and the consensus choice for its target applications,
was assembly language.
In that context, C was radical in its willingness to
incur a price in efficiency in order to protect programmers
from themselves.
C was considered to take a excessively &ldquo;hand holding&rdquo;
approach which very much flew in the face of consensus.
</p>
<p>The decades have made a large difference in the trade-offs,
and the consensus about the degree to which even a
low-level language should protect the user has changed.
It seems inevitable that C will be replaced as the low-level
language of choice, by a language that places
fewer burdens on the programmer,
and more on the machine.
The question seems to be not whether C will be dethroned
as the &ldquo;go to&rdquo; language for low-level progamming,
but when, and by which alternative.
</p>
<p>Modern hardware makes many simple checks essentially cost-free,
and Libmarpa&rsquo;s efforts to protect the application programmer go well
beyond what
would have been considered best practice in the past.
But it remains a C language library.
The Libmarpa application programmer must be prepared to exercise
the high degree of carefulness traditionally required for C language programming.
Libmarpa
places the burden of avoiding irrecoverable failures,
and of handling recoverable failures,
largely on the application programmer.
</p>
<hr>
<a name="User-non_002dconformity-to-specified-behavior"></a>
<div class="header">
<p>
Next: <a href="#Classifying-failure" accesskey="n" rel="next">Classifying failure</a>, Previous: <a href="#Libmarpa_0027s-approach-to-failure" accesskey="p" rel="prev">Libmarpa's approach to failure</a>, Up: <a href="#Failure" accesskey="u" rel="up">Failure</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="User-non_002dconformity-to-specified-behavior-1"></a>
<h3 class="section">14.2 User non-conformity to specified behavior</h3>

<p>This document specifies many behaviors
for Libmarpa application programs to follow,
such as the nature of the arguments to each method.
The C language and the application environment impose
many more behaviors,
such as proper memory management.
When a non-conformity to specified behavior is unintentional
and problematic,
it is frequently called a &ldquo;bug&rdquo;.
Even the most carefully programmed Libmarpa application may sometimes
contain a &ldquo;bug&rdquo;.
In addition, some specified behaviors are explicitly stated as characterizing
a primary branch of the processing,
rather than made mandatory for all successful processing.
Non-conformity to non-mandatory behaviors can be efficiently recoverable,
and is often intentional.
</p>
<p>This chapter describes how
non-conformity to specified behavior
by a Libmarpa application
is handled by Libmarpa.
Non-conformity to specified behavior
by a Libmarpa application
is also called, for the purposes of this document,
a
<a name="index-Libmarpa-application-programming-failure"></a>
<a name="index-failure_002c-Libmarpa-application-programming"></a>
<a name="index-failure"></a>
<em>Libmarpa application programming failure</em>.
In contexts where no ambiguity arises,
<em>Libmarpa application programming failure</em>
will
usually be abbreviated to
<em>failure</em>.
</p>
<a name="index-Libmarpa-application-programming-success"></a>
<a name="index-success_002c-Libmarpa-application-programming"></a>
<a name="index-success"></a>
<p><em>Libmarpa application programming success</em>
in a context
is defined as the absence of unrecovered failure in that context.
When no ambiguity arises,
<em>Libmarpa application programming success</em>
is almost
always abbreviated to
<em>success</em>.
For example, the success of an application means the application
ran without any irrecoverable failures,
and that it recovered from all the recoverable failures that were detected.
</p>
<hr>
<a name="Classifying-failure"></a>
<div class="header">
<p>
Next: <a href="#Memory-allocation-failure" accesskey="n" rel="next">Memory allocation failure</a>, Previous: <a href="#User-non_002dconformity-to-specified-behavior" accesskey="p" rel="prev">User non-conformity to specified behavior</a>, Up: <a href="#Failure" accesskey="u" rel="up">Failure</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Classifying-failure-1"></a>
<h3 class="section">14.3 Classifying failure</h3>

<p>A Libmarpa application programming failure,
unless stated otherwise,
is an irrecoverable failure.
Once an irrecoverable failure has occurred,
the further behavior of the program is undefined.
Nonetheless, we specify,
and Libmarpa attempts,
diagnostics behaviors
(see <a href="#Application-and-diagnostic-behavior">Application and diagnostic behavior</a>)
in an effort to handle irrecoverable failures as
smoothly as possible.
</p>
<p>A Libmarpa application programming failure
is not recoverable,
unless this document states otherwise.
</p>

<p>A failure is called a
<a name="index-hard-failure"></a>
<a name="index-failure_002c-hard"></a>
<em>hard failure</em>
if it has an error code
associated with it.
A recoverable failure is called a
<a name="index-soft-failure"></a>
<a name="index-failure_002c-soft"></a>
<em>soft failure</em>
if it has no associated error code.
(For more on error codes, see <a href="#Error-codes">Error codes</a>.)
</p>
<p>All failures fall into one of five types.
In order of severity, these are
</p><ul>
<li> <strong>memory allocation failures</strong>,
</li><li> <strong>undetected failures</strong>,
</li><li> <strong>irrecoverable hard failures</strong>,
</li><li> <strong>partially recoverable hard failures</strong>,
</li><li> <strong>fully recoverable hard failures</strong>, and
</li><li> <strong>soft failures</strong>.
</li></ul>

<hr>
<a name="Memory-allocation-failure"></a>
<div class="header">
<p>
Next: <a href="#Undetected-failure" accesskey="n" rel="next">Undetected failure</a>, Previous: <a href="#Classifying-failure" accesskey="p" rel="prev">Classifying failure</a>, Up: <a href="#Failure" accesskey="u" rel="up">Failure</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Memory-allocation-failure-1"></a>
<h3 class="section">14.4 Memory allocation failure</h3>

<p>Failure to allocate memory is the most irrecoverable of irrecoverable
errors.
On
<a name="index-memory-allocation-failure"></a>
<a name="index-failure_002c-memory-allocation"></a>
<em>memory allocation failure</em>,
as with all irrecoverable failures,
Libmarpa&rsquo;s behavior is undefined.
Libmarpa attempts to terminate the current program abnormally by calling <code>abort()</code>,
but a component of many modern operating systems is
an out-of-memory (OOM) killer,
which takes the decision out of the hands
of both Libmarpa and the user.
See <a href="#Out_002dof_002dmemory-handling">Out-of-memory handling</a>.
</p>
<p>Memory allocation failure is the only case in which
the decision to terminate the program is made for
the user.
In all other cases,
Libmarpa leaves the decision to terminate the program,
whether normally or abnormally,
up to the application programmer.
</p>
<p>Memory allocation failure does not have an error code.
As a pedantic matter, memory allocation failure
is neither a hard or a soft failure.
</p>
<hr>
<a name="Undetected-failure"></a>
<div class="header">
<p>
Next: <a href="#Irrecoverable-hard-failure" accesskey="n" rel="next">Irrecoverable hard failure</a>, Previous: <a href="#Memory-allocation-failure" accesskey="p" rel="prev">Memory allocation failure</a>, Up: <a href="#Failure" accesskey="u" rel="up">Failure</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Undetected-failure-1"></a>
<h3 class="section">14.5 Undetected failure</h3>

<p>An
<a name="index-undetected-failure"></a>
<a name="index-failure_002c-undetected"></a>
<em>undetected failure</em> is a failure that the Libmarpa
library does not detect.
Many failures are impossible or impractical
for a C library to detect.
Two examples of failure that the Libmarpa methods do not detect
are writes outside the bounds of allocated memory,
and use of memory after it has been freed.
C is not strongly typed, and arguments
of Libmarpa routines undergo only a few simple tests,
tests which are inadequate to detect many of the potential problems.
</p>
<p>By undetected failure we emphasize that we mean failures undetected
<strong>by the Libmarpa methods</strong>.
In the examples just given,
there exist tools that can help the programmer
detect memory errors
and other tools exist
to check the sanity of method arguments.
</p>
<p>This document points out some of the potentially undetected problems,
when doing so seems more helpful than tedious.
But any attempt to list all the undetected problems would be too large
and unwieldy to be useful.
</p>
<p>Undetected failure is always irrecoverable.
An undetected failure
is neither a hard or a soft failure.
</p>
<hr>
<a name="Irrecoverable-hard-failure"></a>
<div class="header">
<p>
Next: <a href="#Partially-recoverable-hard-failure" accesskey="n" rel="next">Partially recoverable hard failure</a>, Previous: <a href="#Undetected-failure" accesskey="p" rel="prev">Undetected failure</a>, Up: <a href="#Failure" accesskey="u" rel="up">Failure</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Irrecoverable-hard-failure-1"></a>
<h3 class="section">14.6 Irrecoverable hard failure</h3>

<p>An
<a name="index-irrecoverable-hard-failure"></a>
<a name="index-hard-failure_002c-irrecoverable"></a>
<a name="index-failure_002c-irrecoverable-hard"></a>
<em>irrecoverable hard failure</em>
is
an irrecoverable Libmarpa application programming failure that has an
error code associated with it.
Libmarpa attempts to behave as predictably as possible
in the face of a hard failure,
but once an irrecoverable failure occurs,
the behavior of a Libmarpa application is undefined.
</p>
<p>In the event of an irrecoverable failure,
there are no application behaviors.
The diagnostic behavior for a hard failure is as described
for the method that detects the hard failure.
At a minimum, this diagnostic behavior will be returning from
the method that detects the hard failure with the return
value specified for hard failure,
and setting the error code as specified for hard failure.
</p>
<hr>
<a name="Partially-recoverable-hard-failure"></a>
<div class="header">
<p>
Next: <a href="#Library_002drecoverable-hard-failure" accesskey="n" rel="next">Library-recoverable hard failure</a>, Previous: <a href="#Irrecoverable-hard-failure" accesskey="p" rel="prev">Irrecoverable hard failure</a>, Up: <a href="#Failure" accesskey="u" rel="up">Failure</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Partially-recoverable-hard-failure-1"></a>
<h3 class="section">14.7 Partially recoverable hard failure</h3>

<p>A
<a name="index-partially-recoverable-hard-failure"></a>
<a name="index-hard-failure_002c-partially-recoverable"></a>
<a name="index-failure_002c-partially-recoverable-hard"></a>
<em>partially recoverable hard failure</em>
is
a recoverable Libmarpa application programming failure
</p><ul>
<li> that has an error code associated with it; and
</li><li> after which some, but not all, of the
    application behaviors remain available to the programmer.
</li></ul>
<p>For every partially recoverable hard failure,
this document specifies the application behaviors that remain
available after it occurs.
The most common kind of
partially recoverable hard failure is a
library-recoverable hard failure.
For an example of
partially recoverable hard failure,
see <a href="#Library_002drecoverable-hard-failure">Library-recoverable hard failure</a>.
</p>
<hr>
<a name="Library_002drecoverable-hard-failure"></a>
<div class="header">
<p>
Next: <a href="#Ancestry_002drecoverable-hard-failure" accesskey="n" rel="next">Ancestry-recoverable hard failure</a>, Previous: <a href="#Partially-recoverable-hard-failure" accesskey="p" rel="prev">Partially recoverable hard failure</a>, Up: <a href="#Failure" accesskey="u" rel="up">Failure</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Library_002drecoverable-hard-failure-1"></a>
<h3 class="section">14.8 Library-recoverable hard failure</h3>

<p>A
<a name="index-library_002drecoverable-hard-failure"></a>
<a name="index-hard-failure_002c-library_002drecoverable"></a>
<a name="index-failure_002c-library_002drecoverable-hard"></a>
<em>library-recoverable hard failure</em>
is a type of partially recoverable hard failure.
Loosely described, it is a hard failure that
allows the programmer to continue to use many
of the Libmarpa methods in the library,
but that disallows certain methods on  some objects.
</p>
<p>To state the restrictions of application behaviors
more precisely, let
the &ldquo;failure grammar&rdquo; be the base grammar
of the method that detected the library-recoverable hard failure.
After a library-recoverable hard failure,
the following behaviors are no longer application
behaviors:
</p><ul>
<li> Libmarpa mutator and constructor method calls where the base grammar is the
  failure grammar.
</li></ul>
<p>Recall that any use of a behavior that is not an application
behavior is an irrecoverable failure.
</p>
<p>The application behaviors
remaining after a library-recoverable hard failure
are the following:
</p><ul>
<li> All non-Libmarpa interfaces,
including calls to libraries
in the application and in the application environment.
</li><li> All Libmarpa static method calls.
</li><li> All Libmarpa accessor and destructor method calls.
</li><li> All Libmarpa mutator and constructor method calls
whose base grammar is not the failure grammar.
</li></ul>

<p>Note that Libmarpa destructors remain available after
a library recoverable failure.
An application will often want to destroy all Libmarpa objects
whose base grammar is the failure grammar,
in order to clear memory of problematic objects.
</p>
<p>An example of a library-recoverable hard failure is
the <code>MARPA_ERR_COUNTED_NULLABLE</code> error
in the <code>marpa_g_precompute</code> method.
See <a href="#marpa_005fg_005fprecompute">marpa_g_precompute()</a>.
</p>
<hr>
<a name="Ancestry_002drecoverable-hard-failure"></a>
<div class="header">
<p>
Next: <a href="#Fully-recoverable-hard-failure" accesskey="n" rel="next">Fully recoverable hard failure</a>, Previous: <a href="#Library_002drecoverable-hard-failure" accesskey="p" rel="prev">Library-recoverable hard failure</a>, Up: <a href="#Failure" accesskey="u" rel="up">Failure</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Ancestry_002drecoverable-hard-failure-1"></a>
<h3 class="section">14.9 Ancestry-recoverable hard failure</h3>

<p>An
<a name="index-ancestry_002drecoverable-hard-failure"></a>
<a name="index-hard-failure_002c-ancestry_002drecoverable"></a>
<a name="index-failure_002c-ancestry_002drecoverable-hard"></a>
<em>ancestry-recoverable hard failure</em>
is a type of partially recoverable hard failure.
An ancestry-recoverable failure allows a superset of the application behaviors
allowed by a library-recoverable hard failure.
More precisely, let
the &ldquo;failure object&rdquo; be the object that detected
the ancestry-recoverable hard failure.
After an ancestry-recoverable hard failure,
the following behaviors are no longer application
behaviors:
</p><ul>
<li> Libmarpa mutator and constructor method calls where the object is the
  failure object, or one of its descendants.
</li></ul>
<p>Recall that any use of a behavior that is not an application
behavior is an irrecoverable failure.
</p>
<p>The application behaviors
remaining after a ancestry-recoverable hard failure
are the following:
</p><ul>
<li> All non-Libmarpa interfaces,
including calls to libraries
in the application and in the application environment.
</li><li> All Libmarpa static method calls.
</li><li> All Libmarpa accessor and destructor method calls.
</li><li> All Libmarpa mutator and constructor method calls
for time objects that are not the failure object,
or one of its descendants.
</li></ul>

<p>Note that all Libmarpa destructors remain available after
an ancestry-recoverable failure.
An application will often want to destroy the failure object
and all of its descendants,
in order to clear memory of problematic objects.
</p>
<p>As an example,
users calling <code>marpa_g_precompute()</code>
will often want to treat a <code>MARPA_EVENT_EARLEY_ITEM_THRESHOLD</code> event
as if it were an ancestry-recoverable hard failure.
See <a href="#marpa_005fg_005fprecompute">marpa_g_precompute()</a>.
</p>
<p>Library-recoverable failure is a special case of ancestry-recoverable
failure.
When the failure object is a grammar,
ancestry-recoverable failure is synonymous with
library-recoverable failure.
</p>
<hr>
<a name="Fully-recoverable-hard-failure"></a>
<div class="header">
<p>
Next: <a href="#Soft-failure" accesskey="n" rel="next">Soft failure</a>, Previous: <a href="#Ancestry_002drecoverable-hard-failure" accesskey="p" rel="prev">Ancestry-recoverable hard failure</a>, Up: <a href="#Failure" accesskey="u" rel="up">Failure</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Fully-recoverable-hard-failure-1"></a>
<h3 class="section">14.10 Fully recoverable hard failure</h3>

<p>A
<a name="index-fully-recoverable-hard-failure"></a>
<a name="index-hard-failure_002c-fully-recoverable"></a>
<a name="index-failure_002c-fully-recoverable-hard"></a>
<em>fully recoverable hard failure</em>
is
a recoverable Libmarpa application programming failure
</p><ul>
<li> that has an error code associated with it; and
</li><li> after which all of the
    application behaviors remain available to the programmer.
</li></ul>
<p>One example of a fully recoverable hard failure is
the error code <code>MARPA_ERR_UNEXPECTED_TOKEN_ID</code>.
The &ldquo;Ruby Slippers&rdquo; parsing technique
(see <a href="#Ruby-Slippers">Ruby Slippers</a>),
which has seen extensive usage,
is based
on Libmarpa&rsquo;s ability to recover from
a <code>MARPA_ERR_UNEXPECTED_TOKEN_ID</code> error
fully and efficiently,
</p>
<hr>
<a name="Soft-failure"></a>
<div class="header">
<p>
Next: <a href="#Error-codes" accesskey="n" rel="next">Error codes</a>, Previous: <a href="#Fully-recoverable-hard-failure" accesskey="p" rel="prev">Fully recoverable hard failure</a>, Up: <a href="#Failure" accesskey="u" rel="up">Failure</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Soft-failure-1"></a>
<h3 class="section">14.11 Soft failure</h3>

<p>A
<a name="index-soft-failure-1"></a>
<a name="index-failure_002c-soft-1"></a>
<em>soft failure</em>
is
a recoverable Libmarpa application programming failure that has no
error code associated with it.
Hard errors are assigned error codes in order to tell them apart.
Error codes are not necessary or useful for soft errors,
because there is at most one type of soft failure per Libmarpa method.
</p>
<p><em>Soft failures</em>
are so called,
because they are the least severe kind of failure.
The most severe failures are &ldquo;bugs&rdquo; &mdash;
unintended, and a symptom of a problem.
Soft failures, on the other hand, are a frequent occurrence
in normal, successful, processing.
In the phrase &ldquo;soft failure&rdquo;, the word &ldquo;failure&rdquo; is used
in the same sense that its cognate &ldquo;fail&rdquo; is used
when we say that a loop terminates when it &ldquo;fails&rdquo; its
loop condition.
That &rdquo;failure&rdquo; is the failure of a condition necessary to continue on
a main branch of processing, and a signal to proceed on another branch.
</p>
<p>It is expected that Libmarpa applications will be designed
such that successful execution
requires handling soft failures.
In fact, a non-trivial Libmarpa application can hardly be designed
except on that basis.
</p>
<hr>
<a name="Error-codes"></a>
<div class="header">
<p>
Previous: <a href="#Soft-failure" accesskey="p" rel="prev">Soft failure</a>, Up: <a href="#Failure" accesskey="u" rel="up">Failure</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Error-codes-1"></a>
<h3 class="section">14.12 Error codes</h3>

<p>As stated, every hard failure has an associated error code.
Full descriptions of the error codes
that are returned by the external methods
are given in their own section
(<a href="#External-error-codes">External error codes</a>).
</p>
<p>How the error code is accessed depends on the method
that detects the hard failure associated with that error code.
Methods for time objects always set the error code in the base grammar,
from which it may be accessed using the error methods described below.
See <a href="#Error-methods">Error methods</a>.
If a method has no base grammar,
the description of that method
will state how to access the error code for a hard failure
detected by that method.
</p>
<p>Since the error of a time object is set in the base grammar,
it follows that every object with the same base grammar
has the same error code.
Objects with different base grammars may have different error codes.
</p>
<p>While error codes are properties of a base grammar,
irrecoverability is application-wide.
That is, whenever any irrecoverable failure occurs, the entire
application is irrecoverable.
Once an application becomes irrecoverable,
those Libmarpa objects with error codes for recoverable errors
are still subject to the general irrecoverability.
</p>
<hr>
<a name="Introduction-to-the-method-descriptions"></a>
<div class="header">
<p>
Next: <a href="#Static-methods" accesskey="n" rel="next">Static methods</a>, Previous: <a href="#Failure" accesskey="p" rel="prev">Failure</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Introduction-to-the-method-descriptions-1"></a>
<h2 class="chapter">15 Introduction to the method descriptions</h2>

<p>The following chapters describe Libmarpa&rsquo;s methods
in detail.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#About-the-overviews" accesskey="1">About the overviews</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Naming-conventions" accesskey="2">Naming conventions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Return-values" accesskey="3">Return values</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#How-to-read-the-method-descriptions" accesskey="4">How to read the method descriptions</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="About-the-overviews"></a>
<div class="header">
<p>
Next: <a href="#Naming-conventions" accesskey="n" rel="next">Naming conventions</a>, Previous: <a href="#Introduction-to-the-method-descriptions" accesskey="p" rel="prev">Introduction to the method descriptions</a>, Up: <a href="#Introduction-to-the-method-descriptions" accesskey="u" rel="up">Introduction to the method descriptions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="About-the-overviews-1"></a>
<h3 class="section">15.1 About the overviews</h3>

<p>The method descriptions are grouped into chapters and sections.
Each such group of methods descriptions begins, optionally, with an overview.
These overviews, again optionally, end with a &ldquo;cheat sheet&rdquo;.
The &ldquo;cheat sheets&rdquo; name the
most important Libmarpa methods in that chapter
or section,
in the order in which they are typically used,
and very briefly describe their purpose.
</p>
<p>The overviews sometimes speak of
an &ldquo;archetypal&rdquo; application.
The
<a name="index-archetypal-Libmarpa-application"></a>
<a name="index-Libmarpa-application_002c-archetypal"></a>
<em>archetypal Libmarpa application</em>
implements a complete logic flow,
starting with the creation of a grammar,
and proceeding all the way
to the return of the final result from a value object.
In the archetypal Libmarpa application,
the grammar, input and semantics are
all small but non-trivial.
</p>
<hr>
<a name="Naming-conventions"></a>
<div class="header">
<p>
Next: <a href="#Return-values" accesskey="n" rel="next">Return values</a>, Previous: <a href="#About-the-overviews" accesskey="p" rel="prev">About the overviews</a>, Up: <a href="#Introduction-to-the-method-descriptions" accesskey="u" rel="up">Introduction to the method descriptions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Naming-conventions-1"></a>
<h3 class="section">15.2 Naming conventions</h3>

<p>Methods in Libmarpa follow a strict naming convention.
All methods have a name beginning with
<code>marpa_</code>,
if they are part of the
external interface.
If an external method is not a static method,
its name is prefixed with one of
<code>marpa_c_</code>,
<code>marpa_g_</code>,
<code>marpa_r_</code>,
<code>marpa_b_</code>,
<code>marpa_o_</code>,
<code>marpa_t_</code> or
<code>marpa_v_</code>,
where the single letter between underscores
is one of the Libmarpa major class abbreviations.
The letter indicates which class
the method belongs to.
</p>
<p>Methods that are exported,
but that are part of
the internal interface,
begin with <code>_marpa_</code>.
Methods that are part of the internal interface
(often called &ldquo;internal methods&rdquo;)
are subject to change and are intended for use
only by Libmarpa&rsquo;s developers.
</p>
<p>Libmarpa reserves the
<code>marpa_</code>
and <code>_marpa_</code> prefixes for itself,
with all their capitalization variants.
All Libmarpa names visible outside the package
will begin with a capitalization variant
of one of these two prefixes.
</p>
<hr>
<a name="Return-values"></a>
<div class="header">
<p>
Next: <a href="#How-to-read-the-method-descriptions" accesskey="n" rel="next">How to read the method descriptions</a>, Previous: <a href="#Naming-conventions" accesskey="p" rel="prev">Naming conventions</a>, Up: <a href="#Introduction-to-the-method-descriptions" accesskey="u" rel="up">Introduction to the method descriptions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Return-values-1"></a>
<h3 class="section">15.3 Return values</h3>

<p>Some general conventions for return values are worth
mentioning:
</p><ul>
<li> For methods that return an integer,
a return value of -1
usually indicates soft method failure.
</li><li> For methods that return an integer,
a return value of -2
usually indicates hard method failure.
</li><li> For methods that return an integer,
a return value greater of zero or more usually indicates method success.
</li><li> If a method returns an pointer value,
<code>NULL</code> usually indicates method failure.
Any other result usually indicates method success.
</li></ul>

<p>The words &ldquo;success&rdquo; and &ldquo;failure&rdquo; are heavily overloaded
in these documents.
But in contexts where our meaning is clear we will usually
abbreviate &ldquo;method success&rdquo; and &ldquo;method failure&rdquo; to
&ldquo;success&rdquo; and &ldquo;failure&rdquo;, respectively.
</p>
<p>While these general conventions are a memory aid,
there are exceptions,
and the programmer must look at the return value summary
in the description of every method they use.
</p>
<p>As one example of an exception,
for certain methods,
a return value of -2 is ambiguous:
-2 can be both a valid return value
for method success, and a potential indication of hard method failure.
An example of a method where -2 is ambiguous is
<code>marpa_g_rule_rank_set()</code>.
See <a href="#marpa_005fg_005frule_005frank_005fset">marpa_g_rule_rank_set</a>.
In cases like <code>marpa_g_rule_rank_set()</code>,
the programmer must distinguish the two return statuses
based on the error code.
</p>
<p>Whenever a method departs from the general return value conventions,
the departure will be detailed in the description of that method.
Any departure by a method from the general return value conventions
will always be indicated
in the return value summary for that method.
</p>
<hr>
<a name="How-to-read-the-method-descriptions"></a>
<div class="header">
<p>
Previous: <a href="#Return-values" accesskey="p" rel="prev">Return values</a>, Up: <a href="#Introduction-to-the-method-descriptions" accesskey="u" rel="up">Introduction to the method descriptions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="How-to-read-the-method-descriptions-1"></a>
<h3 class="section">15.4 How to read the method descriptions</h3>

<p>The method descriptions are written on the assumption
that the reader has the following in mind while reading them:
</p>
<ul>
<li> Each method description begins with the signature
of its &ldquo;topic method&rdquo;.
</li><li> In the method description, the phrase &ldquo;this method&rdquo;
always refers to the topic method.
</li><li> Whenever &ldquo;this method&rdquo; is the subject of a sentence
in the method description, it may be elided,
so that, for example,
<blockquote>
<p>This method returns 42.
</p></blockquote>
<p>becomes
</p><blockquote>
<p>Returns 42.
</p></blockquote>
</li><li> In a time object method,
    the instance, sometimes called the &ldquo;self argument&rdquo;,
    is always the first argument of the method.
    In the descriptions of time object methods,
    references to the base objects of the instance
    are often left implied.
    For example, rather than write
    &ldquo;the rule with ID <var>id</var> in the base grammar&rdquo;,
    we will usually write
    &ldquo;the rule with ID <var>id</var>&rdquo;.
    References to time objects other than base objects
    of the instance are always explicitly stated,
    as are references to multiple time objects.
</li><li> If the return type of a method is not <code>void</code>,
the last paragraph of its method description is a
&ldquo;return value summary&rdquo;.
The return value summary
starts with the label &ldquo;<strong>Return Value</strong>&rdquo;.
</li><li> Every method returns in exactly one of three
statuses: success, hard failure, or soft failure.
</li><li> A return status of hard failure indicates that the method detected
a hard failure.
</li><li> A method may have several kinds of hard failure,
including several kinds of irrecoverable hard failure
and several kinds of recoverable hard failure.
On return, these can be distinguished by their error codes.
</li><li> If a method call hard fails,
its error code is that associated with the hard failure.
Unless stated otherwise in the return value summary,
the error code is set in the base
grammar of the method call, and may be accessed
with the methods described below.
See <a href="#Error-methods">Error methods</a>.
</li><li> If a method allows a recoverable hard failure, this is explicitly stated
in its return value summary,
along with the associated error code.
The method description will state
the circumstances under which the recoverable hard failure occurs,
and what the application must do to recover.
</li><li> A return status of soft failure indicates that the method detected
a soft failure.
</li><li> Every method has at most one kind of soft failure.
</li><li> If a method allows a soft failure, this is explicitly stated
in its return value summary,
and the method description will state
the circumstances under which the soft failure occurs,
and what the application must do to recover.
</li><li> If a method call soft fails, the value of the error code is
unspecified.
</li><li> If a method call succeeds, the value of the error code is
unspecified.
</li><li> A return status of success indicates that the method did not detect
any failures.
</li><li> If both a hard failure and a soft failure occur,
the return status will be hard failure.
</li><li> If both a recoverable hard failure and
an irrecoverable hard failure occur,
the error code will be for an irrecoverable hard failure.
</li><li> The behaviors specified for success and soft failure
are application behaviors.
</li><li> The behaviors specified for hard failures
are diagnostic behaviors if an irrecoverable failure
occurred,
and application behaviors otherwise.
</li></ul>

<hr>
<a name="Static-methods"></a>
<div class="header">
<p>
Next: <a href="#Configuration-methods" accesskey="n" rel="next">Configuration methods</a>, Previous: <a href="#Introduction-to-the-method-descriptions" accesskey="p" rel="prev">Introduction to the method descriptions</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Static-methods-1"></a>
<h2 class="chapter">16 Static methods</h2>

<a name="marpa_005fcheck_005fversion"></a><dl>
<dt><a name="index-marpa_005fcheck_005fversion"></a>Accessor function: <em>Marpa_Error_Code</em> <strong>marpa_check_version</strong> <em>(     int <var>required_major</var>,     int <var>required_minor</var>,     int <var>required_micro</var>     )</em></dt>
<dd>
<p>Checks that the Marpa library in use is compatible with the
given version. Generally, the application programmer will pass in the constants
<code>MARPA_MAJOR_VERSION</code>,
<code>MARPA_MINOR_VERSION</code>, and
<code>MARPA_MICRO_VERSION</code>
as the three arguments,
to check that their application was compiled with headers
that match the version of Libmarpa that they
are using.
</p>
<p>If <var>required_major</var>.<var>required_minor</var>.<var>required_micro</var>
is an exact match with the version of Libmarpa,
the method succeeds.
The version of Libmarpa described in this manual is 11.0.9.
Otherwise the return status is an irrecoverable
hard failure.
</p>
<p><strong>Return value</strong>: On success, <code>MARPA_ERR_NONE</code>.
On hard failure, the error code.
</p>
</dd></dl>

<a name="marpa_005fversion"></a><dl>
<dt><a name="index-marpa_005fversion"></a>Accessor function: <em>Marpa_Error_Code</em> <strong>marpa_version</strong> <em>(     int* version)</em></dt>
<dd>
<p>Writes the version number in <var>version</var>.
It is an undetected irrecoverable hard failure
if <var>version</var> does not have room for three <code>int</code>&rsquo;s.
</p>
<p><strong>Return value</strong>: Always succeeds.
The return value is unspecified.
</p>
</dd></dl>

<hr>
<a name="Configuration-methods"></a>
<div class="header">
<p>
Next: <a href="#Grammar-methods" accesskey="n" rel="next">Grammar methods</a>, Previous: <a href="#Static-methods" accesskey="p" rel="prev">Static methods</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Configuration-methods-1"></a>
<h2 class="chapter">17 Configuration methods</h2>

<p>The configuration object is intended for future extensions.
Currently, the only function of the <code>Marpa_Config</code>
class is to give
<code>marpa_g_new()</code>
a place to put its error code.
</p>
<p><code>Marpa_Config</code> is Libmarpa&rsquo;s only &ldquo;major&rdquo;
class which is not a time class.
There is no constructor or destructor, although
<code>Marpa_Config</code> objects <strong>do</strong> need to be initialized
before use.
Aside from its own accessor,
<code>Marpa_Config</code> objects are only used by
<code>marpa_g_new()</code>
and no reference to their location is kept
in any of Libmarpa&rsquo;s time objects.
The intent is that it be convenient
to have <code>Marpa_Config</code> objects
in memory that might be deallocated
soon after
<code>marpa_g_new()</code>
returns.
For example, they could be put on the stack.
</p>
<a name="marpa_005fc_005finit"></a><dl>
<dt><a name="index-marpa_005fc_005finit"></a>Mutator function: <em>int</em> <strong>marpa_c_init</strong> <em>(   Marpa_Config* <var>config</var>)</em></dt>
<dd>
<p>Initialize the <var>config</var> information to &ldquo;safe&rdquo; default
values.
An irrecoverable error will result
if an uninitialized
configuration is used to create a grammar.
</p>
<p><strong>Return value</strong>: Always succeeds.  The return value is unspecified.
</p>
</dd></dl>

<a name="marpa_005fc_005ferror"></a><dl>
<dt><a name="index-marpa_005fc_005ferror"></a>Accessor function: <em>Marpa_Error_Code</em> <strong>marpa_c_error</strong> <em>(   Marpa_Config* <var>config</var>, const char** <var>p_error_string</var> )</em></dt>
<dd>
<p>Error codes are usually kept in the base grammar,
which leaves
<code>marpa_g_new()</code>
no place to put
its error code on failure.
Objects of
the <code>Marpa_Config</code> class provide such a place.
<var>p_error_string</var> is reserved for use by
the internals.
Applications should set it to <code>NULL</code>.
</p>
<p><strong>Return value</strong>: The error code in <var>config</var>.
Always succeeds, so that
<code>marpa_c_error()</code>
never requires an error code
for itself.
</p>
</dd></dl>

<hr>
<a name="Grammar-methods"></a>
<div class="header">
<p>
Next: <a href="#Recognizer-methods" accesskey="n" rel="next">Recognizer methods</a>, Previous: <a href="#Configuration-methods" accesskey="p" rel="prev">Configuration methods</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Grammar-methods-1"></a>
<h2 class="chapter">18 Grammar methods</h2>
<a name="index-grammars"></a>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Grammar-overview" accesskey="1">Grammar overview</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Grammar-constructor" accesskey="2">Grammar constructor</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Grammar-reference-counting" accesskey="3">Grammar reference counting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Symbol-methods" accesskey="4">Symbol methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Rule-methods" accesskey="5">Rule methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Sequence-methods" accesskey="6">Sequence methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Rank-methods" accesskey="7">Rank methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Grammar-precomputation" accesskey="8">Grammar precomputation</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Grammar-overview"></a>
<div class="header">
<p>
Next: <a href="#Grammar-constructor" accesskey="n" rel="next">Grammar constructor</a>, Previous: <a href="#Grammar-methods" accesskey="p" rel="prev">Grammar methods</a>, Up: <a href="#Grammar-methods" accesskey="u" rel="up">Grammar methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Overview"></a>
<h3 class="section">18.1 Overview</h3>

<p>An archetypal application has a grammar.
To create a grammar, use the
<code>marpa_g_new()</code>
method.
When a grammar is no longer in use, its memory can be freed
using the
<code>marpa_g_unref()</code>
method.
</p>
<p>To be precomputed,
a grammar must have one or more symbols.
To create symbols, use the
<code>marpa_g_symbol_new()</code>
method.
</p>
<p>To be precomputed,
a grammar must have one or more rules.
To create rules, use the
<code>marpa_g_rule_new()</code>
and
<code>marpa_g_sequence_new()</code>
methods.
</p>
<p>To be precomputed,
a grammar must have exactly one start symbol.
To mark a symbol as the start symbol,
use the
<code>marpa_g_start_symbol_set()</code>
method.
</p>
<p>Before parsing with a grammar, it must be precomputed.
To precompute a grammar,
use the
<code>marpa_g_precompute()</code>
method.
</p>
<hr>
<a name="Grammar-constructor"></a>
<div class="header">
<p>
Next: <a href="#Grammar-reference-counting" accesskey="n" rel="next">Grammar reference counting</a>, Previous: <a href="#Grammar-overview" accesskey="p" rel="prev">Grammar overview</a>, Up: <a href="#Grammar-methods" accesskey="u" rel="up">Grammar methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Creating-a-new-grammar"></a>
<h3 class="section">18.2 Creating a new grammar</h3>
<a name="index-grammar-constructor"></a>

<a name="marpa_005fg_005fnew"></a><dl>
<dt><a name="index-marpa_005fg_005fnew"></a>Constructor function: <em>Marpa_Grammar</em> <strong>marpa_g_new</strong> <em>(     Marpa_Config* <var>configuration</var> )</em></dt>
<dd>
<p>Creates a new grammar time object.
The returned grammar object is not yet precomputed,
and will have no symbols and rules.
Its reference count will be 1.
</p>
<p>Unless the application calls
<code>marpa_c_error()</code>,
Libmarpa will not reference the location
pointed to by the <var>configuration</var>
argument after
<code>marpa_g_new()</code>
returns.
(See <a href="#marpa_005fc_005ferror">marpa_c_error()</a>.)
The <var>configuration</var> argument may be <code>NULL</code>,
but if it is,
there will be no way to determine
the error code on failure.
</p>
<p><strong>Return value</strong>: On success, the grammar object.
On hard failure, <code>NULL</code>.
Also on hard failure,
if the <var>configuration</var> argument is not <code>NULL</code>,
the error code is set in <var>configuration</var>.
The error code may be accessed using
<code>marpa_c_error()</code>.
</p>
</dd></dl>

<a name="marpa_005fg_005fforce_005fvalued"></a><dl>
<dt><a name="index-marpa_005fg_005fforce_005fvalued"></a>Mutator function: <em>int</em> <strong>marpa_g_force_valued</strong> <em>(     Marpa_Grammar <var>g</var> )</em></dt>
<dd>
<p>It is recommended that
this call be made immediately after the
grammar constructor.
It turns off a deprecated feature.
</p>
<p>The
<code>marpa_g_force_valued()</code> method
forces all the
symbols in a grammar to be &ldquo;valued&rdquo;.
The parse cares about the value of the symbol iff
the symbol is &ldquo;valued&rdquo;.
In the past, symbols were allowed to be &ldquo;unvalued&rdquo;
in the hope of gaining efficiencies at evaluation time.
Use of unvalued symbols is now deprecated,
because current thinking is that the gains do not repay the extra
complexity.
</p>
<p><strong>Return value</strong>: On success, a non-negative integer, whose value is otherwise unspecified.
On failure, -2.
</p></dd></dl>

<hr>
<a name="Grammar-reference-counting"></a>
<div class="header">
<p>
Next: <a href="#Symbol-methods" accesskey="n" rel="next">Symbol methods</a>, Previous: <a href="#Grammar-constructor" accesskey="p" rel="prev">Grammar constructor</a>, Up: <a href="#Grammar-methods" accesskey="u" rel="up">Grammar methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Tracking-the-reference-count-of-the-grammar"></a>
<h3 class="section">18.3 Tracking the reference count of the grammar</h3>
<a name="index-grammar-destructor"></a>
<a name="index-grammar-reference"></a>
<a name="index-grammar-reference-count"></a>

<a name="marpa_005fg_005fref"></a><dl>
<dt><a name="index-marpa_005fg_005fref"></a>Mutator function: <em>Marpa_Grammar</em> <strong>marpa_g_ref</strong> <em>(Marpa_Grammar <var>g</var>)</em></dt>
<dd>
<p>Increases the reference count of <var>g</var> by 1.
Not needed by most applications.
</p>
<p><strong>Return value</strong>:
On success, <var>g</var>.
On hard failure, <code>NULL</code>.
</p>
</dd></dl>

<a name="marpa_005fg_005funref"></a><dl>
<dt><a name="index-marpa_005fg_005funref"></a>Destructor function: <em>void</em> <strong>marpa_g_unref</strong> <em>(Marpa_Grammar <var>g</var>)</em></dt>
<dd>
<p>Decreases the reference count by 1,
destroying <var>g</var> once the reference count reaches
zero.
</p>
</dd></dl>

<hr>
<a name="Symbol-methods"></a>
<div class="header">
<p>
Next: <a href="#Rule-methods" accesskey="n" rel="next">Rule methods</a>, Previous: <a href="#Grammar-reference-counting" accesskey="p" rel="prev">Grammar reference counting</a>, Up: <a href="#Grammar-methods" accesskey="u" rel="up">Grammar methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Symbol-methods-1"></a>
<h3 class="section">18.4 Symbol methods</h3>

<a name="marpa_005fg_005fstart_005fsymbol"></a><dl>
<dt><a name="index-marpa_005fg_005fstart_005fsymbol"></a>Accessor function: <em>Marpa_Symbol_ID</em> <strong>marpa_g_start_symbol</strong> <em>(Marpa_Grammar <var>g</var>)</em></dt>
<dd>
<p>When successful, returns the ID of the start symbol.
Soft fails, if there is no start symbol.
The start symbol is set by the
<code>marpa_g_start_symbol_set()</code>
call.
</p>
<p><strong>Return value</strong>:
On success, the ID of the start symbol,
which is always a non-negative integer.
On soft failure, -1.
On hard failure, -2.
</p></dd></dl>

<a name="marpa_005fg_005fstart_005fsymbol_005fset"></a><dl>
<dt><a name="index-marpa_005fg_005fstart_005fsymbol_005fset"></a>Mutator function: <em>Marpa_Symbol_ID</em> <strong>marpa_g_start_symbol_set</strong> <em>(     Marpa_Grammar <var>g</var>,     Marpa_Symbol_ID <var>sym_id</var>)</em></dt>
<dd>
<p>When successful,
sets the start symbol of grammar <var>g</var> to symbol <var>sym_id</var>.
Soft fails iff <var>sym_id</var> is well-formed (a non-negative integer),
but a symbol with that ID does not exist.
</p>
<p><strong>Return value</strong>: On success, <var>sym_id</var>,
which will always be a non-negative integer.
On soft failure, -1.
On hard failure, -2.
</p>
</dd></dl>

<a name="marpa_005fg_005fhighest_005fsymbol_005fid"></a><dl>
<dt><a name="index-marpa_005fg_005fhighest_005fsymbol_005fid"></a>Accessor function: <em>int</em> <strong>marpa_g_highest_symbol_id</strong> <em>(Marpa_Grammar <var>g</var>)</em></dt>
<dd>
<p><strong>Return value</strong>: On success, the maximum symbol ID
of <var>g</var>.
On hard failure, -2.
</p></dd></dl>

<a name="marpa_005fg_005fsymbol_005fis_005faccessible"></a><dl>
<dt><a name="index-marpa_005fg_005fsymbol_005fis_005faccessible"></a>Accessor function: <em>int</em> <strong>marpa_g_symbol_is_accessible</strong> <em>(Marpa_Grammar <var>g</var>,     Marpa_Symbol_ID <var>sym_id</var>)</em></dt>
<dd>
<p>Soft fails iff <var>sym_id</var> is well-formed (a non-negative integer),
but a symbol with that ID does not exist.
A common hard failure is calling this method with
a grammar that is not precomputed.
</p>
<p><strong>Return value</strong>: On success, 1 if symbol <var>sym_id</var> is accessible, 0 if not.
On soft failure, -1.
On hard failure, -2.
</p>
</dd></dl>

<a name="marpa_005fg_005fsymbol_005fis_005fnullable"></a><dl>
<dt><a name="index-marpa_005fg_005fsymbol_005fis_005fnullable"></a>Accessor function: <em>int</em> <strong>marpa_g_symbol_is_nullable</strong> <em>(   Marpa_Grammar g, Marpa_Symbol_ID sym_id)</em></dt>
<dd>
<p>Soft fails iff <var>sym_id</var> is well-formed (a non-negative integer),
but a symbol with that ID does not exist.
A common hard failure is calling this method with
a grammar that is not precomputed.
</p>
<p><strong>Return value</strong>: On success, 1 if symbol <var>sym_id</var> is nullable, 0 if not.
On soft failure, -1.
On hard failure, -2.
</p>
</dd></dl>

<a name="marpa_005fg_005fsymbol_005fis_005fnulling"></a><dl>
<dt><a name="index-marpa_005fg_005fsymbol_005fis_005fnulling"></a>Accessor function: <em>int</em> <strong>marpa_g_symbol_is_nulling</strong> <em>(Marpa_Grammar <var>g</var>,     Marpa_Symbol_ID <var>sym_id</var>)</em></dt>
<dd>
<p>Soft fails iff <var>sym_id</var> is well-formed (a non-negative integer),
but a symbol with that ID does not exist.
A common hard failure is calling this method with
a grammar that is not precomputed.
</p>
<p><strong>Return value</strong>: On success, 1 if symbol <var>sym_id</var> is nulling, 0 if not.
On soft failure, -1.
On hard failure, -2.
</p>
</dd></dl>

<a name="marpa_005fg_005fsymbol_005fis_005fproductive"></a><dl>
<dt><a name="index-marpa_005fg_005fsymbol_005fis_005fproductive"></a>Accessor function: <em>int</em> <strong>marpa_g_symbol_is_productive</strong> <em>(Marpa_Grammar <var>g</var>,     Marpa_Symbol_ID <var>sym_id</var>)</em></dt>
<dd>
<p>Soft fails iff <var>sym_id</var> is well-formed (a non-negative integer),
but a symbol with that ID does not exist.
A common hard failure is calling this method with
a grammar that is not precomputed.
</p>
<p><strong>Return value</strong>: On success, 1 if symbol <var>sym_id</var> is productive, 0 if not.
On soft failure, -1.
On hard failure, -2.
</p>
</dd></dl>

<a name="marpa_005fg_005fsymbol_005fis_005fstart"></a><dl>
<dt><a name="index-marpa_005fg_005fsymbol_005fis_005fstart"></a>Accessor function: <em>int</em> <strong>marpa_g_symbol_is_start</strong> <em>( Marpa_Grammar <var>g</var>,     Marpa_Symbol_ID <var>sym_id</var>)</em></dt>
<dd>
<p>On success, if <var>sym_id</var> is the start symbol, returns 1.
On success, if <var>sym_id</var> is not the start symbol, returns 0.
On success, if no start symbol has been set, returns 0.
</p>
<p>Soft fails iff <var>sym_id</var> is well-formed (a non-negative integer),
but a symbol with that ID does not exist.
</p>
<p><strong>Return value</strong>:
On success, 1 or 0.
On soft failure, -1.
On hard failure, -2.
</p>
</dd></dl>

<a name="marpa_005fg_005fsymbol_005fis_005fterminal"></a><dl>
<dt><a name="index-marpa_005fg_005fsymbol_005fis_005fterminal"></a>Accessor function: <em>int</em> <strong>marpa_g_symbol_is_terminal</strong> <em>(     Marpa_Grammar <var>g</var>,     Marpa_Symbol_ID <var>sym_id</var>)</em></dt>
<dd>
<p>On success, if <var>sym_id</var> is a terminal symbol, returns 1.
On success, if <var>sym_id</var> is not a terminal symbol, returns 0.
To be used as an input symbol
in the
<code>marpa_r_alternative()</code>
method,
a symbol must be a terminal.
</p>
<p>Soft fails iff <var>sym_id</var> is well-formed (a non-negative integer),
but a symbol with that ID does not exist.
</p>
<p><strong>Return value</strong>:
On success, 1 or 0.
On soft failure, -1.
On hard failure, -2.
</p>
</dd></dl>

<a name="marpa_005fg_005fsymbol_005fnew"></a><dl>
<dt><a name="index-marpa_005fg_005fsymbol_005fnew"></a>Mutator function: <em>Marpa_Symbol_ID</em> <strong>marpa_g_symbol_new</strong> <em>(Marpa_Grammar <var>g</var>)</em></dt>
<dd>
<p>When successful, creates a new symbol in grammar <var>g</var>,
and returns the ID of the new symbol.
The symbol ID&rsquo;s are non-negative integers.
Within each grammar, a symbol&rsquo;s ID is unique to that symbol.
</p>
<p>Symbols are numbered consecutively, starting at 0.
That is, the first successful call of this method for a grammar returns the symbol
ID 0.
The second and later successful calls of <code>marpa_g_symbol_new()</code>,
return the symbol ID <code><var>n</var>+1</code>,
where <var>n</var> is the symbol ID returned by the previous successful call of
<code>marpa_g_symbol_new()</code>.
This makes it convenient for applications to store additional information
about the symbols in an array.
</p>
<p><strong>Return value</strong>: On success, the ID of the new symbol,
which will be a non-negative integer.
On hard failure, -2.
</p>
</dd></dl>

<hr>
<a name="Rule-methods"></a>
<div class="header">
<p>
Next: <a href="#Sequence-methods" accesskey="n" rel="next">Sequence methods</a>, Previous: <a href="#Symbol-methods" accesskey="p" rel="prev">Symbol methods</a>, Up: <a href="#Grammar-methods" accesskey="u" rel="up">Grammar methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Rule-methods-1"></a>
<h3 class="section">18.5 Rule methods</h3>

<a name="marpa_005fg_005fhighest_005frule_005fid"></a><dl>
<dt><a name="index-marpa_005fg_005fhighest_005frule_005fid"></a>Accessor function: <em>int</em> <strong>marpa_g_highest_rule_id</strong> <em>(Marpa_Grammar <var>g</var>)</em></dt>
<dd>
<p><strong>Return value</strong>: On success, the maximum rule ID
of <var>g</var>.
On hard failure, -2.
</p></dd></dl>

<a name="marpa_005fg_005frule_005fis_005faccessible"></a><dl>
<dt><a name="index-marpa_005fg_005frule_005fis_005faccessible"></a>Accessor function: <em>int</em> <strong>marpa_g_rule_is_accessible</strong> <em>(Marpa_Grammar <var>g</var>,     Marpa_Rule_ID <var>rule_id</var>)</em></dt>
<dd>
<p>On success, does the following:
</p><ul>
<li> If the rule whose ID is <var>rule_id</var> is accessible, returns 1.
</li><li> If the rule whose ID is <var>rule_id</var> is inaccessible, returns 0.
</li></ul>

<p>Soft fails iff <var>rule_id</var> is well-formed (a non-negative integer),
but a rule with that ID does not exist.
A common hard failure is calling this method with
a grammar that is not precomputed.
</p>
<p><strong>Return value</strong>: On success, 1 or 0.
On soft failure, -1.
On hard failure, -2.
</p>
</dd></dl>

<a name="marpa_005fg_005frule_005fis_005fnullable"></a><dl>
<dt><a name="index-marpa_005fg_005frule_005fis_005fnullable"></a>Accessor function: <em>int</em> <strong>marpa_g_rule_is_nullable</strong> <em>(   Marpa_Grammar <var>g</var>, Marpa_Rule_ID <var>ruleid</var>)</em></dt>
<dd>
<p>On success, does the following:
</p><ul>
<li> If the rule whose ID is <var>rule_id</var> is nullable, returns 1.
</li><li> If the rule whose ID is <var>rule_id</var> is non-nullable, returns 0.
</li></ul>

<p>Soft fails iff <var>rule_id</var> is well-formed (a non-negative integer),
but a rule with that ID does not exist.
A common hard failure is calling this method with
a grammar that is not precomputed.
</p>
<p><strong>Return value</strong>: On success, 1 or 0.
On soft failure, -1.
On hard failure, -2.
</p>
</dd></dl>

<a name="marpa_005fg_005frule_005fis_005fnulling"></a><dl>
<dt><a name="index-marpa_005fg_005frule_005fis_005fnulling"></a>Accessor function: <em>int</em> <strong>marpa_g_rule_is_nulling</strong> <em>(Marpa_Grammar <var>g</var>,     Marpa_Rule_ID <var>ruleid</var>)</em></dt>
<dd>
<p>On success, does the following:
</p><ul>
<li> If the rule whose ID is <var>rule_id</var> is nulling, returns 1.
</li><li> If the rule whose ID is <var>rule_id</var> is non-nulling, returns 0.
</li></ul>

<p>Soft fails iff <var>rule_id</var> is well-formed (a non-negative integer),
but a rule with that ID does not exist.
A common hard failure is calling this method with
a grammar that is not precomputed.
</p>
<p><strong>Return value</strong>: On success, 1 or 0.
On soft failure, -1.
On hard failure, -2.
</p>
</dd></dl>

<a name="marpa_005fg_005frule_005fis_005floop"></a><dl>
<dt><a name="index-marpa_005fg_005frule_005fis_005floop"></a>Accessor function: <em>int</em> <strong>marpa_g_rule_is_loop</strong> <em>(Marpa_Grammar <var>g</var>,     Marpa_Rule_ID <var>rule_id</var>)</em></dt>
<dd>
<p>On success, does the following:
</p><ul>
<li> If the rule whose ID is <var>rule_id</var> is a loop rule, returns 1.
</li><li> If the rule whose ID is <var>rule_id</var> is not a loop rule, returns 0.
</li></ul>

<p>A rule is a loop rule iff it non-trivially
produces the string of length one
that consists only of its LHS symbol.
The presence of a loop rule indicates that <var>g</var>
contains a cycle.
Parsing with a grammar that contains a cycle is deprecated.
<code>marpa_g_rule_is_loop</code> should only be used
for diagnostic purposes,
to allow a user to find the rules which cause the
cycle and to change the grammar to be cycle-free.
See <a href="#Cycles">Cycles</a>.
</p>
<p>Soft fails iff <var>rule_id</var> is well-formed (a non-negative integer),
but a rule with that ID does not exist.
A common hard failure is calling this method with
a grammar that is not precomputed.
</p>
<p><strong>Return value</strong>: On success, 1 or 0.
On soft failure, -1.
On hard failure, -2.
</p>
</dd></dl>

<a name="marpa_005fg_005frule_005fis_005fproductive"></a><dl>
<dt><a name="index-marpa_005fg_005frule_005fis_005fproductive"></a>Accessor function: <em>int</em> <strong>marpa_g_rule_is_productive</strong> <em>(Marpa_Grammar <var>g</var>,     Marpa_Rule_ID <var>rule_id</var>)</em></dt>
<dd>
<p>On success, does the following:
</p><ul>
<li> If the rule whose ID is <var>rule_id</var> is productive, returns 1.
</li><li> If the rule whose ID is <var>rule_id</var> is unproductive, returns 0.
</li></ul>

<p>Soft fails iff <var>rule_id</var> is well-formed (a non-negative integer),
but a rule with that ID does not exist.
A common hard failure is calling this method with
a grammar that is not precomputed.
</p>
<p><strong>Return value</strong>: On success, 1 or 0.
On soft failure, -1.
On hard failure, -2.
</p>
</dd></dl>

<a name="marpa_005fg_005frule_005flength"></a><dl>
<dt><a name="index-marpa_005fg_005frule_005flength"></a>Accessor function: <em>int</em> <strong>marpa_g_rule_length</strong> <em>(     Marpa_Grammar <var>g</var>,     Marpa_Rule_ID <var>rule_id</var>)</em></dt>
<dd>
<p>On success, returns the length of the rule with ID <var>rule_id</var>.
The length of a rule is the length of its RHS.
</p>
<p>Soft fails iff <var>rule_id</var> is well-formed (a non-negative integer),
but a rule with that ID does not exist.
</p>
<p><strong>Return value</strong>: On success,
the length of the rule with ID <var>rule_id</var>,
which is always a non-negative integer.
On soft failure, -1.
On hard failure, -2.
</p>
</dd></dl>

<a name="marpa_005fg_005frule_005flhs"></a><dl>
<dt><a name="index-marpa_005fg_005frule_005flhs"></a>Accessor function: <em>Marpa_Symbol_ID</em> <strong>marpa_g_rule_lhs</strong> <em>(     Marpa_Grammar <var>g</var>,     Marpa_Rule_ID <var>rule_id</var>)</em></dt>
<dd>
<p>Soft fails iff <var>rule_id</var> is well-formed (a non-negative integer),
but a rule with that ID does not exist.
</p>
<p><strong>Return value</strong>:
On success, returns the ID of the LHS symbol of the rule with ID <var>rule_id</var>
in grammar <var>g</var>.
A symbol ID is always a non-negative integer.
On soft failure, -1.
On hard failure, -2.
</p>
</dd></dl>

<a name="marpa_005fg_005frule_005fnew"></a><dl>
<dt><a name="index-marpa_005fg_005frule_005fnew"></a>Mutator function: <em>Marpa_Rule_ID</em> <strong>marpa_g_rule_new</strong> <em>(Marpa_Grammar <var>g</var>,     Marpa_Symbol_ID <var>lhs_id</var>,  Marpa_Symbol_ID *<var>rhs_ids</var>,      int <var>length</var>)</em></dt>
<dd>
<p><code>marpa_g_rule_new()</code> is one of the
<a name="index-rule-creation-methods"></a>
<em>rule creation methods</em>.
On success, the following are true:
</p><ul>
<li> This method creates a new BNF rule in grammar <var>g</var>.
</li><li> This method gives the new rule an ID.
</li><li> The ID of the new rule is a non-negative integer,
which is unique to that rule.
</li><li> If grammar <var>g</var> had no rules when
this method was called,
the new rule will have ID 0.
</li><li> If grammar <var>g</var> had one or more rules when
this method was called,
let <code><var>n</var></code> be the maximum rule ID
in grammar <var>g</var> when this method was called.
Then the new rule will have
rule ID <code><var>n</var>+1</code>.
</li><li> The ID of the LHS symbol of the new rule will be <var>lhs_id</var>.
</li><li> The length of the RHS of the new rule will be <var>length</var>.
</li><li> For <code>0 &lt;= i &lt; length</code>,
the ID of the RHS symbol with index <code>i</code> will be
<code>rhs_ids[i]</code>.
</li><li> The return value of this method is the ID of the new rule.
</li></ul>

<p>In addition to BNF rules, Marpa also allows sequence rules,
which are created by
the
<code>marpa_g_sequence_new()</code> method.
See <a href="#marpa_005fg_005fsequence_005fnew">marpa_g_sequence_new()</a>.
We call
<code>marpa_g_rule_new()</code> and
<code>marpa_g_sequence_new()</code>
<em>rule creation methods</em>.
Sequence rules and BNF rules are both rules:
They share the same series of rule IDs,
and are accessed and manipulated by the same methods,
with the only differences being as noted
in the descriptions of those methods.
</p>
<p>Each grammar&rsquo;s rule ID&rsquo;s are a consecutive sequence of non-negative integers,
starting at 0.
The consecutive numbering of rule ID&rsquo;s
is intended to make it convenient for applications to store additional information
about a grammar&rsquo;s rules in an array.
</p>
<p>Possible hard failures, with their error codes, include:
</p><ul>
<li> <code>MARPA_ERR_SEQUENCE_LHS_NOT_UNIQUE</code>: The LHS symbol is the same
as that of a sequence rule.
</li><li> <code>MARPA_ERR_DUPLICATE_RULE</code>: The new rule would duplicate another BNF
rule.
Another BNF rule is considered the duplicate of the new one,
if its LHS symbol is the same as symbol <var>lhs_id</var>,
if its length is the same as <var>length</var>,
and if its RHS symbols match one for one those
in the array of symbols <var>rhs_ids</var>.
</li></ul>

<p><strong>Return value</strong>:  On success, the ID of the new rule,
which is always a non-negative integer.
On hard failure, -2.
</p>
</dd></dl>

<a name="marpa_005fg_005frule_005frhs"></a><dl>
<dt><a name="index-marpa_005fg_005frule_005frhs"></a>Accessor function: <em>Marpa_Symbol_ID</em> <strong>marpa_g_rule_rhs</strong> <em>(     Marpa_Grammar <var>g</var>,     Marpa_Rule_ID <var>rule_id</var>,     int <var>ix</var>)</em></dt>
<dd>
<p>When successful, returns the ID of the symbol at index <var>ix</var>
in the RHS of the rule with ID <var>rule_id</var>.
The indexing of RHS symbols is zero-based.
</p>
<p>Soft fails iff <var>rule_id</var> is well-formed (a non-negative integer),
but a rule with that ID does not exist.
</p>
<p>Hard fails if <var>ix</var>
is not a valid index of the RHS.
This happens if <var>ix</var>
is less than zero,
or if <var>ix</var>  is greater than or equal to the length of
the rule.
</p>
<p><strong>Return value</strong>: On success, a symbol ID,
which is always non-negative.
On soft failure, -1.
On hard failure, -2.
</p>
</dd></dl>

<hr>
<a name="Sequence-methods"></a>
<div class="header">
<p>
Next: <a href="#Rank-methods" accesskey="n" rel="next">Rank methods</a>, Previous: <a href="#Rule-methods" accesskey="p" rel="prev">Rule methods</a>, Up: <a href="#Grammar-methods" accesskey="u" rel="up">Grammar methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sequence-methods-1"></a>
<h3 class="section">18.6 Sequence methods</h3>

<a name="marpa_005fg_005frule_005fis_005fproper_005fseparation"></a><dl>
<dt><a name="index-marpa_005fg_005frule_005fis_005fproper_005fseparation"></a>Accessor function: <em>int</em> <strong>marpa_g_rule_is_proper_separation</strong> <em>(     Marpa_Grammar <var>g</var>,     Marpa_Rule_ID <var>rule_id</var>)</em></dt>
<dd>
<p>When successful, returns
</p><ul>
<li> 1 if <var>rule_id</var> is the ID of a sequence rule whose
proper separation flag is set,
</li><li> 0 if <var>rule_id</var> is the ID of a sequence rule whose
proper separation flag is not set,
</li><li> 0 if <var>rule_id</var> is the ID of a rule that is not
a sequence rule.
</li></ul>
<p>Does not distinguish sequence rules without proper
separation from non-sequence rules.
That is,
does not distinguish an unset proper separation flag
from a
proper separation flag whose value is unspecified
because <var>rule_id</var> is the ID of a BNF rule.
Applications that want to determine whether
or not a rule is a sequence rule
can use
<code>marpa_g_sequence_min()</code> to do this.
See <a href="#marpa_005fg_005fsequence_005fmin">marpa_g_sequence_min()</a>.
</p>
<p>Soft fails iff <var>rule_id</var> is well-formed (a non-negative integer),
but a rule with that ID does not exist.
</p>
<p><strong>Return value</strong>:
On success, 1 or 0.
On soft failure, -1.
On hard failure, -2.
</p>
</dd></dl>

<a name="marpa_005fg_005fsequence_005fmin"></a><dl>
<dt><a name="index-marpa_005fg_005fsequence_005fmin"></a>Accessor function: <em>int</em> <strong>marpa_g_sequence_min</strong> <em>(     Marpa_Grammar <var>g</var>,     Marpa_Rule_ID <var>rule_id</var>)</em></dt>
<dd>
<p>On success, returns the mininum length of a sequence rule.
Soft fails iff a rule with ID <var>rule_id</var> exists,
but is not a sequence rule.
This soft failure can used to test whether
or not a rule is a sequence rule.
</p>
<p>Hard fails irrecoverably if
<var>rule_id</var> is not well-formed (a non-negative integer).
Also, hard fails irrecoverably if no rule with ID <var>rule_id</var> exists,
even when <var>rule_id</var> is well formed.
Note that,
in its handling of the non-existence of a rule for its rule
argument, this method differs from many of the other grammar
methods.
Grammar methods that take a rule ID argument
more often treat the
non-existence of rule for a well-formed
rule ID as a soft, recoverable, failure.
</p>
<p><strong>Return value</strong>:
On success, the minimum length of the sequence rule
with ID <var>rule_id</var>, which is always non-negative.
On soft failure, -1.
On hard failure, -2.
</p>
</dd></dl>

<a name="marpa_005fg_005fsequence_005fnew"></a><dl>
<dt><a name="index-marpa_005fg_005fsequence_005fnew"></a>Mutator function: <em>Marpa_Rule_ID</em> <strong>marpa_g_sequence_new</strong> <em>(Marpa_Grammar <var>g</var>,     Marpa_Symbol_ID <var>lhs_id</var>,  Marpa_Symbol_ID <var>rhs_id</var>,      Marpa_Symbol_ID <var>separator_id</var>,     int <var>min</var>,  int <var>flags</var> )</em></dt>
<dd>
<p><code>marpa_g_sequence_new()</code> is one of the
<a name="index-rule-creation-methods-1"></a>
<em>rule creation methods</em>.
On success, the following are true:
</p><ul>
<li> This method creates a new sequence rule in grammar <var>g</var>.
</li><li> This method gives the new rule an ID.
</li><li> The ID of the new rule is a non-negative integer,
which is unique to that rule.
</li><li> If grammar <var>g</var> had no rules when
this method was called,
the new rule will have ID 0.
</li><li> If grammar <var>g</var> had one or more rules when
this method was called,
let <code><var>n</var></code> be the maximum rule ID
in grammar <var>g</var> when this method was called.
Then the new rule will have
rule ID <code><var>n</var>+1</code>.
</li><li> The ID of the LHS symbol of the new rule will be <var>lhs_id</var>.
</li><li> The ID of the symbol to be repeated on the RHS of the sequence will be <var>rhs_id</var>.
It is a irrecoverable hard error if <var>rhs_id</var> is the ID of a nullable symbol.
</li><li> The sequence must be repeated at least <var>min</var> times.
<var>min</var> must be 0 or 1.
</li><li> If <var>separator_id</var> is a non-negative integer,
it is the ID of a separator symbol.
It is a irrecoverable hard error if <var>separator_id</var> is the ID of a nullable symbol.
</li><li> <var>flags</var> is treated as a bit vector.
The behavior when any bit other than <code>MARPA_PROPER_SEPARATION</code>
is set is undefined.
</li><li> By default, the sequence rule recognizes a trailing separator.
If <code>flags &amp; MARPA_PROPER_SEPARATION</code> is non-zero,
separation is &ldquo;proper&rdquo;.
Proper separation means the the rule does
not recognize a trailing separator.
Specifying proper separation has no effect if
a separator symbol has not been specified.
</li><li> The return value of this method is the ID of the new rule.
</li></ul>

<p>In addition to sequence rules, Marpa also allows BNF rules,
which are created by
the
<code>marpa_g_rule_new()</code> method.
See <a href="#marpa_005fg_005frule_005fnew">marpa_g_rule_new()</a>.
We call
<code>marpa_g_rule_new()</code> and
<code>marpa_g_sequence_new()</code>
<em>rule creation methods</em>.
For details on the use of sequence rules,
see <a href="#Sequence-rules">Sequence rules</a>.
</p>
<p>Sequence rules and BNF rules are both rules:
They share the same series of rule IDs,
and are accessed and manipulated by the same methods,
with the only differences being as noted
in the descriptions of those methods.
</p>
<p>Each grammar&rsquo;s rule ID&rsquo;s are a consecutive sequence of non-negative integers,
starting at 0.
The consecutive numbering of rule ID&rsquo;s
is intended to make it convenient for applications to store additional information
about a grammar&rsquo;s rules in an array.
</p>
<p>The LHS symbol cannot be the LHS of any other rule,
whether a BNF rule or a sequence rule.
On an attempt to create an sequence rule with a duplicate
LHS,
this method hard fails,
with an error code of
<code>MARPA_ERR_SEQUENCE_LHS_NOT_UNIQUE</code>.
</p>
<p><strong>Return value</strong>:  On success, the ID of the newly added
sequence rule, which is always non-negative.
On hard failure, -2.
</p>
</dd></dl>

<a name="marpa_005fg_005fsequence_005fseparator"></a><dl>
<dt><a name="index-marpa_005fg_005fsequence_005fseparator"></a>Accessor function: <em>int</em> <strong>marpa_g_sequence_separator</strong> <em>(     Marpa_Grammar <var>g</var>,     Marpa_Rule_ID <var>rule_id</var>)</em></dt>
<dd>
<p>On success, returns the symbol ID of the separator
of the sequence rule with ID <var>rule_id</var>.
Soft fails iff there is no separator.
Hard fails
if <var>rule_id</var> is a negative integer;
if <var>rule_id</var> is not the ID of a rule that exists; or
if <var>rule_id</var> is not the ID a sequence rule.
</p>
<p><strong>Return value</strong>:
On success, a symbol ID, which is always non-negative.
On soft failure, -1.
On hard failure, -2.
</p>
</dd></dl>

<a name="marpa_005fg_005fsymbol_005fis_005fcounted"></a><dl>
<dt><a name="index-marpa_005fg_005fsymbol_005fis_005fcounted"></a>Accessor function: <em>int</em> <strong>marpa_g_symbol_is_counted</strong> <em>(Marpa_Grammar <var>g</var>,     Marpa_Symbol_ID <var>sym_id</var>)</em></dt>
<dd>
<p>On success, returns a boolean whose value is
1 iff the symbol with
ID <var>sym_id</var> is counted.
A symbol is
<a name="index-counted-symbol"></a>
<a name="index-symbol_002c-counted"></a>
<em>counted</em>
iff
</p><ul>
<li> it appears on the RHS of a sequence rule, or
</li><li> it is used as the separator symbol of a sequence rule.
</li></ul>

<p>Soft fails iff <var>sym_id</var> is well-formed (a non-negative integer),
but a symbol with that ID does not exist.
</p>
<p><strong>Return value</strong>:
On success, a boolean.
On soft failure, -1.
On hard failure, -2.
</p>
</dd></dl>

<hr>
<a name="Rank-methods"></a>
<div class="header">
<p>
Next: <a href="#Grammar-precomputation" accesskey="n" rel="next">Grammar precomputation</a>, Previous: <a href="#Sequence-methods" accesskey="p" rel="prev">Sequence methods</a>, Up: <a href="#Grammar-methods" accesskey="u" rel="up">Grammar methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Rank-methods-1"></a>
<h3 class="section">18.7 Rank methods</h3>

<a name="marpa_005fg_005fdefault_005frank"></a><dl>
<dt><a name="index-marpa_005fg_005fdefault_005frank"></a>Accessor function: <em>Marpa_Rank</em> <strong>marpa_g_default_rank</strong> <em>(     Marpa_Grammar <var>g</var>)</em></dt>
<dd>
<p>On success, returns the default rank of the grammar <var>g</var>.
For more about the default rank of a grammar,
see <a href="#marpa_005fg_005fdefault_005frank_005fset">marpa_g_default_rank_set()</a>.
</p>
<p><strong>Return value</strong>: On success, returns
the default rank of the grammar,
which will be an integer,
and sets the error code to
<code>MARPA_ERR_NONE</code>.
On hard failure, returns -2,
and sets the error code to an appropriate
value, which will never be
<code>MARPA_ERR_NONE</code>.
Note that when
the default rank of the grammar is -2,
the error code is the only way to distinguish
success from failure.
The error code can be determined by using the
<code>marpa_g_error()</code>
call.
See <a href="#marpa_005fg_005ferror">marpa_g_error()</a>.
</p>
</dd></dl>

<a name="marpa_005fg_005fdefault_005frank_005fset"></a><dl>
<dt><a name="index-marpa_005fg_005fdefault_005frank_005fset"></a>Mutator function: <em>Marpa_Rank</em> <strong>marpa_g_default_rank_set</strong> <em>(     Marpa_Grammar <var>g</var>,     Marpa_Rank <var>rank</var>)</em></dt>
<dd>
<p>On success, sets the default rank of the grammar <var>g</var> to <var>rank</var>.
When a grammar is created, the default rank is 0.
When rules and symbols are created, their rank is
the default rank of the grammar.
</p>
<p>Changing the grammar&rsquo;s default rank does not affect
those
rules and symbols already created,
only those that will be created.
This means that
the grammar&rsquo;s default rank can be used to,
in effect, assign ranks to groups of rules and symbols.
Applications may find this behavior useful.
</p>
<p><strong>Return value</strong>: On success, returns <var>rank</var>,
which will be an integer,
and sets the error code to
<code>MARPA_ERR_NONE</code>.
On failure, returns -2,
and sets the error code to an appropriate
value, which will never be
<code>MARPA_ERR_NONE</code>.
Note that when the <var>rank</var> is -2,
the error code is the only way to distinguish
success from failure.
The error code can be determined by using the
<code>marpa_g_error()</code>
call.
See <a href="#marpa_005fg_005ferror">marpa_g_error()</a>.
</p>
</dd></dl>

<a name="marpa_005fg_005fsymbol_005frank"></a><dl>
<dt><a name="index-marpa_005fg_005fsymbol_005frank"></a>Accessor function: <em>Marpa_Rank</em> <strong>marpa_g_symbol_rank</strong> <em>(     Marpa_Grammar <var>g</var>,     Marpa_Symbol_ID <var>sym_id</var>)</em></dt>
<dd>
<p>When successful, returns
the rank of the symbol with ID <var>sym_id</var>.
</p>
<p><strong>Return value</strong>:
On success, returns a symbol rank,
which will be an integer,
and sets the error code to
<code>MARPA_ERR_NONE</code>.
On hard failure, returns -2,
and sets the error code to an appropriate
value, which will never be
<code>MARPA_ERR_NONE</code>.
Note that -2 is a valid symbol rank,
so that when -2 is returned,
the error code is the only way to distinguish
success from failure.
The error code can be determined using
<code>marpa_g_error()</code>.
See <a href="#marpa_005fg_005ferror">marpa_g_error()</a>.
</p>
</dd></dl>

<a name="marpa_005fg_005fsymbol_005frank_005fset"></a><dl>
<dt><a name="index-marpa_005fg_005fsymbol_005frank_005fset"></a>Mutator function: <em>Marpa_Rank</em> <strong>marpa_g_symbol_rank_set</strong> <em>(     Marpa_Grammar <var>g</var>,     Marpa_Symbol_ID <var>sym_id</var>,     Marpa_Rank <var>rank</var>)</em></dt>
<dd>
<p>When successful,
sets
the rank of the symbol with ID <var>sym_id</var> to <var>rank</var>.
</p>
<p><strong>Return value</strong>:
On success, returns <var>rank</var>,
which will be an integer,
and sets the error code to
<code>MARPA_ERR_NONE</code>.
On hard failure, returns -2,
and sets the error code to an appropriate
value, which will never be
<code>MARPA_ERR_NONE</code>.
Note that <var>rank</var> may be -2,
and in this case
the error code is the only way to distinguish
success from failure.
The error code can be determined using
<code>marpa_g_error()</code>.
See <a href="#marpa_005fg_005ferror">marpa_g_error()</a>.
</p></dd></dl>

<a name="marpa_005fg_005frule_005frank"></a><dl>
<dt><a name="index-marpa_005fg_005frule_005frank"></a>Accessor function: <em>Marpa_Rank</em> <strong>marpa_g_rule_rank</strong> <em>(     Marpa_Grammar <var>g</var>,     Marpa_Rule_ID rule_id)</em></dt>
<dd>
<p>When successful, returns
the rank of the rule with ID <var>rule_id</var>.
</p>
<p><strong>Return value</strong>:
On success, returns a rule rank,
which will be an integer,
and sets the error code to
<code>MARPA_ERR_NONE</code>.
On hard failure, returns -2,
and sets the error code to an appropriate
value, which will never be
<code>MARPA_ERR_NONE</code>.
Note that -2 is a valid rule rank,
so that when -2 is returned,
the error code is the only way to distinguish
success from failure.
The error code can be determined using
<code>marpa_g_error()</code>.
See <a href="#marpa_005fg_005ferror">marpa_g_error()</a>.
</p>
</dd></dl>

<a name="marpa_005fg_005frule_005frank_005fset"></a><dl>
<dt><a name="index-marpa_005fg_005frule_005frank_005fset"></a>Mutator function: <em>Marpa_Rank</em> <strong>marpa_g_rule_rank_set</strong> <em>(     Marpa_Grammar <var>g</var>,     Marpa_Rule_ID <var>rule_id</var>,     Marpa_Rank <var>rank</var>)</em></dt>
<dd>
<p>When successful,
sets
the rank of the rule with ID <var>rule_id</var> to <var>rank</var>.
</p>
<p><strong>Return value</strong>:
On success, returns <var>rank</var>,
which will be an integer,
and sets the error code to
<code>MARPA_ERR_NONE</code>.
On hard failure, returns -2,
and sets the error code to an appropriate
value, which will never be
<code>MARPA_ERR_NONE</code>.
Note that -2 is a valid rule rank,
so that when -2 is returned,
the error code is the only way to distinguish
success from failure.
The error code can be determined using
<code>marpa_g_error()</code>.
See <a href="#marpa_005fg_005ferror">marpa_g_error()</a>.
</p>
</dd></dl>

<a name="marpa_005fg_005frule_005fnull_005fhigh"></a><dl>
<dt><a name="index-marpa_005fg_005frule_005fnull_005fhigh"></a>Accessor function: <em>int</em> <strong>marpa_g_rule_null_high</strong> <em>(     Marpa_Grammar <var>g</var>,     Marpa_Rule_ID rule_id)</em></dt>
<dd>
<p>On success, returns a boolean whose value is 1
iff &ldquo;null ranks high&rdquo; is set in the rule with ID <var>rule_id</var>.
When a rule is created, it has &ldquo;null ranks high&rdquo; set.
</p>
<p>For more on the
&ldquo;null ranks high&rdquo; setting, read the description of
<code>marpa_g_rule_null_high_set()</code>.
See <a href="#marpa_005fg_005frule_005fnull_005fhigh_005fset">marpa_g_rule_null_high_set()</a>.
</p>
<p>Soft fails iff <var>rule_id</var> is well-formed (a non-negative integer),
but a rule with that ID does not exist.
</p>
<p><strong>Return value</strong>:
On success, returns a boolean.
On soft failure, returns -1.
On hard failure, returns -2.
</p>
</dd></dl>

<a name="marpa_005fg_005frule_005fnull_005fhigh_005fset"></a><dl>
<dt><a name="index-marpa_005fg_005frule_005fnull_005fhigh_005fset"></a>Mutator function: <em>int</em> <strong>marpa_g_rule_null_high_set</strong> <em>(     Marpa_Grammar <var>g</var>,     Marpa_Rule_ID <var>rule_id</var>,     int <var>flag</var>)</em></dt>
<dd>
<p>On success,
</p><ul>
<li> sets &ldquo;null ranks high&rdquo; in the rule with ID <var>rule_id</var> if the value
of the boolean <var>flag</var> is 1;
</li><li> unsets &ldquo;null ranks high&rdquo; in the rule with ID <var>rule_id</var> if the value
of the boolean <var>flag</var> is 0; and
</li><li> returns <var>flag</var>.
</li></ul>

<p>The &ldquo;null ranks high&rdquo; setting affects the ranking of rules
with properly nullable symbols on their right hand side.
If a rule has properly nullable symbols on its RHS,
each instance in which it appears in a parse will have a pattern
of nulled and non-nulled symbols.
Such a pattern is called a &ldquo;null variant&rdquo;.
</p>
<p>If the &ldquo;null ranks high&rdquo; is set,
nulled symbols rank high.
If the &ldquo;null ranks high&rdquo; is unset (the default),
nulled symbols rank low.
Ranking of a null variants is done from left-to-right.
</p>
<p>Soft fails iff <var>rule_id</var> is well-formed (a non-negative integer),
but a rule with that ID does not exist.
</p>
<p>Hard fails if
the grammar has been precomputed.
</p>
<p><strong>Return value</strong>:
On success, returns a boolean.
On soft failure, returns -1.
On hard failure, returns -2.
</p>
</dd></dl>

<hr>
<a name="Grammar-precomputation"></a>
<div class="header">
<p>
Previous: <a href="#Rank-methods" accesskey="p" rel="prev">Rank methods</a>, Up: <a href="#Grammar-methods" accesskey="u" rel="up">Grammar methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Precomputing-the-Grammar"></a>
<h3 class="section">18.8 Precomputing the Grammar</h3>

<a name="marpa_005fg_005fhas_005fcycle"></a><dl>
<dt><a name="index-marpa_005fg_005fhas_005fcycle"></a>Accessor function: <em>int</em> <strong>marpa_g_has_cycle</strong> <em>(Marpa_Grammar <var>g</var>)</em></dt>
<dd>
<p>On success, returns a boolean which is 1 iff
<var>g</var> has a cycle.
Parsing with a grammar that contains a cycle is deprecated.
See <a href="#Cycles">Cycles</a>.
</p>
<p>For diagnostic purposes,
it is useful to determine which rules are in the cycle.
<code>marpa_g_rule_is_loop()</code> can be used for for this purpose.
See <a href="#marpa_005fg_005frule_005fis_005floop">marpa_g_rule_is_loop</a>.
</p>
<p><strong>Return value</strong>: On success, a boolean.
On hard failure, -2.
</p>
</dd></dl>

<a name="marpa_005fg_005fis_005fprecomputed"></a><dl>
<dt><a name="index-marpa_005fg_005fis_005fprecomputed"></a>Accessor function: <em>int</em> <strong>marpa_g_is_precomputed</strong> <em>(Marpa_Grammar <var>g</var>)</em></dt>
<dd>
<p><strong>Return value</strong>: On success, a boolean which is 1 iff
grammar <var>g</var> is precomputed.
On hard failure, -2.
</p>
</dd></dl>

<a name="marpa_005fg_005fprecompute"></a><dl>
<dt><a name="index-marpa_005fg_005fprecompute"></a>Mutator function: <em>int</em> <strong>marpa_g_precompute</strong> <em>(Marpa_Grammar <var>g</var>)</em></dt>
<dd>
<p>Precomputation involves running a series of grammar checks
and &ldquo;precomputing&rdquo; some useful information which is kept
internally to save repeated calculations.
After precomputation, the grammar is &ldquo;frozen&rdquo; in many respects,
and many grammar mutators that succeed before precomputation
will cause hard failures after precomputation.
Precomputation is necessary for a recognizer to be generated
from a grammar.
</p>
<p>On success,
and on fully recoverable hard failure,
does the following:
</p><ul>
<li> Precomputes the grammar <var>g</var>.
</li><li> Clears any events that were in the event queue
at the beginning of this method call.
</li><li> Returns zero or more events.
</li><li> Returns a value as described in this method&rsquo;s
return value summary.
</li></ul>

<p>The types of event that this method may return
are
<code>MARPA_EVENT_LOOP_RULES</code>,
<code>MARPA_EVENT_COUNTED_NULLABLE</code>, and
<code>MARPA_EVENT_NULLING_TERMINAL</code>.
All of these events occur only on failure.
Events may be queried using the
<code>marpa_g_event()</code> method.
See <a href="#marpa_005fg_005fevent">marpa_g_event()</a>.
</p>
<p>The fully recoverable hard failure is
<code>MARPA_ERR_GRAMMAR_HAS_CYCLE</code>.
While this method precomputes the grammar
for fully recoverable hard failures,
parsing with a grammar that has a cycle is deprecated.
Applications should treat
<code>MARPA_ERR_GRAMMAR_HAS_CYCLE</code>
as a library-recoverable error.
A <code>MARPA_ERR_GRAMMAR_HAS_CYCLE</code> error occurs
iff
at least one <code>MARPA_EVENT_LOOP_RULES</code> event occurs.
For more details on cycles,
see <a href="#Cycles">Cycles</a>.
</p>
<p>The error code <code>MARPA_ERR_COUNTED_NULLABLE</code>
is library-recoverable.
This failure occurs when a symbol on the RHS of a sequence rule is
nullable,
which Libmarpa does not allow in a grammar.
Error code <code>MARPA_ERR_COUNTED_NULLABLE</code> occurs iff
one or more <code>MARPA_EVENT_COUNTED_NULLABLE</code> events occur.
There is one <code>MARPA_EVENT_COUNTED_NULLABLE</code> event for every symbol
that is a nullable on the right hand side of a sequence
rule.
An application may use these events to inform the user
of the problematic symbols,
and this detail may help the user fix the grammar.
</p>
<p>The error code <code>MARPA_ERR_NULLING_TERMINAL</code>
occurs only if LHS terminals are enabled.
The LHS terminals feature is deprecated.
See <a href="#LHS-terminals">LHS terminals</a>.
Error code <code>MARPA_ERR_NULLING_TERMINAL</code>
is library-recoverable.
One or more <code>MARPA_EVENT_NULLING_TERMINAL</code> events will occur iff
this method fails with error code <code>MARPA_ERR_NULLING_TERMINAL</code>.
See <a href="#Nulling-terminals">Nulling terminals</a>.
</p>
<p>Among the other error codes that may case this
method to fail
are the following:
</p>
<ul>
<li> <code>MARPA_ERR_NO_RULES</code>: The grammar has no rules.
</li><li> <code>MARPA_ERR_NO_START_SYMBOL</code>: No start symbol was specified.
</li><li> <code>MARPA_ERR_INVALID_START_SYMBOL</code>: A start symbol ID was specified, but it
is not the ID of a valid symbol.
</li><li> <code>MARPA_ERR_START_NOT_LHS</code>: The start symbol is not on the LHS of any rule.
</li><li> <code>MARPA_ERR_UNPRODUCTIVE_START</code>: The start symbol is not productive.
</li></ul>

<p>More details of these can be found under the
description of the appropriate code.
See <a href="#External-error-codes">External error codes</a>.
</p>
<p><strong>Return value</strong>: On success, a non-negative integer,
whose value is otherwise unspecified.
On hard failure, -2.
For the error code <code>MARPA_ERR_GRAMMAR_HAS_CYCLE</code>,
the hard failure is fully recoverable.
For the error codes <code>MARPA_ERR_COUNTED_NULLABLE</code>
and <code>MARPA_ERR_NULLING_TERMINAL</code>,
the hard failure is library-recoverable.
</p>
</dd></dl>

<hr>
<a name="Recognizer-methods"></a>
<div class="header">
<p>
Next: <a href="#Progress-reports" accesskey="n" rel="next">Progress reports</a>, Previous: <a href="#Grammar-methods" accesskey="p" rel="prev">Grammar methods</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Recognizer-methods-1"></a>
<h2 class="chapter">19 Recognizer methods</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Recognizer-overview" accesskey="1">Recognizer overview</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Creating-a-new-recognizer" accesskey="2">Creating a new recognizer</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Recognizer-reference-counting" accesskey="3">Recognizer reference counting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Recognizer-life-cycle-mutators" accesskey="4">Recognizer life cycle mutators</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Location-accessors" accesskey="5">Location accessors</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Other-parse-status-methods" accesskey="6">Other parse status methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Recognizer-overview"></a>
<div class="header">
<p>
Next: <a href="#Creating-a-new-recognizer" accesskey="n" rel="next">Creating a new recognizer</a>, Previous: <a href="#Recognizer-methods" accesskey="p" rel="prev">Recognizer methods</a>, Up: <a href="#Recognizer-methods" accesskey="u" rel="up">Recognizer methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Recognizer-overview-1"></a>
<h3 class="section">19.1 Recognizer overview</h3>

<p>An archetypal application uses a recognizer to read input.
To create a recognizer, use the
<code>marpa_r_new()</code>
method.
When a recognizer is no longer in use, its memory can be freed
using the
<code>marpa_r_unref()</code>
method.
</p>
<p>To make a recognizer ready for input,
use the
<code>marpa_r_start_input()</code>
method.
</p>
<p>The recognizer starts with its current earleme
at location 0.
To read a token at the current earleme,
use the
<code>marpa_r_alternative()</code>
call.
</p>
<p>To complete the processing of the current earleme,
and move forward to a new one,
use the
<code>marpa_r_earleme_complete()</code>
call.
</p>
<hr>
<a name="Creating-a-new-recognizer"></a>
<div class="header">
<p>
Next: <a href="#Recognizer-reference-counting" accesskey="n" rel="next">Recognizer reference counting</a>, Previous: <a href="#Recognizer-overview" accesskey="p" rel="prev">Recognizer overview</a>, Up: <a href="#Recognizer-methods" accesskey="u" rel="up">Recognizer methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Creating-a-new-recognizer-1"></a>
<h3 class="section">19.2 Creating a new recognizer</h3>

<a name="marpa_005fr_005fnew"></a><dl>
<dt><a name="index-marpa_005fr_005fnew"></a>Constructor function: <em>Marpa_Recognizer</em> <strong>marpa_r_new</strong> <em>( Marpa_Grammar <var>g</var> )</em></dt>
<dd>
<p>On success, creates a new recognizer and
increments the reference count of <var>g</var>,
the base grammar, by one.
In the new recognizer, the following will be true:
</p><ul>
<li> The reference count will be 1.
</li><li> The furthest earleme will be 0.
</li><li> The values of the latest and current earleme will be unspecified.
</li><li> The declaration status of all events will be inherited from
<var>g</var>, so that the event in the recognizer is declared iff
the event in <var>g</var> is declared.
</li><li> The activation status of all events will be inherited from
<var>g</var>, so that the event in the recognizer is activated iff
the event in <var>g</var> is activated.
</li></ul>

<p><strong>Return value</strong>:
On success, the newly created recognizer, which is never <code>NULL</code>.
If <var>g</var> is not precomputed, or on other hard failure, <code>NULL</code>.
</p></dd></dl>

<hr>
<a name="Recognizer-reference-counting"></a>
<div class="header">
<p>
Next: <a href="#Recognizer-life-cycle-mutators" accesskey="n" rel="next">Recognizer life cycle mutators</a>, Previous: <a href="#Creating-a-new-recognizer" accesskey="p" rel="prev">Creating a new recognizer</a>, Up: <a href="#Recognizer-methods" accesskey="u" rel="up">Recognizer methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Keeping-the-reference-count-of-a-recognizer"></a>
<h3 class="section">19.3 Keeping the reference count of a recognizer</h3>

<a name="marpa_005fr_005fref"></a><dl>
<dt><a name="index-marpa_005fr_005fref"></a>Mutator function: <em>Marpa_Recognizer</em> <strong>marpa_r_ref</strong> <em>(Marpa_Recognizer <var>r</var>)</em></dt>
<dd>

<p>Increases the reference count by 1.
This method is not needed by most applications.
</p>
<p><strong>Return value</strong>:
On success, the recognizer object, <var>r</var>, which is never <code>NULL</code>.
On hard failure, <code>NULL</code>.
</p>
</dd></dl>

<a name="marpa_005fr_005funref"></a><dl>
<dt><a name="index-marpa_005fr_005funref"></a>Destructor function: <em>void</em> <strong>marpa_r_unref</strong> <em>(Marpa_Recognizer <var>r</var>)</em></dt>
<dd>
<p>Decreases the reference count by 1,
destroying <var>r</var> once the reference count reaches
zero.
When <var>r</var> is destroyed, the reference count
of its base grammar is decreased by one.
If this takes the reference count of the base grammar
to zero, the base grammar is also destroyed.
</p>
</dd></dl>

<hr>
<a name="Recognizer-life-cycle-mutators"></a>
<div class="header">
<p>
Next: <a href="#Location-accessors" accesskey="n" rel="next">Location accessors</a>, Previous: <a href="#Recognizer-reference-counting" accesskey="p" rel="prev">Recognizer reference counting</a>, Up: <a href="#Recognizer-methods" accesskey="u" rel="up">Recognizer methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Life-cycle-mutators"></a>
<h3 class="section">19.4 Life cycle mutators</h3>

<a name="marpa_005fr_005fstart_005finput"></a><dl>
<dt><a name="index-marpa_005fr_005fstart_005finput"></a>Mutator function: <em>int</em> <strong>marpa_r_start_input</strong> <em>(Marpa_Recognizer <var>r</var>)</em></dt>
<dd>
<p>When successful, does the following:
</p><ul>
<li> Readies <var>r</var> to accept input.
</li><li> Completes the first Earley set.
The ID of the first Earley set is 0,
and it is located at earleme 0.
</li><li> Leaves the latest, current and furthest earlemes all at 0.
</li><li> Clears any events that were in the event queue before this method was called.
</li><li> If this method exhausts the parse, triggers a <code>MARPA_EVENT_EXHAUSTED</code> event.
    See <a href="#Exhaustion">Exhaustion</a>.
</li><li> May trigger one or more <code>MARPA_EVENT_SYMBOL_NULLED</code>,
    <code>MARPA_EVENT_SYMBOL_PREDICTED</code>, or <code>MARPA_EVENT_SYMBOL_EXPECTED</code> events.
    See <a href="#Events">Events</a>.
</li></ul>

<p><strong>Return value</strong>:  On success, a non-negative value,
whose value is otherwise unspecified.
On hard failure, -2.
</p>
</dd></dl>

<a name="marpa_005fr_005falternative"></a><dl>
<dt><a name="index-marpa_005fr_005falternative"></a>Mutator function: <em>int</em> <strong>marpa_r_alternative</strong> <em>(Marpa_Recognizer <var>r</var>,     Marpa_Symbol_ID <var>token_id</var>,     int <var>value</var>,     int <var>length</var>)</em></dt>
<dd>

<p>The <var>token_id</var> argument must be the symbol ID of a terminal.
The <var>value</var> argument is an
integer that represents the &ldquo;value&rdquo; of the
token, and which should not be zero.
The <var>length</var> argument is the length of the token, which must
be greater than zero.
</p>
<p>On success, does the following,
where <code>current</code> is the value of the current earleme
before the call and
<code>furthest</code> is the value of the furthest earleme
before the call:
</p><ul>
<li> Reads a new token into <var>r</var>.
The symbol ID of the token will be
<var>token_id</var>.
The token will start at <code>current</code>
and end at <code><var>current</var>+<var>length</var></code>.
</li><li> Sets the value of the furthest earleme to
<code>max(<var>current</var>+<var>length</var>,<var>furthest</var>)</code>.
</li><li> Leaves
the values of the latest and current earlemes unchanged.
</li></ul>

<p>After recoverable failure, the following are the case:
</p><ul>
<li> The tokens read into <var>r</var> are unchanged.
Specifically, no new token has been read into <var>r</var>.
</li><li> The values of the latest, current and furthest earlemes
are unchanged.
</li></ul>

<p>Libmarpa allows tokens to be ambiguous.
Two tokens are ambiguous if they end at the same earleme location.
If two tokens are ambiguous, Libmarpa will attempt to produce all the parses
that include either of them.
</p>
<p>Libmarpa allows tokens to overlap.
Let the notation
<var>t</var>@<var>s</var>-<var>e</var> indicate that token <var>t</var> starts
at earleme <var>s</var> and ends at earleme <var>e</var>.
Let <var>t1</var>@<var>s1</var>-<var>e1</var>
and <var>t2</var>@<var>s2</var>-<var>e2</var>
be two tokens such that <var>s1</var>&lt;=<var>s2</var>.
We say that <var>t1</var> and <var>t2</var> overlap iff
<var>e1</var>&gt;<var>s2</var>.
</p>
<p>The <var>value</var> argument
is not used inside Libmarpa &mdash; it is simply
stored to be returned by the valuator
as a convenience for the application.
In applications where the token&rsquo;s actual value is not an integer, it is
expected that the application will use <var>value</var> as
a &ldquo;virtual&rdquo; value,
perhaps finding the actual value by using <var>value</var>
to index an array.
Some applications may prefer to track token values on
their own, perhaps based on
the earleme location and <var>token_id</var>,
instead of using Libmarpa&rsquo;s token values.
</p>
<p>A <var>value</var> of 0 does not cause a failure,
but it is reserved for unvalued symbols,
a now-deprecated feature.
See <a href="#Valued-and-unvalued-symbols">Valued and unvalued symbols</a>.
</p>
<p>Hard fails irrecoverably with <code>MARPA_ERR_DUPLICATE_TOKEN</code>
if the token added would be a duplicate.
Two tokens are duplicates iff all of the following are true:
</p><ul>
<li> They would have the same start earleme.
In other words, if <code>marpa_r_alternative()</code> attempts
to read them while at the same current earleme.
</li><li> They have the same <var>token_id</var>.
</li><li> They have the same <var>length</var>.
</li></ul>

<a name="Ruby-Slippers"></a><p>If a token was not accepted
because of its token ID,
hard fails with the <code>MARPA_ERR_UNEXPECTED_TOKEN_ID</code>.
This hard failure is fully recoverable
so that, for example,
the application may
retry this method with different token IDs
until it succeeds.
These retries are efficient,
and are quite useable as a parsing
technique &mdash;
so much so we have given the technique a name:
<a name="index-Ruby-Slippers"></a>
<em>the Ruby Slippers</em>.
The Ruby Slippers are used in several
applications.
</p>
<p><strong>Return value</strong>:  On success, <code>MARPA_ERR_NONE</code>.
On hard failure, an error code other than <code>MARPA_ERR_NONE</code>.
The hard failure for <code>MARPA_ERR_UNEXPECTED_TOKEN_ID</code>
is fully recoverable.
</p>
</dd></dl>

<a name="marpa_005fr_005fearleme_005fcomplete"></a><dl>
<dt><a name="index-marpa_005fr_005fearleme_005fcomplete"></a>Mutator function: <em>int</em> <strong>marpa_r_earleme_complete</strong> <em>(Marpa_Recognizer <var>r</var>)</em></dt>
<dd>
<p>For the purposes of this method description, we define the following:
</p><ul>
<li> <code>current</code> is the value of the current earleme before the call of
<code>marpa_r_earleme_complete</code>.
</li><li> <code>latest</code> is the value of the latest earleme before the call of
<code>marpa_r_earleme_complete</code>.
</li><li> An &ldquo;expected&rdquo; terminal is one expected at a current earleme,
in the same sense that
<code>marpa_r_terminal_is_expected()</code> determines if a terminal is &ldquo;expected&rdquo;
at the current earleme.
See <a href="#marpa_005fr_005fterminals_005fexpected">marpa_r_terminals_expected()</a>.
</li><li> An &ldquo;anticipated&rdquo; terminal is one
that was accepted by
the <code>marpa_r_alternative()</code> to end at an earleme after the current
earleme.
An anticipated terminal will have length greater than one.
&ldquo;Anticipated&rdquo; terminals only occur if the application is using
an advanced model of input.
See <a href="#Advanced-input-models">Advanced input models</a>.
</li></ul>

<p>In this method description,
we will frequently refer to parse exhaustion.
Parse exhaustion is discussed in detail in its own section.
See <a href="#Exhaustion">Exhaustion</a>.
</p>
<p>On success, does the final processing for the current earleme, including
the following:
</p><ul>
<li> Advances the current earleme,
incrementing its value by 1.
That is, sets the current earleme to <code>current+1</code>.
</li><li> If any token was accepted at <code>current</code>,
creates a new Earley set,
which will be the latest Earley set.
After the call, the latest
earleme will be equal to the new current earleme,
<code>current+1</code>.
</li><li> If no token was accepted at <code>current</code>,
    no Earley set is created.
    After the call,
    the value of the latest earleme will be unchanged &mdash;
    that is, it will remain at <code>latest</code>.
    Success when no tokens were accepted at <code>current</code>
    can only occur if the application is using an advanced model of input.
    See <a href="#Advanced-input-models">Advanced input models</a>.
</li><li> The value of the furthest earleme is never changed by
a call to
<code>marpa_r_earleme_complete()</code>.
</li><li> Clears the event queue of any events that
occured before this method was called.
</li><li> May trigger one or more <code>MARPA_EVENT_SYMBOL_COMPLETED</code>,
    <code>MARPA_EVENT_SYMBOL_NULLED</code>, <code>MARPA_EVENT_SYMBOL_PREDICTED</code>,
    or <code>MARPA_EVENT_SYMBOL_EXPECTED</code> events.
    See <a href="#Events">Events</a>.
</li><li> If an application-settable threshold
on the number of Earley items has been reached or exceeded,
triggers a <code>MARPA_EVENT_EARLEY_ITEM_THRESHOLD</code> event.
Often, the application will want to treat this event
as if it were a ancestry-recoverable
failure.
See <a href="#marpa_005fr_005fearley_005fitem_005fwarning_005fthreshold_005fset">marpa_r_earley_item_warning_threshold_set()</a>.
</li><li> If the parse is exhausted,
triggers a
<code>MARPA_EVENT_EXHAUSTED</code> event.
Exhaustion on success only occurs if no terminals
are expected at the current earleme after
the call to this method
(that is, at <code>current+1</code>)
and no terminals are anticipated
after <code>current+1</code>.
</li></ul>

<p>On hard failure
with the code <code>MARPA_ERR_PARSE_EXHAUSTED</code>, does the following:
</p><ul>
<li> Leaves the current earleme at <code>current</code>.
The current earleme will be the same as the furthest earleme.
</li><li> The value of the furthest earleme is never changed by
a call to
<code>marpa_r_earleme_complete()</code>.
</li><li> Leaves the value of the latest earleme at <code>latest</code>.
No new Earley set is created.
</li><li> Sets the parse exhausted, so that no more tokens
will be accepted.
</li><li> Leaves the parse in a state where no terminals
are expected or anticipated.
</li><li> Clears the event queue of any events that
occured before the call to this method.
</li><li> Triggers a
<code>MARPA_EVENT_EXHAUSTED</code> event and no others.
</li><li> Leaves valid any parses that were valid at
the current or earlier earlemes.
Processing with these can continue,
and it for this reason that we consider
hard failures with the code <code>MARPA_ERR_PARSE_EXHAUSTED</code>
to be fully recoverable.
</li></ul>

<p>We note that exhaustion can occur when this method fails
and when it succeeds.
The distinction is that, on success, the call creates a new Earley set before
becoming exhausted while,
on failure, it becomes exhausted without creating a new Earley set.
</p>
<p>This method is commonly called at the top of a loop.
Almost all applications will want to check the return value
and take special action in case of a value other than zero.
If the value is greater than zero, an event will have occurred
and almost all applications
should react to <code>MARPA_EVENT_EARLEY_ITEM_THRESHOLD</code> events,
as described above,
and to unexpected events.
If the value is less than zero,
it may be due to an irrecoverable error,
and only in very unusual circumstances will an application wish
to ignore these.
</p>
<p>How an application reacts to exhaustion will depend on the kind of
parsing it is doing.
See <a href="#Exhaustion">Exhaustion</a>.
</p>
<p>It is often up to
the logic immediately around this method
to detect EOP.
See <a href="#End-of-parse">End of parse</a>.
</p>
<p><strong>Return value</strong>:  On success, the number of events
in the event queue when the method call returns.
On hard failure, -2.
Hard failure with the code
<code>MARPA_ERR_PARSE_EXHAUSTED</code>
is fully recoverable.
</p></dd></dl>

<hr>
<a name="Location-accessors"></a>
<div class="header">
<p>
Next: <a href="#Other-parse-status-methods" accesskey="n" rel="next">Other parse status methods</a>, Previous: <a href="#Recognizer-life-cycle-mutators" accesskey="p" rel="prev">Recognizer life cycle mutators</a>, Up: <a href="#Recognizer-methods" accesskey="u" rel="up">Recognizer methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Location-accessors-1"></a>
<h3 class="section">19.5 Location accessors</h3>

<a name="marpa_005fr_005fcurrent_005fearleme"></a><dl>
<dt><a name="index-marpa_005fr_005fcurrent_005fearleme"></a>Accessor function: <em><code>Marpa_Earleme</code></em> <strong>marpa_r_current_earleme</strong> <em>(Marpa_Recognizer <var>r</var>)</em></dt>
<dd>
<p>Successful iff input has started.
If input has not started, returns soft failure.
</p>
<p><strong>Return value</strong>:
On success, the current earleme, which is always non-negative.
On soft failure, -1.
Never returns a hard failure.
</p></dd></dl>

<a name="marpa_005fr_005fearleme"></a><dl>
<dt><a name="index-marpa_005fr_005fearleme"></a>Accessor function: <em>Marpa_Earleme</em> <strong>marpa_r_earleme</strong> <em>(     Marpa_Recognizer <var>r</var>,     Marpa_Earley_Set_ID <var>set_id</var>)</em></dt>
<dd>
<p>On success, returns the earleme of the Earley set with ID <code>set_id</code>.
The ID of an Earley set ID is also called its ordinal.
In the default, token-stream model, Earley set ID and earleme
are always equal, but this is not the case in other input
models.
</p>
<p>Hard fails if there is no Earley set whose ID is
<var>set_id</var>.
This hard failure is fully recoverable.
If <var>set_id</var> was negative,
the error code of the hard failure is
<code>MARPA_ERR_INVALID_LOCATION</code>.
If <var>set_id</var> is greater than the ordinal
of the latest Earley set,
the error code of the hard failure is
<code>MARPA_ERR_NO_EARLEY_SET_AT_LOCATION</code>.
</p>
<p>Techniques for performing
the inverse operation (conversion of an earleme to an Earley set
ID)
are described in the section on advanced input models.
See <a href="#Converting-earleme-to-Earley-set-ID">Converting earleme to Earley set ID</a>.
</p>
<p><strong>Return value</strong>:
On success, the earleme corresponding to Earley
set <var>set_id</var>,
which is always non-negative.
On hard failure, -2.
The hard failures with error codes
<code>MARPA_ERR_INVALID_LOCATION</code> and
<code>MARPA_ERR_NO_EARLEY_SET_AT_LOCATION</code>
are fully recoverable.
</p>
</dd></dl>

<a name="marpa_005fr_005fearley_005fset_005fvalue"></a><dl>
<dt><a name="index-marpa_005fr_005fearley_005fset_005fvalue"></a>Accessor function: <em>int</em> <strong>marpa_r_earley_set_value</strong> <em>(  Marpa_Recognizer <var>r</var>,   Marpa_Earley_Set_ID earley_set)</em></dt>
<dd>
<p>On success,
returns the &ldquo;integer value&rdquo; of <var>earley_set</var>.
For more about the integer value of an Earley set,
see <a href="#marpa_005fr_005fearley_005fset_005fvalues">marpa_r_earley_set_values()</a>.
</p>
<p><strong>Return value</strong>:
On success, returns the the integer value of <var>earley_set</var>,
and sets the error code to <code>MARPA_ERR_NONE</code>.
On hard failure, returns -2,
and sets the error code to
the error code of the hard failure,
which will never be <code>MARPA_ERR_NONE</code>.
Note that -2 is a valid &ldquo;integer value&rdquo; for
an Earley set,
so that when -2 is returned,
the error code is the only way to distinguish
success from failure.
The error code can be determined using
<code>marpa_g_error()</code>.
See <a href="#marpa_005fg_005ferror">marpa_g_error()</a>.
</p>
</dd></dl>

<a name="marpa_005fr_005fearley_005fset_005fvalues"></a><dl>
<dt><a name="index-marpa_005fr_005fearley_005fset_005fvalues"></a>Mutator function: <em>int</em> <strong>marpa_r_earley_set_values</strong> <em>(  Marpa_Recognizer <var>r</var>,   Marpa_Earley_Set_ID <var>earley_set</var>,   int* <var>p_value</var>,   void** <var>p_pvalue</var>   )</em></dt>
<dd>
<p>On success, does the following:
</p><ul>
<li> If <var>p_value</var> is non-zero,
sets the location pointed to by
<var>p_value</var> to the integer value of the Earley set
with ID <var>earley_set</var>.
</li><li> If <var>p_pvalue</var> is non-zero,
sets the location pointed to by
<var>p_pvalue</var> to the pointer value of the Earley set
with ID <var>earley_set</var>.
</li></ul>

<p>The &ldquo;value&rdquo; and &ldquo;pointer&rdquo; of an Earley set are
an arbitrary integer
and an arbitrary pointer.
Libmarpa never examines them
and the application is free to
use them for its own purposes.
In an application with a codepoint-per-earleme input model, for example,
the integer value of the Earley set
can used to store the current codepoint.
In a traditional token-per-earleme input model,
the integer and pointer values could be used to track the string value of the token &ndash;
the pointer could point to the start of the string,
and the integer could indicate its length.
See <a href="#The-codepoint_002dper_002dearleme-model">The codepoint-per-earleme model</a>.
</p>
<p>The Earley set integer value defaults to -1,
and the pointer value defaults to <code>NULL</code>.
The Earley set value and pointer can be set using
the
<code>marpa_r_latest_earley_set_values_set()</code>
method.
See <a href="#marpa_005fr_005flatest_005fearley_005fset_005fvalues_005fset">marpa_r_latest_earley_set_values_set()</a>.
</p>
<p><strong>Return value</strong>: On success, returns a non-negative integer.
On hard failure, returns -2.
</p></dd></dl>

<a name="marpa_005fr_005ffurthest_005fearleme"></a><dl>
<dt><a name="index-marpa_005fr_005ffurthest_005fearleme"></a>Accessor function: <em><code>unsigned int</code></em> <strong>marpa_r_furthest_earleme</strong> <em>(Marpa_Recognizer <var>r</var>)</em></dt>
<dd>
<p><strong>Return value</strong>: The furthest earleme.  Always succeeds.
</p>
</dd></dl>

<a name="marpa_005fr_005flatest_005fearley_005fset"></a><dl>
<dt><a name="index-marpa_005fr_005flatest_005fearley_005fset"></a>Accessor function: <em>Marpa_Earley_Set_ID</em> <strong>marpa_r_latest_earley_set</strong> <em>(Marpa_Recognizer <var>r</var>)</em></dt>
<dd>
<p>Returns the Earley set ID of the latest Earley set.
The ID of an Earley set ID is also called its ordinal.
Applications that want the
value of the latest earleme can convert
this value using
the
<code>marpa_r_earleme()</code>
method.
See <a href="#marpa_005fr_005fearleme">marpa_r_earleme()</a>.
</p>
<p><strong>Return value</strong>: The ID of the latest Earley set.  Always succeeds.
</p></dd></dl>

<a name="marpa_005fr_005flatest_005fearley_005fset_005fvalue_005fset"></a><dl>
<dt><a name="index-marpa_005fr_005flatest_005fearley_005fset_005fvalue_005fset"></a>Mutator function: <em>int</em> <strong>marpa_r_latest_earley_set_value_set</strong> <em>(  Marpa_Recognizer <var>r</var>, int <var>value</var>)</em></dt>
<dd>
<p>Sets the &ldquo;integer value&rdquo; of the latest Earley set to <var>value</var>.
For more about the integer value of an Earley set,
see <a href="#marpa_005fr_005fearley_005fset_005fvalues">marpa_r_earley_set_values()</a>.
</p>
<p><strong>Return value</strong>:
On success, returns the newly set integer value of the latest earley set,
and sets the error code to <code>MARPA_ERR_NONE</code>.
On hard failure, returns -2,
and sets the error code to
the error code of the hard failure,
which will never be <code>MARPA_ERR_NONE</code>.
Note that -2 is a valid &ldquo;integer value&rdquo; for
an Earley set,
so that when -2 is returned,
the error code is the only way to distinguish
success from failure.
The error code can be determined using
<code>marpa_g_error()</code>.
See <a href="#marpa_005fg_005ferror">marpa_g_error()</a>.
</p>
</dd></dl>

<a name="marpa_005fr_005flatest_005fearley_005fset_005fvalues_005fset"></a><dl>
<dt><a name="index-marpa_005fr_005flatest_005fearley_005fset_005fvalues_005fset"></a>Mutator function: <em>int</em> <strong>marpa_r_latest_earley_set_values_set</strong> <em>(  Marpa_Recognizer <var>r</var>,   int value,   void* pvalue)</em></dt>
<dd>
<p>Sets the integer and pointer value of the latest Earley set.
For more about the &ldquo;integer value&rdquo; and &ldquo;pointer value&rdquo;
of an Earley set,
see <a href="#marpa_005fr_005fearley_005fset_005fvalues">marpa_r_earley_set_values()</a>.
</p>
<p><strong>Return value</strong>: On success, returns a non-negative integer.
On hard failure, returns -2.
</p></dd></dl>

<hr>
<a name="Other-parse-status-methods"></a>
<div class="header">
<p>
Previous: <a href="#Location-accessors" accesskey="p" rel="prev">Location accessors</a>, Up: <a href="#Recognizer-methods" accesskey="u" rel="up">Recognizer methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Other-parse-status-methods-1"></a>
<h3 class="section">19.6 Other parse status methods</h3>

<a name="marpa_005fr_005fearley_005fitem_005fwarning_005fthreshold"></a><dl>
<dt><a name="index-marpa_005fr_005fearley_005fitem_005fwarning_005fthreshold"></a>Accessor function: <em>int</em> <strong>marpa_r_earley_item_warning_threshold</strong> <em>(Marpa_Recognizer <var>r</var>)</em></dt>
<dd>
<p>Details about the &ldquo;earley item warning threshold&rdquo; are
in the description of the
<code>marpa_r_earley_item_warning_threshold_set()</code> method.
See <a href="#marpa_005fr_005fearley_005fitem_005fwarning_005fthreshold_005fset">marpa_r_earley_item_warning_threshold_set()</a>.
</p>
<p><strong>Return value</strong>:
The Earley item warning threshold.
Always succeeds.
</p></dd></dl>

<a name="marpa_005fr_005fearley_005fitem_005fwarning_005fthreshold_005fset"></a><dl>
<dt><a name="index-marpa_005fr_005fearley_005fitem_005fwarning_005fthreshold_005fset"></a>Mutator function: <em>int</em> <strong>marpa_r_earley_item_warning_threshold_set</strong> <em>(Marpa_Recognizer <var>r</var>,     int <var>threshold</var>)</em></dt>
<dd>
<p>On success, sets
the Earley item warning threshold.
The
<a name="index-Earley-item-warning-threshold"></a>
<em>Earley item warning threshold</em>
is a number that is compared with
the count of Earley items in each Earley set.
When it is matched or exceeded,
a <code>MARPA_EVENT_EARLEY_ITEM_THRESHOLD</code> event is created.
See <a href="#MARPA_005fEVENT_005fEARLEY_005fITEM_005fTHRESHOLD">MARPA_EVENT_EARLEY_ITEM_THRESHOLD</a>.
</p>
<p>If <var>threshold</var> is zero or less,
an unlimited number of Earley items
will be allowed without warning.
This will rarely be what the user wants.
</p>
<p>By default, Libmarpa calculates a value based on the grammar.
The formula Libmarpa uses is the result of some experience,
and most applications will
be happy with it.
</p>
<p>What should be done when the threshold is exceeded, depends on the application,
but exceeding the threshold means that it is very likely
that the time and space resources consumed by
the parse will prove excessive.
This is often a sign of a bug in the grammar.
Applications often will want to smoothly shut down
the parse,
in effect treating
the <code>MARPA_EVENT_EARLEY_ITEM_THRESHOLD</code> event
as equivalent to library-recoverable hard failure.
</p>
<p><strong>Return value</strong>:
The value that the Earley item warning threshold has
after the method call is finished.
Always succeeds.
</p></dd></dl>

<a name="marpa_005fr_005fis_005fexhausted"></a><dl>
<dt><a name="index-marpa_005fr_005fis_005fexhausted"></a>Accessor function: <em>int</em> <strong>marpa_r_is_exhausted</strong> <em>(Marpa_Recognizer <var>r</var>)</em></dt>
<dd><p>A parser is &ldquo;exhausted&rdquo; if it cannot accept any more input.
See <a href="#Exhaustion">Exhaustion</a>.
</p>
<p><strong>Return value</strong>:
1 if the parser is exhausted, 0 otherwise.
Always succeeds.
</p></dd></dl>

<a name="marpa_005fr_005fterminals_005fexpected"></a><dl>
<dt><a name="index-marpa_005fr_005fterminals_005fexpected"></a>Accessor function: <em>int</em> <strong>marpa_r_terminals_expected</strong> <em>(     Marpa_Recognizer <var>r</var>,     Marpa_Symbol_ID* <var>buffer</var>)</em></dt>
<dd><p>Returns a list of the ID&rsquo;s of the symbols
that are acceptable as tokens
at the current earleme.
<var>buffer</var> is expected to be large enough to hold
the result.
This is guaranteed to be the case if the buffer
is large enough to hold an array of
<code>Marpa_Symbol_ID</code>&rsquo;s whose length
is greater than or equal to the number of symbols
in the grammar.
</p>
<p><strong>Return value</strong>:  On success, the number of <code>Marpa_Symbol_ID</code>&rsquo;s
in <var>buffer</var>, which is always non-negative.
On hard failure, -2.
</p></dd></dl>

<a name="marpa_005fr_005fterminal_005fis_005fexpected"></a><dl>
<dt><a name="index-marpa_005fr_005fterminal_005fis_005fexpected"></a>Accessor function: <em>int</em> <strong>marpa_r_terminal_is_expected</strong> <em>(     Marpa_Recognizer <var>r</var>,     Marpa_Symbol_ID <var>symbol_id</var>)</em></dt>
<dd>
<p>On success, does the folloing:
</p><ul>
<li> If
<var>symbol_id</var> is not the ID of
a terminal symbol, returns 0.
</li><li> If
<var>symbol_id</var> is the ID of
a terminal symbol, but that symbol is <strong>not</strong>
expected at the current earleme, returns 0.
</li><li> If
<var>symbol_id</var> is the ID of
a terminal symbol, but that symbol <strong>is</strong>
expected at the current earleme, returns 1.
</li></ul>
<p>Hard fails if
the symbol with ID <var>symbol_id</var> does not
exist.
</p>
<p><strong>Return value</strong>: On success, 0 or 1.
On hard failure, -2.
</p>
</dd></dl>

<hr>
<a name="Progress-reports"></a>
<div class="header">
<p>
Next: <a href="#Bocage-methods" accesskey="n" rel="next">Bocage methods</a>, Previous: <a href="#Recognizer-methods" accesskey="p" rel="prev">Recognizer methods</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Progress-reports-1"></a>
<h2 class="chapter">20 Progress reports</h2>

<p>It is an important property of the Marpa algorithm that the
Earley sets are added one at a time,
so that
before we have started the construction of the Earley set at <code>n+1</code>,
we know the full state of the parse at and before
location <code>n</code>.
Libmarpa&rsquo;s progress reports allow access to the Earley items
in an Earley set.
</p>
<p>To start a progress report,
use the
<code>marpa_r_progress_report_start()</code>
command.
For each recognizer,
only one progress report can be in use at any one time.
</p>
<p>To step through the Earley items,
use the
<code>marpa_r_progress_item()</code>
method.
</p>
<a name="marpa_005fr_005fprogress_005freport_005freset"></a><dl>
<dt><a name="index-marpa_005fr_005fprogress_005freport_005freset"></a>Mutator function: <em>int</em> <strong>marpa_r_progress_report_reset</strong> <em>(   Marpa_Recognizer <var>r</var>)</em></dt>
<dd>
<p>On success, sets the current vertex of the report traverser
to the null vertex.
For more about the report traverser,
including details about the current and null vertices,
see <a href="#marpa_005fr_005fprogress_005freport_005fstart">marpa_r_progress_report_start()</a>.
</p>
<p>This method is not usually needed.
Its effect is to leave the traverser in the same state as it is
immediately after the
<code>marpa_r_progress_report_start()</code> method.
Loosely speaking, it allows the traversal to &ldquo;start over&rdquo;.
</p>
<p>Hard fails if the recognizer is not started,
or if no progress report traverser is active.
</p>
<p><strong>Return value</strong>: On success, a non-negative value.
On failure, -2.
</p></dd></dl>

<a name="marpa_005fr_005fprogress_005freport_005fstart"></a><dl>
<dt><a name="index-marpa_005fr_005fprogress_005freport_005fstart"></a>Mutator function: <em>int</em> <strong>marpa_r_progress_report_start</strong> <em>(   Marpa_Recognizer <var>r</var>,   Marpa_Earley_Set_ID <var>set_id</var>)</em></dt>
<dd>
<p>Creates a progress report traverser
in recognizer <var>r</var>
for the Earley set with ID <var>set_id</var>.
A
<a name="index-progress-report-traverser"></a>
<a name="index-traverser_002c-progress-report"></a>
<em>progress report traverser</em>
is a non-empty directed cycle graph whose vertices consist
of the following:
</p><ul>
<li> For every Earley item,
exactly one vertex that corresponds to
that Earley item.
This vertex is called the
<a name="index-progress-report-item"></a>
<em>progress report item</em>
or, when the meaning is clear, the
<a name="index-report-item"></a>
<em>report item</em>.
In this method description,
we will say that the number of report items is <code>n</code>,
and we will write <code>ritem[i]</code>
for the <code>i</code>&rsquo;th report item.
</li><li> A special vertex, called the
<a name="index-null-vertex"></a>
<a name="index-vertex_002c-null"></a>
<em>null vertex</em>,
which does not correspond
to any Earley item.
In this method description, we will write <code>null</code> for
the null vertex.
</li></ul>

<p>There may be no Earley items in an Earley set,
and therefore a progress report traverser may contain no report items.
A progress report traverser with no report items is called a
&ldquo;trivial traverser&rdquo;.
A trivial traverser has exactly one edge: <code>(null, null)</code>.
</p>
<p>The edges of a non-trivial traverser are
</p><ul>
<li> <code>(null, ritem[0])</code>,
</li><li> <code>(ritem[n-1], null)</code>, and
</li><li> for every <code>0 &lt;= i &lt; v-1</code>, <code>(ritem[i-1], ritem[i])</code>.
</li></ul>
<p>This implies that every vertex has exactly one direct successor.
The report items are a subgraph,
and this graph can be seen as inducing the sequence <code>ritem[0] ... ritem[n-1]</code>.
</p>
<p>When a progress report traverser is active, one vertex is distinguished as the
<a name="index-current-vertex-_0028of-a-progress-report-traverser_0029"></a>
<a name="index-vertex_002c-current-_0028of-a-progress-report-traverser_0029"></a>
<em>current vertex</em>,
which we will write as <code>current</code>.
We call the direct successor of the current vertex,
the
<a name="index-next-vertex-_0028of-a-progress-report-traverser_0029"></a>
<a name="index-vertex_002c-next-_0028of-a-progress-report-traverser_0029"></a>
<em>next vertex</em>.
</p>
<p>On success, does the following:
</p><ul>
<li> If a progress report traverser was active in this recognizer before this method call,
it is destroyed and its memory is freed..
</li><li> Creates a new progress report traverser from the Earley items for the
Earley set with ID <var>set_id</var>.
</li><li> Activates the newly created progress report traverser,
setting the current vertex to the null vertex.
Intuitively, in a non-trivial traverser,
this can be thought of as positioning the
traverser before the first report item.
</li><li> Returns <code>n</code>, the number of report items.
    <code>n</code> may be zero.
</li></ul>

<p>Hard fails if no Earley set with ID
<var>set_id</var> exists.
The error code is <code>MARPA_ERR_INVALID_LOCATION</code> if <var>set_id</var>
is negative.
The error code is <code>MARPA_ERR_NO_EARLEY_SET_AT_LOCATION</code>
if <var>set_id</var> is greater than the ID of
the latest Earley set.
</p>
<p><strong>Return value</strong>: On success, the number of report items,
which will always be non-negative.
On hard failure, -2.
</p></dd></dl>

<a name="marpa_005fr_005fprogress_005freport_005ffinish"></a><dl>
<dt><a name="index-marpa_005fr_005fprogress_005freport_005ffinish"></a>Mutator function: <em>int</em> <strong>marpa_r_progress_report_finish</strong> <em>(   Marpa_Recognizer <var>r</var> )</em></dt>
<dd>
<p>On success,
destroys the progress report traverser
for recognizer <var>r</var>,
freeing its memory.
For details about the report traverser,
see <a href="#marpa_005fr_005fprogress_005freport_005fstart">marpa_r_progress_report_start()</a>.
</p>
<p>It is often not necessary to call this method.
<code>marpa_r_progress_report_start()</code> destroys
any previously existing progress report.
And,
when a recognizer is destroyed,
its progress report is destroyed as a side effect.
</p>
<p>Hard fails if no progress report is active.
</p>
<p><strong>Return value</strong>:
On success, a non-negative value.
On hard failure, -2.
</p></dd></dl>

<a name="marpa_005fr_005fprogress_005fitem"></a><dl>
<dt><a name="index-marpa_005fr_005fprogress_005fitem"></a>Mutator function: <em>Marpa_Rule_ID</em> <strong>marpa_r_progress_item</strong> <em>(   Marpa_Recognizer <var>r</var>,   int* <var>position</var>,   Marpa_Earley_Set_ID* <var>origin</var> )</em></dt>
<dd><p>This method allows access to the data
for the next progress report item of a
progress report.
For details about progress reports,
see <a href="#marpa_005fr_005fprogress_005freport_005fstart">marpa_r_progress_report_start()</a>.
</p>
<p>In the event of success:
</p><ul>
<li> Advances the current vertex to the next vertex.
More precisely, let <code>c_before</code> be the vertex
that was the current vertex when
this method was called.
The report item traverser has exactly one edge such that <code>c_before</code>
is its first element.
Let this edge be <code>(c_before,c_after)</code>.
This method sets the current vertex to <code>c_after</code>.
In this method description, we will write <code>current</code> as an alias for <code>c_after</code>.
</li><li> <code>current</code> will be a report item vertex and therefore there will
be an Earley item corresponding to <code>current</code>.
</li><li> Writes the &ldquo;cooked dot position&rdquo; of the Earley item corresponding to <code>current</code>
to the location pointed to by the <var>position</var> argument.
</li><li> Writes the origin of the Earley item corresponding to <code>current</code>
to the location pointed to by the <var>origin</var> argument.
</li><li> Returns the rule ID of the Earley item corresponding to <code>current</code>.
</li></ul>

<p>The &ldquo;cooked dot position&rdquo; is
</p><ul>
<li> the standard 0-based start-relative
dot position, if the dotted rule is <strong>not</strong> a completion; and
</li><li> -1, if the dotted rule <strong>is</strong> a completion.
This has the advantage of making it easy for the application
to determine if the dotted rule
is a completion.
An application that prefers the &ldquo;raw&rdquo; 0-based start-relative dot position
may convert
a -1 to the rule length.
See <a href="#marpa_005fg_005frule_005flength">marpa_g_rule_length()</a>.
</li></ul>

<p>In the event of soft failure:
</p><ul>
<li> <code>current</code> is the null vertex.
</li><li> Sets the error code to <code>MARPA_ERR_PROGRESS_REPORT_EXHAUSTED</code>.
</li><li> Leaves unchanged the locations pointed to by
the <var>position</var> and <var>origin</var> arguments.
</li><li> Returns -1.
</li></ul>

<p>In addition to watching for soft failure,
the application can use the item count returned by
<code>marpa_r_progress_report_start()</code>
to determine when the last
item has been seen.
</p>
<p><strong>Return value</strong>: On success, the rule ID of
the progress report item, which is always non-negative.
On soft failure, -1.
If either the <var>position</var> or the <var>origin</var>
argument is <code>NULL</code>,
or on other hard failure, -2.
</p></dd></dl>

<hr>
<a name="Bocage-methods"></a>
<div class="header">
<p>
Next: <a href="#Ordering-methods" accesskey="n" rel="next">Ordering methods</a>, Previous: <a href="#Progress-reports" accesskey="p" rel="prev">Progress reports</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Bocage-methods-1"></a>
<h2 class="chapter">21 Bocage methods</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Bocage-overview" accesskey="1">Bocage overview</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Bocage-data-structure" accesskey="2">Bocage data structure</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Bocage-constructor" accesskey="3">Bocage constructor</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Bocage-reference-counting" accesskey="4">Bocage reference counting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Bocage-accessor" accesskey="5">Bocage accessor</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Bocage-overview"></a>
<div class="header">
<p>
Next: <a href="#Bocage-data-structure" accesskey="n" rel="next">Bocage data structure</a>, Previous: <a href="#Bocage-methods" accesskey="p" rel="prev">Bocage methods</a>, Up: <a href="#Bocage-methods" accesskey="u" rel="up">Bocage methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Overview-1"></a>
<h3 class="section">21.1 Overview</h3>

<p>To create a bocage, use the
<code>marpa_b_new()</code>
method.
</p>
<p>When a bocage is no longer in use, its memory can be freed
using the
<code>marpa_b_unref()</code>
method.
</p>
<hr>
<a name="Bocage-data-structure"></a>
<div class="header">
<p>
Next: <a href="#Bocage-constructor" accesskey="n" rel="next">Bocage constructor</a>, Previous: <a href="#Bocage-overview" accesskey="p" rel="prev">Bocage overview</a>, Up: <a href="#Bocage-methods" accesskey="u" rel="up">Bocage methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Bocage-data-structure-1"></a>
<h3 class="section">21.2 Bocage data structure</h3>

<p>A bocage is a data structure containing the parses
found by processing the input according to the grammar.
It is related to a parse forest,
but is in a form that is more compact and easily traversable.
&ldquo;Bocage&rdquo; is our term, and we discovered this structure
independently,
but we were preceded in the discovery by Elizabeth Scott.
And, unlike us,
Prof. Scott did the all-important
work of documenting it and providing the
appropriate mathematical apparatus.
See <a href="#Scott-2008">Scott 2008</a>.
</p>
<hr>
<a name="Bocage-constructor"></a>
<div class="header">
<p>
Next: <a href="#Bocage-reference-counting" accesskey="n" rel="next">Bocage reference counting</a>, Previous: <a href="#Bocage-data-structure" accesskey="p" rel="prev">Bocage data structure</a>, Up: <a href="#Bocage-methods" accesskey="u" rel="up">Bocage methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Creating-a-new-bocage"></a>
<h3 class="section">21.3 Creating a new bocage</h3>

<a name="marpa_005fb_005fnew"></a><dl>
<dt><a name="index-marpa_005fb_005fnew"></a>Constructor function: <em>Marpa_Bocage</em> <strong>marpa_b_new</strong> <em>(Marpa_Recognizer <var>r</var>,     Marpa_Earley_Set_ID <var>earley_set_ID</var>)</em></dt>
<dd>
<p>On success, the following is the case:
</p><ul>
<li> If <code>earley_set_ID</code> is non-negative,
creates a new bocage object, whose EOP
is the Earley set with ID <code>earley_set_ID</code>.
</li><li> If <code>earley_set_ID</code> is -1,
creates a new bocage object, whose EOP
is the Earley set at the current earleme.
</li><li> The new bocage object has a reference count of 1.
</li><li> The reference count of its parent recognizer object, <var>r</var>,
is increased by 1.
</li></ul>

<p>The application will usually want EOP to be the Earley set
at the current earleme,
but there are exceptions.
See <a href="#End-of-parse">End of parse</a>.
</p>
<p>If <var>earley_set_ID</var> is -1
and there is no Earley set at the current earleme;
or if <var>earley_set_ID</var> is non-negative
and there is no parse ending at Earley set <var>earley_set_ID</var>,
<code>marpa_b_new()</code>
hard fails
with the error code <code>MARPA_ERR_NO_PARSE</code>.
</p>
<p><strong>Return value</strong>: On success, the new bocage object.
On hard failure, <code>NULL</code>.
</p></dd></dl>

<hr>
<a name="Bocage-reference-counting"></a>
<div class="header">
<p>
Next: <a href="#Bocage-accessor" accesskey="n" rel="next">Bocage accessor</a>, Previous: <a href="#Bocage-constructor" accesskey="p" rel="prev">Bocage constructor</a>, Up: <a href="#Bocage-methods" accesskey="u" rel="up">Bocage methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Reference-counting-2"></a>
<h3 class="section">21.4 Reference counting</h3>
<a name="marpa_005fb_005fref"></a><dl>
<dt><a name="index-marpa_005fb_005fref"></a>Mutator function: <em>Marpa_Bocage</em> <strong>marpa_b_ref</strong> <em>(Marpa_Bocage <var>b</var>)</em></dt>
<dd>
<p>On success, increases the reference count by 1.
This method is not needed by most applications.
</p>
<p><strong>Return value</strong>:
On success, <var>b</var>.
On hard failure, <code>NULL</code>.
</p></dd></dl>

<a name="marpa_005fb_005funref"></a><dl>
<dt><a name="index-marpa_005fb_005funref"></a>Destructor function: <em>void</em> <strong>marpa_b_unref</strong> <em>(Marpa_Bocage <var>b</var>)</em></dt>
<dd><p>Decreases the reference count by 1,
destroying <var>b</var> once the reference count reaches
zero.
When <var>b</var> is destroyed, the reference count
of its parent recognizer is decreased by 1.
</p>
</dd></dl>

<hr>
<a name="Bocage-accessor"></a>
<div class="header">
<p>
Previous: <a href="#Bocage-reference-counting" accesskey="p" rel="prev">Bocage reference counting</a>, Up: <a href="#Bocage-methods" accesskey="u" rel="up">Bocage methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Accessors"></a>
<h3 class="section">21.5 Accessors</h3>
<a name="marpa_005fb_005fambiguity_005fmetric"></a><dl>
<dt><a name="index-marpa_005fb_005fambiguity_005fmetric"></a>Accessor function: <em>int</em> <strong>marpa_b_ambiguity_metric</strong> <em>(Marpa_Bocage <var>b</var>)</em></dt>
<dd><p>On success, returns an ambiguity metric.
If the parse is unambiguous,
the metric is 1.
If the parse is ambiguous, the metric
is 2 or greater, and is otherwise unspecified.
See <a href="#Better-defined-ambiguity-metric">Better defined ambiguity metric</a>.
</p>
<p><strong>Return value</strong>: On success, the ambiguity metric,
which is always non-negative.
On hard failure, -2.
</p>
</dd></dl>

<a name="marpa_005fb_005fis_005fnull"></a><dl>
<dt><a name="index-marpa_005fb_005fis_005fnull"></a>Accessor function: <em>int</em> <strong>marpa_b_is_null</strong> <em>(Marpa_Bocage <var>b</var>)</em></dt>
<dd>
<p><strong>Return value</strong>
On success, a non-negative integer:
1 or greater if the bocage <strong>is</strong> for a null parse,
and 0 if the bocage is <strong>not</strong> for a null parse.
On hard failure, -2.
</p></dd></dl>

<hr>
<a name="Ordering-methods"></a>
<div class="header">
<p>
Next: <a href="#Tree-methods" accesskey="n" rel="next">Tree methods</a>, Previous: <a href="#Bocage-methods" accesskey="p" rel="prev">Bocage methods</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Ordering-methods-1"></a>
<h2 class="chapter">22 Ordering methods</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Ordering-overview" accesskey="1">Ordering overview</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Freezing-the-ordering" accesskey="2">Freezing the ordering</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Ordering-constructor" accesskey="3">Ordering constructor</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Ordering-reference-counting" accesskey="4">Ordering reference counting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Order-accessor" accesskey="5">Order accessor</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Non_002ddefault-ordering" accesskey="6">Non-default ordering</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Ordering-overview"></a>
<div class="header">
<p>
Next: <a href="#Freezing-the-ordering" accesskey="n" rel="next">Freezing the ordering</a>, Previous: <a href="#Ordering-methods" accesskey="p" rel="prev">Ordering methods</a>, Up: <a href="#Ordering-methods" accesskey="u" rel="up">Ordering methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Overview-2"></a>
<h3 class="section">22.1 Overview</h3>

<p>Before iterating through the parse trees in the bocage,
the parse trees must be ordered.
To create an ordering, use the
<code>marpa_o_new()</code>
method.
</p>
<p>When an ordering is no longer in use, its memory can be freed
using the
<code>marpa_o_unref()</code>
method.
</p>
<hr>
<a name="Freezing-the-ordering"></a>
<div class="header">
<p>
Next: <a href="#Ordering-constructor" accesskey="n" rel="next">Ordering constructor</a>, Previous: <a href="#Ordering-overview" accesskey="p" rel="prev">Ordering overview</a>, Up: <a href="#Ordering-methods" accesskey="u" rel="up">Ordering methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Freezing-the-ordering-1"></a>
<h3 class="section">22.2 Freezing the ordering</h3>

<p>An ordering is
<a name="index-frozen-ordering"></a>
<a name="index-ordering_002c-frozen"></a>
<em>frozen</em>
under the following circumstances:
</p><ul>
<li> The first
tree iterator is created
using the ordering.
See <a href="#marpa_005ft_005fnew">marpa_t_new()</a>.
</li><li> <code>marpa_o_ambiguity_metric()</code>
is successfully called.
See <a href="#marpa_005fo_005fambiguity_005fmetric">marpa_o_ambiguity_metric()</a>.
</li><li> <code>marpa_o_rank()</code> is successfully called.
See <a href="#marpa_005fo_005frank">marpa_o_rank()</a>.
</li></ul>

<p>A frozen ordering cannot be changed.
There is no way to &ldquo;unfreeze&rdquo; an ordering.
</p>
<hr>
<a name="Ordering-constructor"></a>
<div class="header">
<p>
Next: <a href="#Ordering-reference-counting" accesskey="n" rel="next">Ordering reference counting</a>, Previous: <a href="#Freezing-the-ordering" accesskey="p" rel="prev">Freezing the ordering</a>, Up: <a href="#Ordering-methods" accesskey="u" rel="up">Ordering methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Creating-an-ordering"></a>
<h3 class="section">22.3 Creating an ordering</h3>

<a name="marpa_005fo_005fnew"></a><dl>
<dt><a name="index-marpa_005fo_005fnew"></a>Constructor function: <em>Marpa_Order</em> <strong>marpa_o_new</strong> <em>( Marpa_Bocage <var>b</var>)</em></dt>
<dd>
<p>On success, does the following:
</p><ul>
<li> Creates a new ordering object, with a reference count of 1.
</li><li> Increases the reference count of its parent bocage object, <var>b</var>, by 1.
</li></ul>

<p><strong>Return value</strong>: On success, the new ordering object.
On hard failure, <code>NULL</code>.
</p></dd></dl>

<hr>
<a name="Ordering-reference-counting"></a>
<div class="header">
<p>
Next: <a href="#Order-accessor" accesskey="n" rel="next">Order accessor</a>, Previous: <a href="#Ordering-constructor" accesskey="p" rel="prev">Ordering constructor</a>, Up: <a href="#Ordering-methods" accesskey="u" rel="up">Ordering methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Reference-counting-3"></a>
<h3 class="section">22.4 Reference counting</h3>

<a name="marpa_005fo_005fref"></a><dl>
<dt><a name="index-marpa_005fo_005fref"></a>Mutator function: <em>Marpa_Order</em> <strong>marpa_o_ref</strong> <em>( Marpa_Order <var>o</var>)</em></dt>
<dd>
<p>On success, increases the reference count by 1.
Not needed by most applications.
</p>
<p><strong>Return value</strong>:
On success, <var>o</var>.
On hard failure, <code>NULL</code>.
</p></dd></dl>

<a name="marpa_005fo_005funref"></a><dl>
<dt><a name="index-marpa_005fo_005funref"></a>Destructor function: <em>void</em> <strong>marpa_o_unref</strong> <em>(     Marpa_Order <var>o</var>)</em></dt>
<dd>
<p>Decreases the reference count by 1,
destroying <var>o</var> once the reference count reaches
zero.
</p>
</dd></dl>

<hr>
<a name="Order-accessor"></a>
<div class="header">
<p>
Next: <a href="#Non_002ddefault-ordering" accesskey="n" rel="next">Non-default ordering</a>, Previous: <a href="#Ordering-reference-counting" accesskey="p" rel="prev">Ordering reference counting</a>, Up: <a href="#Ordering-methods" accesskey="u" rel="up">Ordering methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Accessors-1"></a>
<h3 class="section">22.5 Accessors</h3>
<a name="marpa_005fo_005fambiguity_005fmetric"></a><dl>
<dt><a name="index-marpa_005fo_005fambiguity_005fmetric"></a>Accessor function: <em>int</em> <strong>marpa_o_ambiguity_metric</strong> <em>(Marpa_Order <var>o</var>)</em></dt>
<dd>
<p>On success, returns an ambiguity metric.
If the parse is unambiguous,
the metric is 1.
If the parse is ambiguous, the metric
is 2 or greater, and is otherwise unspecified.
See <a href="#Better-defined-ambiguity-metric">Better defined ambiguity metric</a>.
</p>
<p>If &ldquo;high rank only&rdquo; is in effect,
this ambiguity metric may differ from that returned by
<code>marpa_b_ambiguity_metric()</code>.
In particular, a &ldquo;high rank only&rdquo; ordering
may be unambiguous even if its base bocage is ambiguous.
But note also,
because multiple parses choices may have the same rank,
it is quite possible for
a &ldquo;high rank only&rdquo; ordering to be ambiguous.
</p>
<p>If the ordering is not already frozen,
it will be frozen on return from
<code>marpa_o_ambiguity_metric()</code>.
Note that, despite this, we classify
<code>marpa_o_ambiguity_metric()</code> as an &ldquo;accessor&rdquo;.
Our classification of methods into accessors,
mutators, etc. is for the purpose of
specifying diagnostic behaviors.
When diagnostic behaviors proscribe the use of mutators on a ordering,
they treat the orderings as if they were frozen,
so that, from the point of view of the diagnostic behaviors,
the &ldquo;freezing&rdquo; of an ordering does not change its state.
</p>
<p><strong>Return value</strong>:
On success, the ambiguity metric, which is non-negative.
On hard failure, -2.
</p>
</dd></dl>

<a name="marpa_005fo_005fis_005fnull"></a><dl>
<dt><a name="index-marpa_005fo_005fis_005fnull"></a>Accessor function: <em>int</em> <strong>marpa_o_is_null</strong> <em>(Marpa_Order <var>o</var>)</em></dt>
<dd><p><strong>Return value</strong>:
On success:
A number greater than or equal to 1 if the ordering is for a null parse;
otherwise, 0.
On hard failure, -2.
</p></dd></dl>

<hr>
<a name="Non_002ddefault-ordering"></a>
<div class="header">
<p>
Previous: <a href="#Order-accessor" accesskey="p" rel="prev">Order accessor</a>, Up: <a href="#Ordering-methods" accesskey="u" rel="up">Ordering methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Non_002ddefault-ordering-1"></a>
<h3 class="section">22.6 Non-default ordering</h3>

<a name="marpa_005fo_005fhigh_005frank_005fonly"></a><dl>
<dt><a name="index-marpa_005fo_005fhigh_005frank_005fonly"></a>Accessor function: <em>int</em> <strong>marpa_o_high_rank_only</strong> <em>( Marpa_Order <var>o</var>)</em></dt>
<dd>
<p>On success, returns,
the &ldquo;high rank only&rdquo; flag of ordering <var>o</var>.
See <a href="#marpa_005fo_005fhigh_005frank_005fonly_005fset">marpa_o_high_rank_only_set()</a>.
</p>
<p><strong>Return value</strong>:
On success, the  value of the
&ldquo;high rank only&rdquo; flag, which is a boolean.
On hard failure, -2.
</p></dd></dl>

<a name="marpa_005fo_005fhigh_005frank_005fonly_005fset"></a><dl>
<dt><a name="index-marpa_005fo_005fhigh_005frank_005fonly_005fset"></a>Mutator function: <em>int</em> <strong>marpa_o_high_rank_only_set</strong> <em>(     Marpa_Order <var>o</var>,     int <var>flag</var>)</em></dt>
<dd>
<p>Sets the &ldquo;high rank only&rdquo; flag of ordering <var>o</var>.
A <var>flag</var> of 1 indicates that, when ranking,
all choices should be discarded except those of the
highest rank.
A <var>flag</var> of 0 indicates that
no choices should be discarded on the
basis of their rank.
</p>
<p>A value of 1 is the default.
The value of the &ldquo;high rank only&rdquo; flag has no effect
until ranking is turned on using the
<code>marpa_o_rank()</code>
method.
</p>
<p>Hards fails if the ordering is frozen.
</p>
<p><strong>Return value</strong>:
On success, a boolean which is the value of the
&ldquo;high rank only&rdquo; flag <strong>after</strong>
the call.
On hard failure, -2.
</p></dd></dl>

<a name="marpa_005fo_005frank"></a><dl>
<dt><a name="index-marpa_005fo_005frank"></a>Mutator function: <em>int</em> <strong>marpa_o_rank</strong> <em>( Marpa_Order <var>o</var> )</em></dt>
<dd>
<p>By default, the ordering of parse trees is arbitrary.
On success, the following happens:
</p><ul>
<li> The ordering is ranked
according to the ranks of symbols and rules,
the &ldquo;null ranks high&rdquo; flags of the rules,
and the &ldquo;high rank only&rdquo; flag of the ordering.
</li><li> The ordering is <em>frozen</em>.
See <a href="#Freezing-the-ordering">Freezing the ordering</a>.
</li></ul>

<p><strong>Return value</strong>:
On success, a non-negative value.
On hard failure, -2.
</p></dd></dl>

<hr>
<a name="Tree-methods"></a>
<div class="header">
<p>
Next: <a href="#Value-methods" accesskey="n" rel="next">Value methods</a>, Previous: <a href="#Ordering-methods" accesskey="p" rel="prev">Ordering methods</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Tree-methods-1"></a>
<h2 class="chapter">23 Tree methods</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Tree-overview" accesskey="1">Tree overview</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Tree-constructor" accesskey="2">Tree constructor</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Tree-reference-counting" accesskey="3">Tree reference counting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Iterating-through-the-trees" accesskey="4">Iterating through the trees</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Tree-overview"></a>
<div class="header">
<p>
Next: <a href="#Tree-constructor" accesskey="n" rel="next">Tree constructor</a>, Previous: <a href="#Tree-methods" accesskey="p" rel="prev">Tree methods</a>, Up: <a href="#Tree-methods" accesskey="u" rel="up">Tree methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Overview-3"></a>
<h3 class="section">23.1 Overview</h3>

<p>Once the bocage has an ordering, the parses trees can be iterated.
Marpa&rsquo;s
<a name="index-parse-tree-iterator"></a>
<a name="index-iterator_002c-parse-tree"></a>
<a name="index-parse-tree"></a>
<a name="index-tree-1"></a>
<em>parse tree iterators</em>
iterate the parse trees contained
in a bocage object.
In Libmarpa,
&ldquo;parse tree iterators&rdquo; are usually just called
<em>trees</em>.
</p>
<p>To create a tree, use the
<code>marpa_t_new()</code>
method.
A newly created tree iterator is positioned before the first parse tree.
</p>
<p>When a tree iterator is no longer in use, its memory can be freed
using the
<code>marpa_t_unref()</code>
method.
</p>
<p>To position a newly created tree iterator at the first parse tree,
use the
<code>marpa_t_next()</code>
method.
Once the tree iterator is positioned at a parse tree,
the same
<code>marpa_t_next()</code>
method is used
to position it to the next parse tree.
</p>
<hr>
<a name="Tree-constructor"></a>
<div class="header">
<p>
Next: <a href="#Tree-reference-counting" accesskey="n" rel="next">Tree reference counting</a>, Previous: <a href="#Tree-overview" accesskey="p" rel="prev">Tree overview</a>, Up: <a href="#Tree-methods" accesskey="u" rel="up">Tree methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Creating-a-new-tree-iterator"></a>
<h3 class="section">23.2 Creating a new tree iterator</h3>

<a name="marpa_005ft_005fnew"></a><dl>
<dt><a name="index-marpa_005ft_005fnew"></a>Constructor function: <em>Marpa_Tree</em> <strong>marpa_t_new</strong> <em>(Marpa_Order <var>o</var>)</em></dt>
<dd>
<p>On success, does the following:
</p><ul>
<li> Creates a new tree iterator, with a reference count of 1.
</li><li> Increases the reference count of its parent ordering object, <var>o</var>, by 1.
</li><li> Positions the new tree iterator before the first parse tree.
</li></ul>

<p><strong>Return value</strong>:
On success, a newly created tree.
On hard failure, <code>NULL</code>.
</p></dd></dl>

<hr>
<a name="Tree-reference-counting"></a>
<div class="header">
<p>
Next: <a href="#Iterating-through-the-trees" accesskey="n" rel="next">Iterating through the trees</a>, Previous: <a href="#Tree-constructor" accesskey="p" rel="prev">Tree constructor</a>, Up: <a href="#Tree-methods" accesskey="u" rel="up">Tree methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Reference-counting-4"></a>
<h3 class="section">23.3 Reference counting</h3>

<a name="marpa_005ft_005fref"></a><dl>
<dt><a name="index-marpa_005ft_005fref"></a>Mutator function: <em>Marpa_Tree</em> <strong>marpa_t_ref</strong> <em>(Marpa_Tree <var>t</var>)</em></dt>
<dd><p>On success, increases the reference count by 1.
Not needed by most applications.
</p>
<p><strong>Return value</strong>:
On success, <var>t</var>.
On hard failure, <code>NULL</code>.
</p></dd></dl>

<a name="marpa_005ft_005funref"></a><dl>
<dt><a name="index-marpa_005ft_005funref"></a>Destructor function: <em>void</em> <strong>marpa_t_unref</strong> <em>(Marpa_Tree <var>t</var>)</em></dt>
<dd>
<p>Decreases the reference count by 1,
destroying <var>t</var> once the reference count reaches
zero.
</p></dd></dl>

<hr>
<a name="Iterating-through-the-trees"></a>
<div class="header">
<p>
Previous: <a href="#Tree-reference-counting" accesskey="p" rel="prev">Tree reference counting</a>, Up: <a href="#Tree-methods" accesskey="u" rel="up">Tree methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Iterating-through-the-trees-1"></a>
<h3 class="section">23.4 Iterating through the trees</h3>

<a name="marpa_005ft_005fnext"></a><dl>
<dt><a name="index-marpa_005ft_005fnext"></a>Mutator function: <em>int</em> <strong>marpa_t_next</strong> <em>( Marpa_Tree <var>t</var>)</em></dt>
<dd>
<p>On success,
positions <var>t</var> at the next parse tree
in the iteration.
</p>
<p>Tree iterators are initialized to the position
before the first parse tree,
so this method must be called before creating a valuator
from a tree.
</p>
<p>If a tree iterator is positioned after the last parse,
the tree is said to be &ldquo;exhausted&rdquo;.
A tree iterator for a bocage with no parse trees
is considered to be &ldquo;exhausted&rdquo; when initialized.
</p>
<p>If the tree iterator is exhausted,
soft fails, and
sets the error code to <code>MARPA_ERR_TREE_EXHAUSTED</code>.
See <a href="#Orthogonal-treatment-of-soft-failures">Orthogonal treatment of soft failures</a>.
</p>
<p>It the tree iterator is paused,
hard fails, and
sets the error code to <code>MARPA_ERR_TREE_PAUSED</code>.
This hard failure is fully recoverable.
See <a href="#marpa_005fv_005fnew">marpa_v_new()</a>.
</p>
<p><strong>Return value</strong>: On success, a non-negative value.
On soft failure, -1.
On hard failure, -2.
The hard failure with error code <code>MARPA_ERR_TREE_PAUSED</code>
is fully recoverable.
</p></dd></dl>

<a name="marpa_005ft_005fparse_005fcount"></a><dl>
<dt><a name="index-marpa_005ft_005fparse_005fcount"></a>Accessor function: <em>int</em> <strong>marpa_t_parse_count</strong> <em>( Marpa_Tree <var>t</var>)</em></dt>
<dd>
<p>Returns the count of the number of parse trees
traversed so far.
The count includes the current iteration of the
tree.
A value of 0 indicates that the tree iterator
is at its initialized position,
before the first parse tree.
</p>
<p><strong>Return value</strong>: The number of parses traversed so far.
Always succeeds.
</p></dd></dl>

<hr>
<a name="Value-methods"></a>
<div class="header">
<p>
Next: <a href="#Events" accesskey="n" rel="next">Events</a>, Previous: <a href="#Tree-methods" accesskey="p" rel="prev">Tree methods</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Value-methods-1"></a>
<h2 class="chapter">24 Value methods</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Value-overview" accesskey="1">Value overview</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#How-to-use-the-valuator" accesskey="2">How to use the valuator</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Advantages-of-step_002ddriven-valuation" accesskey="3">Advantages of step-driven valuation</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Maintaining-the-stack" accesskey="4">Maintaining the stack</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Valuator-constructor" accesskey="5">Valuator constructor</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Valuator-reference-counting" accesskey="6">Valuator reference counting</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Stepping-through-the-valuator" accesskey="7">Stepping through the valuator</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Valuator-step-types" accesskey="8">Valuator step types</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Basic-step-accessors" accesskey="9">Basic step accessors</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Step-location-accessors">Step location accessors</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Value-overview"></a>
<div class="header">
<p>
Next: <a href="#How-to-use-the-valuator" accesskey="n" rel="next">How to use the valuator</a>, Previous: <a href="#Value-methods" accesskey="p" rel="prev">Value methods</a>, Up: <a href="#Value-methods" accesskey="u" rel="up">Value methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Overview-4"></a>
<h3 class="section">24.1 Overview</h3>

<p>The archetypal application needs
a value object (or
<a name="index-valuator"></a>
<em>valuator</em>) to produce
the value of the parse tree.
To create a valuator, use the
<code>marpa_v_new()</code>
method.
</p>
<p>The application is required to maintain the stack,
and the application is also required to implement
most of the semantics, including the evaluation
of rules.
Libmarpa&rsquo;s valuator provides instructions to
the application on how to manipulate the stack.
To iterate through this series of instructions,
use the
<code>marpa_v_step()</code>
method.
</p>
<p>When successful, <code>marpa_v_step()</code>
returns the type
of step.
Most step types have values associated with them.
See <a href="#Basic-step-accessors">Basic step accessors</a>,
see <a href="#How-to-use-the-valuator">How to use the valuator</a>, and
see <a href="#Stepping-through-the-valuator">Stepping through the valuator</a>.
</p>
<p>When a valuator is no longer in use, its memory can be freed
using the
<code>marpa_v_unref()</code>
method.
</p>
<hr>
<a name="How-to-use-the-valuator"></a>
<div class="header">
<p>
Next: <a href="#Advantages-of-step_002ddriven-valuation" accesskey="n" rel="next">Advantages of step-driven valuation</a>, Previous: <a href="#Value-overview" accesskey="p" rel="prev">Value overview</a>, Up: <a href="#Value-methods" accesskey="u" rel="up">Value methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="How-to-use-the-valuator-1"></a>
<h3 class="section">24.2 How to use the valuator</h3>
<p>Libmarpa&rsquo;s valuator provides the application with
&ldquo;steps&rdquo;, which are
instructions for stack manipulation.
Libmarpa itself does not maintain a stack.
This leaves the upper layer in total control of the
stack and the values that are placed on it.
</p>
<p>As example may make this clearer.
Suppose the evaluation is at a place in the parse tree
where an addition is being performed.
Libmarpa does not know that the operation
is an addition.
It will tell the application that rule number <var>R</var>
is to be applied to the arguments at stack locations
<var>N</var> and <var>N</var>+1, and that the result is to placed in
stack location <var>N</var>.
</p>
<p>In this system
the application keeps track of the semantics for all
rules, so it looks up rule <var>R</var> and determines that it
is an addition.
The application can do this by using <var>R</var> as an index
into an array of callbacks, or by any other method
it chooses.
Let&rsquo;s assume a callback implements the semantics
for rule <var>R</var>.
Libmarpa has told the application that two arguments
are available for this operation, and that they are
at locations <var>N</var> and <var>N</var>+1 in the stack.
They might be the numbers 42 and 711.
So the callback is called with its two arguments,
and produces a return value, let&rsquo;s say, 753.
Libmarpa has told the application that the result
belongs at location <var>N</var> in the stack,
so the application writes 753 to location <var>N</var>.
</p>
<p>Since Libmarpa knows nothing about the semantics,
the operation for rule R could be string concatenation
instead of addition.
Or, if it is addition, it could allow for its arguments
to be floating point or complex numbers.
Since the application maintains the stack, it is up
to the application whether the stack contains integers,
strings, complex numbers, or polymorphic objects that are
capable of being any of these things and more.
</p>
<hr>
<a name="Advantages-of-step_002ddriven-valuation"></a>
<div class="header">
<p>
Next: <a href="#Maintaining-the-stack" accesskey="n" rel="next">Maintaining the stack</a>, Previous: <a href="#How-to-use-the-valuator" accesskey="p" rel="prev">How to use the valuator</a>, Up: <a href="#Value-methods" accesskey="u" rel="up">Value methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Advantages-of-step_002ddriven-valuation-1"></a>
<h3 class="section">24.3 Advantages of step-driven valuation</h3>

<p>Step-driven valuation
hides Libmarpa&rsquo;s grammar rewrites from the application,
and is quite efficient.
Libmarpa knows which rules are sequences.
Libmarpa optimizes stack manipulations based on this knowledge.
Long sequences
are very common in practical grammars.
For these,
the stack manipulations suggested by Libmarpa&rsquo;s
step-driven valuator
will be significantly faster than the
traditional stack evaluation algorithm.
</p>
<p>Step-driven evaluation has another advantage.
To illustrate this,
consider what is a very common case:
The semantics are implemented in a higher-level language,
using callbacks.
If Libmarpa did not use step-driven valuation,
it would need to provide for this case.
But for generality,
Libmarpa would have to deal in C callbacks.
Therefore, a middle layer would have to create C language wrappers
for the callbacks in the higher level language.
</p>
<p>The implementation that results is this:
The higher level language would need to wrap each callback in C.
When calling Libmarpa, it would pass the wrappered callback.
Libmarpa would then need to call the C language &ldquo;wrapper&rdquo;.
Next, the wrapper would call the higher-level language callback.
The return value,
which would be data native to the higher-level language,
would need to be passed to the C language wrapper,
which will need to make arrangements for it to be based
back to the higher-level language when appropriate.
</p>
<p>A setup like this is not terribly efficient.
And exception handling across language boundaries would be
very tricky.
</p>
<p>But neither of these is the worst problem.
The worst problem is that callbacks are hard to debug.
Wrappered callbacks are even worse.
Calls made across language boundaries
are harder yet to debug.
In the system described above,
by the time a return value is finally consumed,
a language boundary will have been crossed four times.
The ability to debug can make the difference between
code that works and code that does not work,
and callbacks put far too many hurdles
in the way of debugging.
</p>
<p>So, while step-driven valuation seems
a roundabout approach,
it is simpler and more direct than
the likely alternatives.
And there is something to be said for pushing
semantics up to the higher levels &mdash;
they can be expected to know more about it.
</p>
<p>These advantages of step-driven valuation
are strictly in
the context of a low-level interface.
We are under no illusion
that direct use of Libmarpa&rsquo;s valuator will be found
satisfactory by most Libmarpa users,
even those using the C language.
Libmarpa&rsquo;s valuator is intended
to be used via an upper layer,
one that <strong>does</strong> know about semantics.
</p>
<hr>
<a name="Maintaining-the-stack"></a>
<div class="header">
<p>
Next: <a href="#Valuator-constructor" accesskey="n" rel="next">Valuator constructor</a>, Previous: <a href="#Advantages-of-step_002ddriven-valuation" accesskey="p" rel="prev">Advantages of step-driven valuation</a>, Up: <a href="#Value-methods" accesskey="u" rel="up">Value methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Maintaining-the-stack-1"></a>
<h3 class="section">24.4 Maintaining the stack</h3>

<p>This section discusses in detail the requirements
for maintaining the stack.
In some cases,
such as implementation using a Perl array,
fulfilling these requirements is trivial.
Perl auto-extends its arrays,
and initializes the element values,
on every read or write.
For the C programmer,
things are not quite so easy.
</p>
<p>In this section,
we will assume a C89 standard-conformant
C application.
This assumption is convenient on two grounds.
First, this will be the intended use
for many readers.
Second, standard-conformant C89 is
a &ldquo;worst case&rdquo;.
Any issue faced by a programmer in another environment
is likely to also be one that must be solved
by the C programmer.
</p>
<p>Libmarpa often
optimizes away unnecessary stack writes
to stack locations.
When it does so, it will not
necessarily optimize away all reads
to that stack location.
This means that a location&rsquo;s first access,
as suggested by the Libmarpa step instructions,
may be a read.
This possibility
requires a special awareness from the C
programmer.
See <a href="#Sizing-the-stack">Sizing the stack</a>.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Sizing-the-stack" accesskey="1">Sizing the stack</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Sizing-the-stack"></a>
<div class="header">
<p>
Previous: <a href="#Maintaining-the-stack" accesskey="p" rel="prev">Maintaining the stack</a>, Up: <a href="#Maintaining-the-stack" accesskey="u" rel="up">Maintaining the stack</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Sizing-the-stack-1"></a>
<h4 class="subsection">24.4.1 Sizing the stack</h4>

<p>In our discussion of the stack handler for the valuator,
we will treat the stack as a 0-based array.
If an implementation applies Libmarpa&rsquo;s step
instructions literally, using a physical stack,
it must make sure that all locations in the stack are initialized.
The range of locations that must be initialized is from
stack location 0 to the &ldquo;end of stack&rdquo; location.
The result of the parse tree is always stored in stack location 0,
so that a stack location 0 is always needed.
Therefore, the end of stack location is always a specified value, and greater than or equal to 0.
The end of stack location must also be greater than or equal to
</p><ul>
<li> <code>marpa_v_result(v)</code> for every <code>MARPA_STEP_TOKEN</code> step,
</li><li> <code>marpa_v_result(v)</code>
for every <code>MARPA_STEP_NULLING_SYMBOL</code> step, and
</li><li> <code>marpa_v_arg_n(v)</code>
for every <code>MARPA_STEP_RULE</code> step.
</li></ul>

<p>In practice, an application will often extend the stack
as it iterates through the steps,
initializing the new stack locations as they are created.
</p>
<p>Note that our requirement is not merely that the stack locations
exist and be writable, but that they be initialized.
This is necessary for C89 conformance.
Because of write optimizations in our implementation,
the first access to any stack location
may be a read.
C89 allows trap values,
so that a read of an uninitialized location could result
in undefined behavior.
See <a href="#Trap-representations">Trap representations</a>.
</p>
<hr>
<a name="Valuator-constructor"></a>
<div class="header">
<p>
Next: <a href="#Valuator-reference-counting" accesskey="n" rel="next">Valuator reference counting</a>, Previous: <a href="#Maintaining-the-stack" accesskey="p" rel="prev">Maintaining the stack</a>, Up: <a href="#Value-methods" accesskey="u" rel="up">Value methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Creating-a-new-valuator"></a>
<h3 class="section">24.5 Creating a new valuator</h3>

<a name="marpa_005fv_005fnew"></a><dl>
<dt><a name="index-marpa_005fv_005fnew"></a>Constructor function: <em>Marpa_Value</em> <strong>marpa_v_new</strong> <em>(  Marpa_Tree <var>t</var> )</em></dt>
<dd>
<p>On success, does the following:
</p><ul>
<li> Creates a new valuator.  The parent object of the new valuator
will be the tree iterator <var>t</var>.
</li><li> Sets the reference count of the new valuator to 1.
</li><li> Sets new valuator to
<a name="index-active-_0028valuator_0029"></a>
<em>active</em>.
A valuator is always either active or inactive.
</li><li> Increases the reference count of <var>t</var> by 1.
</li><li> &ldquo;Pauses&rdquo; the parent tree iterator.
</li></ul>

<p>As long as a parent tree iterator is
<a name="index-pause-_0028a-parent-tree-iterator_0029"></a>
<em>paused</em>
<code>marpa_t_next()</code>
will not succeed,
and therefore the parent tree iterator cannot move on
to a new parse tree.
Many valuators can share the same parent parse tree.
A tree iterator is &ldquo;unpaused&rdquo; when
all of the valuators of that tree iterator are destroyed.
</p>
<p><strong>Return value</strong>:
On success, the newly created valuator.
On hard failure, <code>NULL</code>.
</p></dd></dl>

<hr>
<a name="Valuator-reference-counting"></a>
<div class="header">
<p>
Next: <a href="#Stepping-through-the-valuator" accesskey="n" rel="next">Stepping through the valuator</a>, Previous: <a href="#Valuator-constructor" accesskey="p" rel="prev">Valuator constructor</a>, Up: <a href="#Value-methods" accesskey="u" rel="up">Value methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Reference-counting-5"></a>
<h3 class="section">24.6 Reference counting</h3>

<a name="marpa_005fv_005fref"></a><dl>
<dt><a name="index-marpa_005fv_005fref"></a>Mutator function: <em>Marpa_Value</em> <strong>marpa_v_ref</strong> <em>(Marpa_Value <var>v</var>)</em></dt>
<dd><p>On success, increases the reference count by 1.
Not needed by most applications.
</p>
<p><strong>Return value</strong>:
On success, <var>v</var>.
On hard failure, <code>NULL</code>.
</p></dd></dl>

<a name="marpa_005fv_005funref"></a><dl>
<dt><a name="index-marpa_005fv_005funref"></a>Destructor function: <em>void</em> <strong>marpa_v_unref</strong> <em>(Marpa_Value <var>v</var>)</em></dt>
<dd>
<p>Decreases the reference count by 1,
destroying <var>v</var> once the reference count reaches
zero.
</p></dd></dl>

<hr>
<a name="Stepping-through-the-valuator"></a>
<div class="header">
<p>
Next: <a href="#Valuator-step-types" accesskey="n" rel="next">Valuator step types</a>, Previous: <a href="#Valuator-reference-counting" accesskey="p" rel="prev">Valuator reference counting</a>, Up: <a href="#Value-methods" accesskey="u" rel="up">Value methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Stepping-through-the-valuator-1"></a>
<h3 class="section">24.7 Stepping through the valuator</h3>

<a name="marpa_005fv_005fstep"></a><dl>
<dt><a name="index-marpa_005fv_005fstep"></a>Mutator function: <em>Marpa_Step_Type</em> <strong>marpa_v_step</strong> <em>( Marpa_Value <var>v</var>)</em></dt>
<dd>
<p>Steps through the tree in depth-first, left-to-right order.
On success, does the following:
</p><ul>
<li> Takes the valuator to the next
<a name="index-step-_0028of-a-valuator_0029"></a>
<a name="index-valuator-step"></a>
<em>step</em>
in its life cycle.
</li><li> Sets and returns the
<a name="index-valuator-step-type"></a>
<a name="index-step-type_002c-valuator"></a>
<a name="index-step-type"></a>
<em>step type</em>,
which is a non-negative integer.
The C type for a step type is <code>Marpa_Step_Type</code>.
</li></ul>

<p>The step type tells
the application how it expected to act on
the step.
See <a href="#Valuator-step-types">Valuator step types</a>.
Steps are often referred to along with their step type so that,
for example, we say
&ldquo;a <code>MARPA_STEP_RULE</code> step&rdquo;
to refer to a step whose step type
is <code>MARPA_STEP_RULE</code>.
</p>
<p>When the iteration through the steps is finished,
the step type is <code>MARPA_STEP_INACTIVE</code>.
At this point, we say that the valuator is
<a name="index-inactive-_0028valuator_0029"></a>
<em>inactive</em>.
Once a valuator becomes inactive, it stays inactive.
</p>
<p><strong>Return value</strong>:  On success, a <code>Marpa_Step_Type</code>,
which always be a non-negative integer.
On hard failure, -2.
</p>
</dd></dl>

<hr>
<a name="Valuator-step-types"></a>
<div class="header">
<p>
Next: <a href="#Basic-step-accessors" accesskey="n" rel="next">Basic step accessors</a>, Previous: <a href="#Stepping-through-the-valuator" accesskey="p" rel="prev">Stepping through the valuator</a>, Up: <a href="#Value-methods" accesskey="u" rel="up">Value methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Valuator-step-types-1"></a>
<h3 class="section">24.8 Valuator step types</h3>

<dl>
<dt><a name="index-MARPA_005fSTEP_005fRULE"></a>Accessor macro: <em>Marpa_Step_Type</em> <strong>MARPA_STEP_RULE</strong></dt>
<dd><p>MARPA_STEP_RULE is the step type for for a rule node.
The application should perform its equivalent
of rule execution.
</p><ul>
<li> The &ldquo;child values&rdquo; for this step
will be in the stack locations from
<code>marpa_v_arg_0(v)</code>
to
<code>marpa_v_arg_n(v)</code>.
</li><li> The rule for this step will be
<code>marpa_v_rule(v)</code>.
</li><li> The result of this step should be written
to stack location
<code>marpa_v_result(v)</code>.
Typically, the result of this step is determined by
executing the semantics for its rule on
its child values.
</li><li> The stack location of
<code>marpa_v_result(v)</code>
is guaranteed to
be equal to
<code>marpa_v_arg_0(v)</code>.
</li></ul>

</dd></dl>

<dl>
<dt><a name="index-MARPA_005fSTEP_005fTOKEN"></a>Accessor macro: <em>Marpa_Step_Type</em> <strong>MARPA_STEP_TOKEN</strong></dt>
<dd><p>MARPA_STEP_TOKEN is the step type for a token node.
The application&rsquo;s equivalent of the evaluation
of the semantics of a non-null token should be performed.
</p><ul>
<li> The symbol ID of the token will be
at stack location <code>marpa_v_token(v)</code>.
</li><li> Libmarpa will already have a&ldquo;token value&rdquo; for the token
in this step,
as was set by the
<code>marpa_r_alternative()</code> method.
See <a href="#marpa_005fr_005falternative">marpa_r_alternative()</a>.
Libmarpa&rsquo;s &ldquo;token value&rdquo; will be in
stack location <code>marpa_v_token_value(v)</code>.
</li><li> The result of the applications&rsquo;s evaluation of the semantics of this token
should be placed in stack location <code>marpa_v_result(v)</code>.
Often, an application will simply copy Libmarpa&rsquo;s &ldquo;token value&rdquo;
to stack location <code>marpa_v_result(v)</code>.
</li></ul>
</dd></dl>

<dl>
<dt><a name="index-MARPA_005fSTEP_005fNULLING_005fSYMBOL"></a>Accessor macro: <em>Marpa_Step_Type</em> <strong>MARPA_STEP_NULLING_SYMBOL</strong></dt>
<dd><p>MARPA_STEP_NULLING_SYMBOL is the step type for a nulled node.
The application&rsquo;s equivalent of the evaluation
of the semantics of a nulled token should be performed.
</p><ul>
<li> The ID of the nulled symbol will be
at stack location <code>marpa_v_symbol(v)</code>.
</li><li> The application&rsquo;s value for this nulled symbol instance
should be placed in
stack location <code>marpa_v_result(v)</code>.
Often, an application will assign a fixed value to each
nullable symbol,
and will simply copy this fixed value to
stack location <code>marpa_v_result(v)</code>.
</li></ul>
<p>The use of the word &ldquo;nulling&rdquo; in
the step type name <code>MARPA_STEP_NULLING_SYMBOL</code>
is problematic.
While the node must be zero-length (nulled),
the node&rsquo;s symbol need not be nulling:
it may be a proper nullable.
The name of the step type would more correctly
be &ldquo;MARPA_STEP_NULLED_SYMBOL&rdquo;,
but it is left as is for backward compatibility.
See <a href="#Nulling-versus-nulled">Nulling versus nulled</a>.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fSTEP_005fINACTIVE"></a>Accessor macro: <em>Marpa_Step_Type</em> <strong>MARPA_STEP_INACTIVE</strong></dt>
<dd><p>When this is the step type, the valuator has gone through all of its steps
and is now inactive.
The value of the parse tree will be in stack location 0.
Because of optimizations,
it is possible for valuator to immediately
became inactive &mdash; <code>MARPA_STEP_INACTIVE</code> could
be both the first and last step.
Once a valuator becomes inactive, it stays inactive.
</p>
</dd></dl>

<dl>
<dt><a name="index-MARPA_005fSTEP_005fINITIAL"></a>Accessor macro: <em>Marpa_Step_Type</em> <strong>MARPA_STEP_INITIAL</strong></dt>
<dd><p>The valuator is new and has
yet to go through any steps.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fSTEP_005fINTERNAL1"></a>Accessor macro: <em>Marpa_Step_Type</em> <strong>MARPA_STEP_INTERNAL1</strong></dt>
<dt><a name="index-MARPA_005fSTEP_005fINTERNAL2"></a>Accessor macro: <em>Marpa_Step_Type</em> <strong>MARPA_STEP_INTERNAL2</strong></dt>
<dt><a name="index-MARPA_005fSTEP_005fTRACE"></a>Accessor macro: <em>Marpa_Step_Type</em> <strong>MARPA_STEP_TRACE</strong></dt>
<dd><p>These step types are reserved for internal purposes.
</p></dd></dl>

<hr>
<a name="Basic-step-accessors"></a>
<div class="header">
<p>
Next: <a href="#Step-location-accessors" accesskey="n" rel="next">Step location accessors</a>, Previous: <a href="#Valuator-step-types" accesskey="p" rel="prev">Valuator step types</a>, Up: <a href="#Value-methods" accesskey="u" rel="up">Value methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Basic-step-accessors-1"></a>
<h3 class="section">24.9 Basic step accessors</h3>

<p>This section describes the
accessors that are basic to stack manipulation.
</p>
<dl>
<dt><a name="index-marpa_005fv_005farg_005f0"></a>Accessor macro: <em>int</em> <strong>marpa_v_arg_0</strong> <em>(Marpa_Value <var>v</var>)</em></dt>
<dd><p><strong>Return value</strong>:
For a <code>MARPA_STEP_RULE</code> step,
the stack location where the value of first child
can be found.
For other step types, an unspecified value.
Always succeeds.
</p></dd></dl>

<dl>
<dt><a name="index-marpa_005fv_005farg_005fn"></a>Accessor macro: <em>int</em> <strong>marpa_v_arg_n</strong> <em>(Marpa_Value <var>v</var>)</em></dt>
<dd><p><strong>Return value</strong>:
For a <code>MARPA_STEP_RULE</code> step,
the stack location where the value of the last child
can be found.
For other step types, an unspecified value.
Always succeeds.
</p></dd></dl>

<dl>
<dt><a name="index-marpa_005fv_005fresult"></a>Accessor macro: <em>int</em> <strong>marpa_v_result</strong> <em>(Marpa_Value <var>v</var>)</em></dt>
<dd><p><strong>Return value</strong>:
For <code>MARPA_STEP_RULE</code>,
<code>MARPA_STEP_TOKEN</code>,
and <code>MARPA_STEP_NULLING_SYMBOL</code> steps,
the stack location where the result of the semantics
should be placed.
For other step types, an unspecified value.
Always succeeds.
</p></dd></dl>

<dl>
<dt><a name="index-marpa_005fv_005frule"></a>Accessor macro: <em>Marpa_Rule_ID</em> <strong>marpa_v_rule</strong> <em>(Marpa_Value <var>v</var>)</em></dt>
<dd><p><strong>Return value</strong>:
For the
<code>MARPA_STEP_RULE</code> step,
the ID of the rule.
For other step types, an unspecified value.
Always succeeds.
</p></dd></dl>

<dl>
<dt><a name="index-marpa_005fv_005fstep_005ftype"></a>Accessor macro: <em>Marpa_Step_Type</em> <strong>marpa_v_step_type</strong> <em>(Marpa_Value <var>v</var>)</em></dt>
<dd><p>This macro is rarely needed since its return value
is the same as the value that <code>marpa_v_step()</code> returns on success.
</p>
<p><strong>Return value</strong>:
The current step type: <code>MARPA_STEP_TOKEN</code>, <code>MARPA_STEP_RULE</code>, etc.
Always succeeds.
</p></dd></dl>

<dl>
<dt><a name="index-marpa_005fv_005fsymbol"></a>Accessor macro: <em>Marpa_Symbol_ID</em> <strong>marpa_v_symbol</strong> <em>(Marpa_Value <var>v</var>)</em></dt>
<dd><p><strong>Return value</strong>:
For the <code>MARPA_STEP_NULLING_SYMBOL</code> step,
the ID of the symbol.
The value returned is the same as that
returned by the
<code>marpa_v_token()</code>
macro.
For other step types, an unspecified value.
Always succeeds.
</p></dd></dl>

<dl>
<dt><a name="index-marpa_005fv_005ftoken"></a>Accessor macro: <em>Marpa_Symbol_ID</em> <strong>marpa_v_token</strong> <em>(Marpa_Value <var>v</var>)</em></dt>
<dd><p><strong>Return value</strong>:
For the <code>MARPA_STEP_TOKEN</code> step,
the ID of the token.
The value returned is the same as that
returned by the
<code>marpa_v_symbol()</code>
macro.
For other step types, an unspecified value.
Always succeeds.
</p></dd></dl>

<dl>
<dt><a name="index-marpa_005fv_005ftoken_005fvalue"></a>Accessor macro: <em>int</em> <strong>marpa_v_token_value</strong> <em>(Marpa_Value <var>v</var>)</em></dt>
<dd><p><strong>Return value</strong>:
For the <code>MARPA_STEP_TOKEN</code> step,
the &ldquo;token value&rdquo; that was assigned to the token by
the <code>marpa_r_alternative()</code> method.
See <a href="#marpa_005fr_005falternative">marpa_r_alternative()</a>.
For other step types, an unspecified value.
Always succeeds.
</p></dd></dl>

<hr>
<a name="Step-location-accessors"></a>
<div class="header">
<p>
Previous: <a href="#Basic-step-accessors" accesskey="p" rel="prev">Basic step accessors</a>, Up: <a href="#Value-methods" accesskey="u" rel="up">Value methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Step-location-accessors-1"></a>
<h3 class="section">24.10 Step location accessors</h3>

<p>This section describes step accessors that are not basic to stack manipulation.
They provide Earley set location information about the parse tree.
</p>
<p>A step&rsquo;s location in terms of Earley sets is called its ES location.
Every ES location is the ID of an Earley set.
ES location is only relevant for steps that correspond to tree nodes.
</p>
<p>Every tree node has both a start ES location
and an end ES location.
The start ES location is the first ES location of
that parse node.
</p>
<p>The end ES location of a leaf is the ES location where
the next leaf symbol in the fringe of the current parse tree would start.
Typically, this is the location where a leaf node actually starts but,
at the end of a parse, there is not an actual next leaf node.
</p>
<p>The start ES location of a MARPA_RULE_STEP step is the start ES location
of its first child node in the current parse tree.
The end ES location of a MARPA_RULE_STEP step is the end ES location
of its last child node in the current parse tree.
</p>
<dl>
<dt><a name="index-marpa_005fv_005fes_005fid"></a>Accessor macro: <em>Marpa_Earley_Set_ID</em> <strong>marpa_v_es_id</strong> <em>(Marpa_Value v)</em></dt>
<dd>
<p><strong>Return value</strong>:
If the current step type is MARPA_STEP_RULE, MARPA_STEP_TOKEN, or MARPA_STEP_NULLING_SYMBOL,
the return value is the end ES location of the parse node.
If the current step type is anything else,
or if the valuator is inactive,
the return value is unspecified.
</p></dd></dl>

<dl>
<dt><a name="index-marpa_005fv_005frule_005fstart_005fes_005fid"></a>Accessor macro: <em>Marpa_Earley_Set_ID</em> <strong>marpa_v_rule_start_es_id</strong> <em>(Marpa_Value v)</em></dt>
<dd>
<p><strong>Return value</strong>:
If the current step type is MARPA_STEP_RULE, the start ES location of the rule node.
If the current step type is anything else,
or if the valuator is inactive,
the return value is unspecified.
</p></dd></dl>

<dl>
<dt><a name="index-marpa_005fv_005ftoken_005fstart_005fes_005fid"></a>Accessor macro: <em>Marpa_Earley_Set_ID</em> <strong>marpa_v_token_start_es_id</strong> <em>(Marpa_Value v)</em></dt>
<dd>
<p><strong>Return value</strong>:
If the current step type is MARPA_STEP_TOKEN or MARPA_STEP_NULLING_SYMBOL,
the start ES location of the leaf node.
If the current step type is anything else,
or if the valuator is inactive,
the return value is unspecified.
</p></dd></dl>

<p>For every parse node of the current parse tree,
the Earley set length (ES length) of the node is the end ES location,
less the start ES location.
The ES length of a nulled node is always 0.
</p>
<p>If v is a valuator whose current step type is MARPA_STEP_NULLING_SYMBOL, it is always the case that
</p>
<pre class="verbatim">         marpa_v_token_start_es_id(v) == marpa_v_es_id(v)
</pre>
<p>If v is a valuator whose current step type is MARPA_STEP_RULE or MARPA_STEP_TOKEN,
it is always the case that
</p>
<pre class="verbatim">        marpa_v_token_start_es_id(v) &lt;= marpa_v_es_id(v)
</pre>
<p>For the following examples,
</p><ul>
<li> let <tt>Null</tt> be a nulling symbol,
</li><li> let <tt>Tok</tt> be a non-nullable symbol, and
</li><li> let the notation <tt>Sym@m-n</tt> indicate that the symbol
<tt>Sym</tt> has ES start location <tt>m</tt> and ES end location <tt>n</tt>.
</li></ul>

<p>Ordered from left to right, a possible fringe is
</p><pre class="verbatim">        Null@0-0, Tok@0-1, Null@1-1, Tok@1-2, Null@2-2
</pre><p>Another example is
</p><pre class="verbatim">        Null@0-0, Null@0-0, Tok@0-1, Null@1-1, Null@1-1, Tok@1-2,
        Null@2-2, Null@2-2
</pre><p>In this second example note that when a nulled leaf immediately follows another
nulled leaf, both leaves has the same start ES location and the same end ES location.
This makes sense, because nulled symbol instances do not advance the current ES location,
but it also implies that the ES locations and LHS symbol
cannot be used to uniquely identify a parse node.
</p>
<hr>
<a name="Events"></a>
<div class="header">
<p>
Next: <a href="#Tracing-and-diagnosing-parses" accesskey="n" rel="next">Tracing and diagnosing parses</a>, Previous: <a href="#Value-methods" accesskey="p" rel="prev">Value methods</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Events-1"></a>
<h2 class="chapter">25 Events</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Events-overview" accesskey="1">Events overview</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Event-codes" accesskey="2">Event codes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Basic-event-accessors" accesskey="3">Basic event accessors</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Completion-events" accesskey="4">Completion events</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Symbol-nulled-events" accesskey="5">Symbol nulled events</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Prediction-events" accesskey="6">Prediction events</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Symbol-expected-events" accesskey="7">Symbol expected events</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Recognizer-per_002dsymbol-events" accesskey="8">Recognizer per-symbol events</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Tentative-events" accesskey="9">Tentative events</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Ambiguous-parses-and-events">Ambiguous parses and events</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Nulled-subtrees-and-events">Nulled subtrees and events</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Event-coincidence-of-symbol-instances">Event coincidence of symbol instances</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Event-coincidence-of-symbols">Event coincidence of symbols</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Marker-symbols">Marker symbols</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Per_002drule-events">Per-rule events</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Events-overview"></a>
<div class="header">
<p>
Next: <a href="#Event-codes" accesskey="n" rel="next">Event codes</a>, Previous: <a href="#Events" accesskey="p" rel="prev">Events</a>, Up: <a href="#Events" accesskey="u" rel="up">Events</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Overview-5"></a>
<h3 class="section">25.1 Overview</h3>

<p>This chapter discusses Libmarpa&rsquo;s events.
It contains descriptions of both grammar and recognizer methods.
</p>
<p>A method is
<a name="index-event_002dtriggering-_0028method_0029"></a>
<em>event-triggering</em>
iff it can add event instances to the
<a name="index-event-queue"></a>
<em>event queue</em>.
The event-triggering methods are
<code>marpa_g_precompute()</code>,
<code>marpa_r_earleme_complete()</code>,
and
<code>marpa_r_start_input()</code>.
The event-triggering methods always clear all previous events
so that, on return from an event-triggering method,
the only events in the event queue will be
the events triggered by that method.
</p>
<p>Every event instance has a type, and a subtype.
The type of an event instance is its
<em>code</em>,
such as <code>MARPA_EVENT_SYMBOL_COMPLETED</code>.
Event codes are listed in a later section.
See <a href="#Event-codes">Event codes</a>.
Subtypes will be described shortly.
</p>
<p>Event types are either
<a name="index-implicit-event-type"></a>
<em>implicit</em>
or
<a name="index-explicit-event-type"></a>
<em>explicit</em>.
Intuitively, implicit event types are
available to the application without any action
by the user;
and explicit event types are not available
unless the user calls certains methods which are
available for that purpose.
</p>
<p>Event are also either
<a name="index-global-event"></a>
<a name="index-event_002c-global"></a>
<em>global</em>
or
<a name="index-per_002dsymbol-event"></a>
<a name="index-event_002c-per_002dsymbol"></a>
<em>per-symbol</em>.
In any event-triggering method,
at most one event instance can trigger for each subtype.
If an event type is
<a name="index-global-event-1"></a>
<em>global</em>,
it has only one subtype,
and only one event instance of that type
may trigger in a method call.
If an event is
<a name="index-per_002dsymbol-event-1"></a>
<em>per-symbol</em>,
it has one subtype for each symbol in grammar.
Many instances of a per-symbol event may trigger
in a method call,
up to the number of symbols in the grammar.
</p>
<p>All global event types are implicit.
All explicit event types are per-symbol.
The reason for event types to be explicit
is to avoid the overhead of unused events,
and for per-symbol event types there might
be many such events.
</p>
<p>For an event instance to trigger,
its event subtype must first be
<a name="index-declared-event-subtype"></a>
<em>declared</em>.
Subtypes of implicit events are always
declared &mdash;
declaring them requires no action on the part
of the user.
Subtypes
of explicit event types must be declared by the user,
using a method call provided
for that purpose.
Once declared, an event subtype remains declared:
there is no way to remove or undo the declaration
of an event subtype.
Details of event declaration are provided,
by event code,
in the section on event codes.
See <a href="#Event-codes">Event codes</a>.
</p>
<p>A declared event subtype can be activated.
An event instance will not trigger,
unless its event subtype is
<a name="index-activated-event-subtype"></a>
<em>activated</em>.
Subtypes of implicit event are always
activated &mdash;
activating them requires no action on the part
of the user.
Subtypes of explicit event types must be activated by the user,
using a method call provided
for that purpose.
Implicitly activated event subtypes cannot be deactivated.
Some explicitly activated event subtypes can be
deactivated, using a method call available for that purpose.
Details of event activation are provided,
by event code,
in the section on event codes.
See <a href="#Event-codes">Event codes</a>.
</p>
<p>When a recognizer is created,
the event subtypes of a recognizer inherit their declared
and activated status from the events of the base
grammar.
See <a href="#marpa_005fr_005fnew">marpa_r_new()</a>.
</p>
<p>A Libmarpa method or macro is
<a name="index-event_002dsafe-_0028method_0029"></a>
<em>event-safe</em>
iff it does not change the events queue.
All Libmarpa accessors are event-safe.
</p>
<p>Regardless of the event-safety of the method calls
between event triggering and event access,
it is good practice to access event instances
as soon as reasonable after the method that triggered them.
Note that the event queue is kept in the base grammar,
so that multiple recognizers using the same base grammar
can overwrite each other&rsquo;s events.
</p>
<p>To find out how many events are in the event queue,
use the
<code>marpa_g_event_count()</code>
method.
See <a href="#marpa_005fg_005fevent_005fcount">marpa_g_event_count()</a>.
</p>
<p>To access specific events,
use the
<code>marpa_g_event()</code>
(see <a href="#marpa_005fg_005fevent">marpa_g_event()</a>)
and
<code>marpa_g_event_value()</code>
(see <a href="#marpa_005fg_005fevent_005fvalue">marpa_g_event_value()</a>)
methods.
</p>
<hr>
<a name="Event-codes"></a>
<div class="header">
<p>
Next: <a href="#Basic-event-accessors" accesskey="n" rel="next">Basic event accessors</a>, Previous: <a href="#Events-overview" accesskey="p" rel="prev">Events overview</a>, Up: <a href="#Events" accesskey="u" rel="up">Events</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Event-codes-1"></a>
<h3 class="section">25.2 Event codes</h3>

<dl>
<dt><a name="index-MARPA_005fEVENT_005fNONE"></a>Accessor macro: <em>int</em> <strong>MARPA_EVENT_NONE</strong></dt>
<dd><p>This is an implicit global event.
This event code is reserved.
No method triggers an event with this code.
</p>
<p><strong>Event value</strong>: Unspecified.
<strong>Suggested message</strong>: &quot;No event&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fEVENT_005fCOUNTED_005fNULLABLE"></a>Accessor macro: <em>int</em> <strong>MARPA_EVENT_COUNTED_NULLABLE</strong></dt>
<dd><p>This is an implicit per-symbol event.
This event is triggered by the
<code>marpa_g_precompute()</code> method
(see <a href="#marpa_005fg_005fprecompute">marpa_g_precompute()</a>),
when a nullable symbol was used as either the separator
for, or the right hand side of, a sequence.
</p>
<p><strong>Event value</strong>: The ID of the symbol.
<strong>Suggested message</strong>: &quot;This symbol is a counted nullable&quot;.
</p></dd></dl>

<a name="MARPA_005fEVENT_005fEARLEY_005fITEM_005fTHRESHOLD"></a><dl>
<dt><a name="index-MARPA_005fEVENT_005fEARLEY_005fITEM_005fTHRESHOLD"></a>Accessor macro: <em>int</em> <strong>MARPA_EVENT_EARLEY_ITEM_THRESHOLD</strong></dt>
<dd><p>This is an implicit global event.
This event is triggered by the
<code>marpa_r_earleme_complete()</code> method
(see <a href="#marpa_005fr_005fearleme_005fcomplete">marpa_r_earleme_complete()</a>),
when
an application-settable threshold
on the number of Earley items has been reached or exceeded.
See <a href="#marpa_005fr_005fearley_005fitem_005fwarning_005fthreshold_005fset">marpa_r_earley_item_warning_threshold_set()</a>.
</p>
<p><strong>Event value</strong>: The current Earley item count.
<strong>Suggested message</strong>: &quot;Too many Earley items&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fEVENT_005fEXHAUSTED"></a>Accessor macro: <em>int</em> <strong>MARPA_EVENT_EXHAUSTED</strong></dt>
<dd><p>This is an implicit global event.
This event is triggered by the
<code>marpa_r_earleme_complete()</code>
(see <a href="#marpa_005fr_005fearleme_005fcomplete">marpa_r_earleme_complete</a>)
and
<code>marpa_r_start_input()</code>
(see <a href="#marpa_005fr_005fstart_005finput">marpa_r_start_input</a>)
methods,
when the parse is exhausted.
See <a href="#Exhaustion">Exhaustion</a>.
</p>
<p><strong>Event value</strong>: Unspecified.
<strong>Suggested message</strong>: &quot;Recognizer is exhausted&quot;.
</p></dd></dl>

<a name="MARPA_005fEVENT_005fLOOP_005fRULES"></a><dl>
<dt><a name="index-MARPA_005fEVENT_005fLOOP_005fRULES"></a>Accessor macro: <em>int</em> <strong>MARPA_EVENT_LOOP_RULES</strong></dt>
<dd><p>This is an implicit global event.
This event is triggered by the
<code>marpa_g_precompute()</code> method,
when one or more rules are loop rules.
(See <a href="#marpa_005fg_005fprecompute">marpa_g_precompute()</a>.
</p>
<p>A rule is a loop rule iff it is part of a cycle.
See <a href="#Cycles">Cycles</a>.
Parsing with a grammar than contains a loop rule
is deprecated.
</p>
<p><strong>Event value</strong>: The count of loop rules.
<strong>Suggested message</strong>: &quot;Grammar contains a infinite loop&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fEVENT_005fNULLING_005fTERMINAL"></a>Accessor macro: <em>int</em> <strong>MARPA_EVENT_NULLING_TERMINAL</strong></dt>
<dd><p>This is an implicit per-symbol event.
This event is triggered by the
<code>marpa_g_precompute()</code> method.
See <a href="#marpa_005fg_005fprecompute">marpa_g_precompute()</a>.
It only occurs if the LHS terminals feature is in use.
The LHS terminals feature is deprecated.
See <a href="#LHS-terminals">LHS terminals</a>.
</p>
<p><strong>Event value</strong>: The ID of the symbol.
<strong>Suggested message</strong>: &quot;This symbol is a nulling terminal&quot;.
</p></dd></dl>

<a name="MARPA_005fEVENT_005fSYMBOL_005fCOMPLETED"></a><dl>
<dt><a name="index-MARPA_005fEVENT_005fSYMBOL_005fCOMPLETED"></a>Accessor macro: <em>int</em> <strong>MARPA_EVENT_SYMBOL_COMPLETED</strong></dt>
<dd><p>This is an explicit per-symbol event.
Intuitively, it triggers when a non-nulled non-terminal symbol is
fully recognized.
</p>
<p>More precisely,
when an Earley set is completed at earleme <code>j</code>,
the MARPA_EVENT_SYMBOL_COMPLETED event instance
for symbol <code>sym</code>
triggers iff
</p><ul>
<li> the event subtype of
MARPA_EVENT_SYMBOL_COMPLETED for <code>sym</code>
is activated; and
</li><li> the Earley set at earleme <code>j</code> contains
a completed Earley item for a rule whose
LHS is <code>sym</code>.
</li></ul>
<p>The MARPA_EVENT_SYMBOL_COMPLETED
is triggered by the
<code>marpa_r_earleme_complete()</code> method.
See <a href="#marpa_005fr_005fearleme_005fcomplete">marpa_r_earleme_complete()</a>.
</p>
<p>We recall that a symbol instance is a symbol,
together with start and end parse locations.
More than one symbol instance may trigger the
same
MARPA_EVENT_SYMBOL_COMPLETED event instance.
For example,
if <code>x</code>@40-42 and
<code>x</code>@38-42 are symbol instances,
they will trigger only one event instance &mdash;
the MARPA_EVENT_SYMBOL_COMPLETED event instance
at location 42 with symbol <code>x</code>.
</p>
<p>To declare a completed symbol event, use the
<code>marpa_g_symbol_is_completion_event_set()</code> method.
See <a href="#marpa_005fg_005fsymbol_005fis_005fcompletion_005fevent_005fset">marpa_g_symbol_is_completion_event_set</a>.
To activate or deactivate a completed symbol event,
use the
<code>marpa_g_completion_symbol_activate</code> method
(see <a href="#marpa_005fg_005fcompletion_005fsymbol_005factivate">marpa_g_completion_symbol_activate</a>),
or the
<code>marpa_r_completion_symbol_activate</code> method
(see <a href="#marpa_005fr_005fcompletion_005fsymbol_005factivate">marpa_r_completion_symbol_activate</a>).
</p>
<p><strong>Event value</strong>: The ID of the completed symbol.
<strong>Suggested message</strong>: &quot;Completed symbol&quot;.
</p></dd></dl>

<a name="MARPA_005fEVENT_005fSYMBOL_005fEXPECTED"></a><dl>
<dt><a name="index-MARPA_005fEVENT_005fSYMBOL_005fEXPECTED"></a>Accessor macro: <em>int</em> <strong>MARPA_EVENT_SYMBOL_EXPECTED</strong></dt>
<dd><p>This is an explicit per-symbol event.
Intuitively, it triggers when a terminal symbol
is expected.
</p>
<p>More precisely,
when an Earley set is completed at earleme <code>j</code>,
the MARPA_EVENT_SYMBOL_EXPECTED event instance
for symbol <code>sym</code>
triggers iff
</p><ul>
<li> the event subtype of
MARPA_EVENT_SYMBOL_EXPECTED for <code>sym</code>
is activated;
</li><li> <code>sym</code> is a terminal; and
</li><li> <code>sym</code> is the postdot symbol of an Earley item
whose current location is <code>j</code>.
</li></ul>
<p>This event is triggered by the
<code>marpa_r_earleme_complete()</code>
(see <a href="#marpa_005fr_005fearleme_005fcomplete">marpa_r_earleme_complete</a>)
and
<code>marpa_r_start_input()</code>
(see <a href="#marpa_005fr_005fstart_005finput">marpa_r_start_input</a>)
methods.
</p>
<p>More than one symbol instance may trigger the same
MARPA_EVENT_SYMBOL_EXPECTED event instance.
For example, if
</p><div class="display">
<pre class="display">    <code>[ [ X ::= B &bull; x ], 0, 42 ]</code> and
    <code>[ [ Y ::= C &bull; x ], 7, 42 ]</code>
</pre></div>
<p>are Earley items,
they will trigger only one event instance &mdash;
the MARPA_EVENT_SYMBOL_EXPECTED event instance at location 42
with symbol <code>x</code>.
</p>
<p>MARPA_EVENT_SYMBOL_EXPECTED events
only trigger if their symbol is expected as a terminal.
Predicted symbols that are not expected as terminals
do not trigger this event.
</p>
<p>To declare an expected terminal event, use the
<code>marpa_r_expected_symbol_event_set()</code> method.
The <code>marpa_r_expected_symbol_event_set()</code> method
is also used to activate or deactivate an expected terminal event.
See <a href="#marpa_005fr_005fexpected_005fsymbol_005fevent_005fset">marpa_r_expected_symbol_event_set</a>.
</p>
<p><strong>Event value</strong>: The ID of the expected symbol.
<strong>Suggested message</strong>: &quot;Expecting symbol&quot;.
</p></dd></dl>

<a name="MARPA_005fEVENT_005fSYMBOL_005fNULLED"></a><dl>
<dt><a name="index-MARPA_005fEVENT_005fSYMBOL_005fNULLED"></a>Accessor macro: <em>int</em> <strong>MARPA_EVENT_SYMBOL_NULLED</strong></dt>
<dd><p>This is an explicit per-symbol event.
Intuitively,
this event triggers when a nulled instance of a symbol
is recognized.
</p>
<p>More precisely,
when an Earley set is completed at earleme <code>j</code>,
the MARPA_EVENT_SYMBOL_NULLED event instance
for symbol <code>sym</code>
triggers iff
</p><ul>
<li> the event subtype of
MARPA_EVENT_SYMBOL_NULLED for <code>sym</code>
is activated; and
</li><li> <code>sym</code>@<code>j</code>-<code>j</code>
is a symbol instance.
</li></ul>
<p>This event is triggered by the
<code>marpa_r_earleme_complete()</code>
(see <a href="#marpa_005fr_005fearleme_005fcomplete">marpa_r_earleme_complete</a>)
and
<code>marpa_r_start_input()</code>
(see <a href="#marpa_005fr_005fstart_005finput">marpa_r_start_input</a>)
methods.
</p>
<p>Duplicate nulled nodes may occur.
See <a href="#Duplicate-nulled-nodes">Duplicate nulled nodes</a>.
Even if there are duplicate nulled nodes
for symbol <code>sym</code> at location <code>j</code>,
only one
MARPA_EVENT_SYMBOL_NULLED event instance for <code>sym</code>
will be triggered at location <code>j</code>.
</p>
<p>To declare an nulled symbol event,
use the recognizer&rsquo;s
<code>marpa_g_symbol_is_nulled_event_set()</code>
method.
See <a href="#marpa_005fg_005fsymbol_005fis_005fnulled_005fevent_005fset">marpa_g_symbol_is_nulled_event_set</a>.
To activate or deactivate a nulled symbol event,
use the
<code>marpa_g_nulled_symbol_activate</code> method
(see <a href="#marpa_005fg_005fnulled_005fsymbol_005factivate">marpa_g_nulled_symbol_activate</a>),
or the
<code>marpa_r_nulled_symbol_activate</code> method
(see <a href="#marpa_005fr_005fnulled_005fsymbol_005factivate">marpa_r_nulled_symbol_activate</a>).
</p>
<p><strong>Event value</strong>: The ID of the nulled symbol.
<strong>Suggested message</strong>: &quot;Symbol was nulled&quot;.
</p></dd></dl>

<a name="MARPA_005fEVENT_005fSYMBOL_005fPREDICTED"></a><dl>
<dt><a name="index-MARPA_005fEVENT_005fSYMBOL_005fPREDICTED"></a>Accessor macro: <em>int</em> <strong>MARPA_EVENT_SYMBOL_PREDICTED</strong></dt>
<dd><p>This is an explicit per-symbol event.
Intuitively,
this event triggers when a symbol is predicted.
Unlike the
<code>MARPA_EVENT_SYMBOL_EXPECTED</code> event,
the <code>MARPA_EVENT_SYMBOL_PREDICTED</code> event
triggers for predictions of both
non-terminals and terminals.
</p>
<p>More precisely,
when an Earley set is completed at earleme <code>j</code>,
the MARPA_EVENT_SYMBOL_PREDICTED event instance
for symbol <code>sym</code>
triggers iff
</p><ul>
<li> the event subtype of
MARPA_EVENT_SYMBOL_PREDICTED for <code>sym</code>
is activated; and
</li><li> the Earley set at earleme <code>j</code> contains an Earley item
whose postdot symbol is <code>sym</code>.
</li></ul>
<p>This event is triggered by the
<code>marpa_r_earleme_complete()</code>
(see <a href="#marpa_005fr_005fearleme_005fcomplete">marpa_r_earleme_complete</a>)
and
<code>marpa_r_start_input()</code>
(see <a href="#marpa_005fr_005fstart_005finput">marpa_r_start_input</a>)
methods.
</p>
<p>In an Earley set,
multiple Earley items may have the same
postdot symbol,
but they will trigger only one event instance.
For example, if
</p><div class="display">
<pre class="display">    <code>[ [ X ::= B &bull; X ], 0, 42 ]</code> and
    <code>[ [ Y ::= C &bull; X ], 7, 42 ]</code>
</pre></div>
<p>are Earley items,
they will trigger only one event instance &mdash;
the <code>MARPA_EVENT_SYMBOL_PREDICTED</code> event instance at location 42
with symbol <code>X</code>.
</p>
<p>To declare a predicted symbol event,
use the recognizer&rsquo;s
<code>marpa_g_symbol_is_prediction_event_set()</code>
method.
See <a href="#marpa_005fg_005fsymbol_005fis_005fprediction_005fevent_005fset">marpa_g_symbol_is_prediction_event_set</a>.
To activate or deactivate a predicted symbol event,
use the
<code>marpa_g_prediction_symbol_activate</code> method
(see <a href="#marpa_005fg_005fprediction_005fsymbol_005factivate">marpa_g_prediction_symbol_activate</a>),
or the
<code>marpa_r_prediction_symbol_activate</code> method
(see <a href="#marpa_005fr_005fprediction_005fsymbol_005factivate">marpa_r_prediction_symbol_activate</a>).
</p>
<p><strong>Event value</strong>: The ID of the predicted symbol.
<strong>Suggested message</strong>: &quot;Symbol was predicted&quot;.
</p></dd></dl>

<hr>
<a name="Basic-event-accessors"></a>
<div class="header">
<p>
Next: <a href="#Completion-events" accesskey="n" rel="next">Completion events</a>, Previous: <a href="#Event-codes" accesskey="p" rel="prev">Event codes</a>, Up: <a href="#Events" accesskey="u" rel="up">Events</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Basic-event-accessors-1"></a>
<h3 class="section">25.3 Basic event accessors</h3>

<a name="marpa_005fg_005fevent"></a><dl>
<dt><a name="index-marpa_005fg_005fevent"></a>Accessor function: <em>Marpa_Event_Type</em> <strong>marpa_g_event</strong> <em>(Marpa_Grammar <var>g</var>,     Marpa_Event* <var>event</var>, int <var>ix</var>)</em></dt>
<dd>
<p>On success,
</p><ul>
<li> the type of the <var>ix</var>&rsquo;th event is returned, and
</li><li> the data for the <var>ix</var>&rsquo;th event is placed
in the location pointed to by <var>event</var>.
</li></ul>

<p>Event indexes are in sequence.
Valid events will be in the range from 0 to <var>n</var>,
where <var>n</var> is one less than the event count.
The event count
can be read using the
<code>marpa_g_event_count()</code>
method.
</p>
<p>Hard fails if
there is no <var>ix</var>&rsquo;th event,
or if <var>ix</var> is negative.
On failure,
the locations pointed to by <var>event</var>
are not changed.
</p>
<p><strong>Return value</strong>:
On success, the type of event <var>ix</var>,
which is always non-negative.
On hard failure, -2.
</p></dd></dl>

<a name="marpa_005fg_005fevent_005fcount"></a><dl>
<dt><a name="index-marpa_005fg_005fevent_005fcount"></a>Accessor function: <em>int</em> <strong>marpa_g_event_count</strong> <em>( Marpa_Grammar g )</em></dt>
<dd>
<p><strong>Return value</strong>:
On success, the number of events, which is always non-negative.
On hard failure, -2.
</p></dd></dl>

<a name="marpa_005fg_005fevent_005fvalue"></a><dl>
<dt><a name="index-marpa_005fg_005fevent_005fvalue"></a>Accessor macro: <em>int</em> <strong>marpa_g_event_value</strong> <em>(Marpa_Event* <var>event</var>)</em></dt>
<dd><p>Returns the &ldquo;value&rdquo; of the event.
The semantics of the value varies according to the type
of the event, and is described in the section on event
codes.
See <a href="#Event-codes">Event codes</a>.
</p>
<p><strong>Return value</strong>: The &ldquo;value&rdquo; of the event.
Always succeeds.
</p></dd></dl>

<hr>
<a name="Completion-events"></a>
<div class="header">
<p>
Next: <a href="#Symbol-nulled-events" accesskey="n" rel="next">Symbol nulled events</a>, Previous: <a href="#Basic-event-accessors" accesskey="p" rel="prev">Basic event accessors</a>, Up: <a href="#Events" accesskey="u" rel="up">Events</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Completion-events-1"></a>
<h3 class="section">25.4 Completion events</h3>

<p>This section contains methods
for dealing with MARPA_EVENT_SYMBOL_COMPLETED
events.
See <a href="#MARPA_005fEVENT_005fSYMBOL_005fCOMPLETED">MARPA_EVENT_SYMBOL_COMPLETED</a>.
</p>
<p>To declare a symbol as a completion event symbol
use the <code>marpa_g_symbol_is_completion_event_set()</code>
method.
The event will be activated by default.
</p>
<p>To activate or deactivate a completion symbol event
use the <code>marpa_r_completion_symbol_activate()</code>
method.
</p>
<a name="marpa_005fg_005fcompletion_005fsymbol_005factivate"></a><dl>
<dt><a name="index-marpa_005fg_005fcompletion_005fsymbol_005factivate"></a>Mutator function: <em>int</em> <strong>marpa_g_completion_symbol_activate</strong> <em>(   Marpa_Grammar <var>g</var>,   Marpa_Symbol_ID <var>sym_id</var>,   int <var>reactivate</var> )</em></dt>
<dd>
<p>Allows the user to deactivate and reactivate symbol completion
events in the grammar.
On success, does the following:
</p><ul>
<li> If <var>reactivate</var> is zero, deactivates the event in the grammar.
</li><li> If <var>reactivate</var> is one, activates the event in the grammar.
</li></ul>

<p>The activation status of a completion event in the grammar becomes the initial
activation status of a completion event in all of its child recognizers.
</p>
<p>This method is seldom needed.
When a symbol is declared as a completion event symbol in
the grammar,
it is activated by default.
See <a href="#marpa_005fg_005fsymbol_005fis_005fcompletion_005fevent_005fset">marpa_g_symbol_is_completion_event_set()</a>.
And a completion event can be deactivated
and reactivated in the recognizer
using the
<code>marpa_r_completion_symbol_activate</code> method.
See <a href="#marpa_005fr_005fcompletion_005fsymbol_005factivate">marpa_r_completion_symbol_activate()</a>.
</p>
<p>Hard fails
if the <var>sym_id</var> is not declared as a completion event symbol
in the grammar,
or if the grammar has not been precomputed.
</p>
<p><strong>Return value</strong>:
On success, the value of <var>reactivate</var>, which is a boolean.
On hard failure, -2.
</p></dd></dl>

<a name="marpa_005fr_005fcompletion_005fsymbol_005factivate"></a><dl>
<dt><a name="index-marpa_005fr_005fcompletion_005fsymbol_005factivate"></a>Mutator function: <em>int</em> <strong>marpa_r_completion_symbol_activate</strong> <em>(   Marpa_Recognizer <var>r</var>,   Marpa_Symbol_ID <var>sym_id</var>,   int <var>reactivate</var> )</em></dt>
<dd>
<p>Allows the user to deactivate and reactivate symbol completion
events in the recognizer.
On success, does the following:
</p><ul>
<li> If <var>reactivate</var> is zero, deactivates the event in the recognizer.
</li><li> If <var>reactivate</var> is one, activates the event in the recognizer.
</li></ul>

<p>Hard fails if
<var>sym_id</var> was not declared for completion events in the base grammar.
</p>
<p><strong>Return value</strong>:
On success, the value of <var>reactivate</var>, which is a boolean.
On hard failure, -2.
</p></dd></dl>

<a name="marpa_005fg_005fsymbol_005fis_005fcompletion_005fevent"></a><dl>
<dt><a name="index-marpa_005fg_005fsymbol_005fis_005fcompletion_005fevent"></a>Accessor function: <em>int</em> <strong>marpa_g_symbol_is_completion_event</strong> <em>(     Marpa_Grammar <var>g</var>,     Marpa_Symbol_ID <var>sym_id</var>)</em></dt>
<dd>
<p>On success, returns a boolean which is 1 iff <var>sym_id</var> is declared
as a completion event symbol in <var>g</var>.
For more about completion events,
see <a href="#marpa_005fg_005fsymbol_005fis_005fcompletion_005fevent_005fset">marpa_g_symbol_is_completion_event_set()</a>.
</p>
<p>Soft fails iff <var>sym_id</var> is well-formed (a non-negative integer), but there is no
such symbol.
</p>
<p>Hard fails if <var>g</var> is precomputed.
</p>
<p><strong>Return value</strong>:
On success, a boolean .
On soft failure, -1.
On hard failure, -2.
</p></dd></dl>

<a name="marpa_005fg_005fsymbol_005fis_005fcompletion_005fevent_005fset"></a><dl>
<dt><a name="index-marpa_005fg_005fsymbol_005fis_005fcompletion_005fevent_005fset"></a>Mutator function: <em>int</em> <strong>marpa_g_symbol_is_completion_event_set</strong> <em>(     Marpa_Grammar <var>g</var>,     Marpa_Symbol_ID <var>sym_id</var>,  int <var>value</var>)</em></dt>
<dd>
<p>On success, if <var>value</var> is 1,
</p><ul>
<li> declares symbol <var>sym_id</var> as a completion event symbol,
</li><li> activates the completion event for <var>sym_id</var> in <var>g</var>, and
</li><li> returns 1.
</li></ul>

<p>On success, if <var>value</var> is 0,
</p><ul>
<li> declares symbol <var>sym_id</var> as a completion event symbol,
</li><li> deactivates the completion event for <var>sym_id</var> in <var>g</var>, and
</li><li> returns 0.
</li></ul>

<p>Nulled rules and symbols will never cause completion events.
Nullable symbols
may be declared as completion event symbols,
but this will have an effect only when the symbol
is not nulled.
Nulling symbols
may be declared as completion event symbols,
but no completion events will ever be triggered
for a nulling symbol.
Note that this implies that no completion event will
ever be triggered at earleme 0,
the start of parsing.
</p>
<p>Soft fails iff <var>sym_id</var> is well-formed (a non-negative integer), but there is no
such symbol.
</p>
<p>Hards fails if
the grammar is precomputed.
</p>
<p><strong>Return value</strong>:
On success, <var>value</var>, which is a boolean.
On soft failure, -1.
On hard failure, -2.
</p></dd></dl>

<hr>
<a name="Symbol-nulled-events"></a>
<div class="header">
<p>
Next: <a href="#Prediction-events" accesskey="n" rel="next">Prediction events</a>, Previous: <a href="#Completion-events" accesskey="p" rel="prev">Completion events</a>, Up: <a href="#Events" accesskey="u" rel="up">Events</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Symbol-nulled-events-1"></a>
<h3 class="section">25.5 Symbol nulled events</h3>

<p>This section contains methods
for dealing with MARPA_EVENT_SYMBOL_NULLED
events.
See <a href="#MARPA_005fEVENT_005fSYMBOL_005fNULLED">MARPA_EVENT_SYMBOL_NULLED</a>.
</p>
<p>To declare a symbol as a nulled event symbol
use the <code>marpa_g_symbol_is_nulled_event_set()</code>
method.
The event will be activated by default.
</p>
<p>To activate or deactivate a nulled symbol event
use the <code>marpa_r_nulled_symbol_activate()</code>
method.
</p>
<a name="marpa_005fg_005fnulled_005fsymbol_005factivate"></a><dl>
<dt><a name="index-marpa_005fg_005fnulled_005fsymbol_005factivate"></a>Mutator function: <em>int</em> <strong>marpa_g_nulled_symbol_activate</strong> <em>(   Marpa_Grammar <var>g</var>,   Marpa_Symbol_ID <var>sym_id</var>,   int <var>reactivate</var> )</em></dt>
<dd>
<p>Allows the user to deactivate and reactivate symbol nulled
events in the grammar.
On success, does the following:
</p><ul>
<li> If <var>reactivate</var> is zero, deactivates the event in the grammar.
</li><li> If <var>reactivate</var> is one, activates the event in the grammar.
</li></ul>

<p>The activation status of a nulled event in the grammar becomes the initial
activation status of a nulled event in all of its child recognizers.
</p>
<p>This method is seldom needed.
When a symbol is declared as a nulled event symbol in
the grammar,
it is activated by default.
See <a href="#marpa_005fg_005fsymbol_005fis_005fnulled_005fevent_005fset">marpa_g_symbol_is_nulled_event_set()</a>.
And a nulled event can be deactivated
and reactivated in the recognizer
using the
<code>marpa_r_nulled_symbol_activate</code> method.
See <a href="#marpa_005fr_005fnulled_005fsymbol_005factivate">marpa_r_nulled_symbol_activate()</a>.
</p>
<p>Hard fails
if the <var>sym_id</var> is not declared as a nulled event symbol
in the grammar,
or if the grammar has not been precomputed.
</p>
<p><strong>Return value</strong>:
On success, the value of <var>reactivate</var>, which is a boolean.
On hard failure, -2.
</p></dd></dl>

<a name="marpa_005fr_005fnulled_005fsymbol_005factivate"></a><dl>
<dt><a name="index-marpa_005fr_005fnulled_005fsymbol_005factivate"></a>Mutator function: <em>int</em> <strong>marpa_r_nulled_symbol_activate</strong> <em>(   Marpa_Recognizer <var>r</var>,   Marpa_Symbol_ID <var>sym_id</var>,   int <var>boolean</var> )</em></dt>
<dd>
<p>Allows the user to deactivate and reactivate symbol nulled
events in the recognizer.
On success, does the following:
</p><ul>
<li> If <var>reactivate</var> is zero, deactivates the event in the recognizer.
</li><li> If <var>reactivate</var> is one, activates the event in the recognizer.
</li></ul>

<p>Hard fails if
the subtype <var>sym_id</var> of
the <code>MARPA_EVENT_SYMBOL_NULLED</code> event
is not declared.
</p>
<p><strong>Return value</strong>:
On success, the value of <var>reactivate</var>, which is a boolean.
On hard failure, -2.
</p></dd></dl>

<a name="marpa_005fg_005fsymbol_005fis_005fnulled_005fevent"></a><dl>
<dt><a name="index-marpa_005fg_005fsymbol_005fis_005fnulled_005fevent"></a>Accessor function: <em>int</em> <strong>marpa_g_symbol_is_nulled_event</strong> <em>(     Marpa_Grammar <var>g</var>,     Marpa_Symbol_ID <var>sym_id</var>)</em></dt>
<dd>
<p>On success, returns a boolean which is 1 iff the subtype <var>sym_id</var>
of the <code>MARPA_EVENT_SYMBOL_NULLED</code> event
is declared.
For more about nulled events,
see <a href="#marpa_005fg_005fsymbol_005fis_005fnulled_005fevent_005fset">marpa_g_symbol_is_nulled_event_set</a>.
</p>
<p>Soft fails iff <var>sym_id</var> is well-formed (a non-negative integer), but there is no
such symbol.
</p>
<p>Hard fails if <var>g</var> is precomputed.
</p>
<p><strong>Return value</strong>:
On success, a boolean .
On soft failure, -1.
On hard failure, -2.
</p></dd></dl>

<a name="marpa_005fg_005fsymbol_005fis_005fnulled_005fevent_005fset"></a><dl>
<dt><a name="index-marpa_005fg_005fsymbol_005fis_005fnulled_005fevent_005fset"></a>Mutator function: <em>int</em> <strong>marpa_g_symbol_is_nulled_event_set</strong> <em>(     Marpa_Grammar <var>g</var>,     Marpa_Symbol_ID <var>sym_id</var>,  int <var>value</var>)</em></dt>
<dd>
<p>On success, if <var>value</var> is 1,
</p><ul>
<li> declares symbol <var>sym_id</var> as a nulled event symbol,
</li><li> activates the nulled event for <var>sym_id</var> in <var>g</var>, and
</li><li> returns 1.
</li></ul>

<p>On success, if <var>value</var> is 0,
</p><ul>
<li> declares symbol <var>sym_id</var> as a nulled event symbol,
</li><li> deactivates the nulled event for <var>sym_id</var> in <var>g</var>, and
</li><li> returns 0.
</li></ul>

<p>The
<code>marpa_g_symbol_is_nulled_event_set()</code>
method will
declare a symbol as a nulled event symbol,
even if the symbol is non-nullable.
This is convenient, for example,
for automatically generated grammars.
Applications that wish to treat
it as a failure when
a non-nullable symbol is declared
as a nulled event symbol,
can check for this after precomputation,
using the
<code>marpa_g_symbol_is_nulled_event()</code> and
<code>marpa_g_symbol_is_nullable()</code>
methods.
</p>
<p>Soft fails iff <var>sym_id</var> is well-formed (a non-negative integer), but there is no
such symbol.
</p>
<p>Hards fails if
the grammar is precomputed.
</p>
<p><strong>Return value</strong>:
On success, <var>value</var>, which is a boolean.
On soft failure, -1.
On hard failure, -2.
</p></dd></dl>

<hr>
<a name="Prediction-events"></a>
<div class="header">
<p>
Next: <a href="#Symbol-expected-events" accesskey="n" rel="next">Symbol expected events</a>, Previous: <a href="#Symbol-nulled-events" accesskey="p" rel="prev">Symbol nulled events</a>, Up: <a href="#Events" accesskey="u" rel="up">Events</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Prediction-events-1"></a>
<h3 class="section">25.6 Prediction events</h3>

<p>This section contains methods
for dealing with MARPA_EVENT_SYMBOL_PREDICTED
events.
See <a href="#MARPA_005fEVENT_005fSYMBOL_005fPREDICTED">MARPA_EVENT_SYMBOL_PREDICTED</a>.
</p>
<p>To declare a symbol as a prediction event symbol
use the <code>marpa_g_symbol_is_prediction_event_set()</code>
method.
The event will be activated by default.
</p>
<p>To activate or deactivate a prediction symbol event
use the <code>marpa_r_prediction_symbol_activate()</code>
method.
</p>
<a name="marpa_005fg_005fprediction_005fsymbol_005factivate"></a><dl>
<dt><a name="index-marpa_005fg_005fprediction_005fsymbol_005factivate"></a>Mutator function: <em>int</em> <strong>marpa_g_prediction_symbol_activate</strong> <em>(   Marpa_Grammar <var>g</var>,   Marpa_Symbol_ID <var>sym_id</var>,   int <var>reactivate</var> )</em></dt>
<dd>
<p>Allows the user to deactivate and reactivate symbol prediction
events in the grammar.
On success, does the following:
</p><ul>
<li> If <var>reactivate</var> is zero, deactivates the event in the grammar.
</li><li> If <var>reactivate</var> is one, activates the event in the grammar.
</li></ul>

<p>The activation status of a prediction event in the grammar becomes the initial
activation status of a prediction event in all of its child recognizers.
</p>
<p>This method is seldom needed.
When a symbol is declared as a prediction event symbol in
the grammar,
it is activated by default.
See <a href="#marpa_005fg_005fsymbol_005fis_005fprediction_005fevent_005fset">marpa_g_symbol_is_prediction_event_set()</a>.
And a prediction event can be deactivated
and reactivated in the recognizer
using the
<code>marpa_r_prediction_symbol_activate</code> method.
See <a href="#marpa_005fr_005fprediction_005fsymbol_005factivate">marpa_r_prediction_symbol_activate()</a>.
</p>
<p>Hard fails
if the <var>sym_id</var> is not declared as a prediction event symbol
in the grammar,
or if the grammar has not been precomputed.
</p>
<p><strong>Return value</strong>:
On success, the value of <var>reactivate</var>, which is a boolean.
On hard failure, -2.
</p></dd></dl>

<a name="marpa_005fr_005fprediction_005fsymbol_005factivate"></a><dl>
<dt><a name="index-marpa_005fr_005fprediction_005fsymbol_005factivate"></a>Mutator function: <em>int</em> <strong>marpa_r_prediction_symbol_activate</strong> <em>(   Marpa_Recognizer <var>r</var>,   Marpa_Symbol_ID <var>sym_id</var>,   int <var>boolean</var> )</em></dt>
<dd>
<p>Allows the user to deactivate and reactivate symbol prediction
events in the recognizer.
On success, does the following:
</p><ul>
<li> If <var>reactivate</var> is zero, deactivates the event in the recognizer.
</li><li> If <var>reactivate</var> is one, activates the event in the recognizer.
</li></ul>

<p>Hard fails if
<var>sym_id</var> was not declared for prediction events in the base grammar.
</p>
<p><strong>Return value</strong>:
On success, the value of <var>reactivate</var>, which is a boolean.
On hard failure, -2.
</p></dd></dl>

<a name="marpa_005fg_005fsymbol_005fis_005fprediction_005fevent"></a><dl>
<dt><a name="index-marpa_005fg_005fsymbol_005fis_005fprediction_005fevent"></a>Accessor function: <em>int</em> <strong>marpa_g_symbol_is_prediction_event</strong> <em>(     Marpa_Grammar <var>g</var>,     Marpa_Symbol_ID <var>sym_id</var>)</em></dt>
<dd>
<p>On success, returns a boolean which is 1 iff <var>sym_id</var> is declared
as a prediction event symbol.
For more about prediction events,
see <a href="#marpa_005fg_005fsymbol_005fis_005fprediction_005fevent_005fset">marpa_g_symbol_is_prediction_event_set</a>.
</p>
<p>Soft fails iff <var>sym_id</var> is well-formed (a non-negative integer), but there is no
such symbol.
</p>
<p>Hard fails if <var>g</var> is precomputed.
</p>
<p><strong>Return value</strong>:
On success, a boolean .
On soft failure, -1.
On hard failure, -2.
</p>
</dd></dl>

<a name="marpa_005fg_005fsymbol_005fis_005fprediction_005fevent_005fset"></a><dl>
<dt><a name="index-marpa_005fg_005fsymbol_005fis_005fprediction_005fevent_005fset"></a>Mutator function: <em>int</em> <strong>marpa_g_symbol_is_prediction_event_set</strong> <em>(     Marpa_Grammar <var>g</var>,     Marpa_Symbol_ID <var>sym_id</var>,  int <var>value</var>)</em></dt>
<dd>
<p>On success, if <var>value</var> is 1,
</p><ul>
<li> declares symbol <var>sym_id</var> as a prediction event symbol,
</li><li> activates the prediction event for <var>sym_id</var> in <var>g</var>, and
</li><li> returns 1.
</li></ul>

<p>On success, if <var>value</var> is 0,
</p><ul>
<li> declares symbol <var>sym_id</var> as a prediction event symbol,
</li><li> deactivates the prediction event for <var>sym_id</var> in <var>g</var>, and
</li><li> returns 0.
</li></ul>

<p>Soft fails iff <var>sym_id</var> is well-formed (a non-negative integer), but there is no
such symbol.
</p>
<p>Hards fails if
the grammar is precomputed.
</p>
<p><strong>Return value</strong>:
On success, <var>value</var>, which is a boolean.
On soft failure, -1.
On hard failure, -2.
</p></dd></dl>

<hr>
<a name="Symbol-expected-events"></a>
<div class="header">
<p>
Next: <a href="#Recognizer-per_002dsymbol-events" accesskey="n" rel="next">Recognizer per-symbol events</a>, Previous: <a href="#Prediction-events" accesskey="p" rel="prev">Prediction events</a>, Up: <a href="#Events" accesskey="u" rel="up">Events</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Symbol-expected-events-1"></a>
<h3 class="section">25.7 Symbol expected events</h3>

<p>This section contains methods
for dealing with MARPA_EVENT_SYMBOL_EXPECTED
events.
See <a href="#MARPA_005fEVENT_005fSYMBOL_005fEXPECTED">MARPA_EVENT_SYMBOL_EXPECTED</a>.
</p>
<a name="marpa_005fr_005fexpected_005fsymbol_005fevent_005fset"></a><dl>
<dt><a name="index-marpa_005fr_005fexpected_005fsymbol_005fevent_005fset"></a>Mutator function: <em>int</em> <strong>marpa_r_expected_symbol_event_set</strong> <em>(   Marpa_Recognizer <var>r</var>,   Marpa_Symbol_ID <var>symbol_id</var>,   int <var>value</var>)</em></dt>
<dd>
<p>On success, if <var>value</var> is 1, does the following:
</p><ul>
<li> Declares
the symbol expected event for
the symbol with ID <var>symbol_id</var>,
if it is not already declared.
</li><li> Activates the symbol expected event for
the symbol with ID <var>symbol_id</var>.
</li><li> Returns 1.
</li></ul>

<p>On success, if <var>value</var> is 0, does the following:
</p><ul>
<li> Deactivates the symbol expected event for
the symbol with ID <var>symbol_id</var>.
</li><li> Returns 0.
</li></ul>

<p>Expected symbol events only trigger if
the symbol with ID <var>symbol_id</var> is expected as terminal.
This method will succeed if
the symbol with ID <var>symbol_id</var> is not a terminal,
but the event subtype
that this method declared will never trigger.
</p>
<p>The same symbol may be acceptable as both a
terminal and a non-terminal if the
deprecated LHS terminals feature is in use.
If the symbol with ID <var>symbol_id</var> is expected
at the current earleme
as a non-terminal,
but is not acceptable as a terminal,
an expected symbol event will not be triggered
at the current earleme.
See <a href="#LHS-terminals">LHS terminals</a>.
</p>
<p>Hard fails if <var>value</var> is not a boolean.
Hard fails if <var>value</var> is 1,
and <var>symbol_id</var> is the ID of a nulling symbol,
an inaccessible symbol,
or an unproductive symbol.
Hard fails if <var>symbol_id</var> is not the ID of a valid symbol.
</p>
<p><strong>Return value</strong>:
On success, <var>value</var>, which will be a boolean.
On hard failure,
-2.
</p></dd></dl>

<hr>
<a name="Recognizer-per_002dsymbol-events"></a>
<div class="header">
<p>
Next: <a href="#Tentative-events" accesskey="n" rel="next">Tentative events</a>, Previous: <a href="#Symbol-expected-events" accesskey="p" rel="prev">Symbol expected events</a>, Up: <a href="#Events" accesskey="u" rel="up">Events</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Recognizer-per_002dsymbol-events-1"></a>
<h3 class="section">25.8 Recognizer per-symbol events</h3>

<p>The
<a name="index-events_002c-recognizer-per_002dsymbol"></a>
<a name="index-recognizer-per_002dsymbol-events"></a>
<em>recognizer per-symbol events</em>
are those which
trigger in the recognizer,
and which are per-symbol.
All recognizer per-symbol event instances are triggered by the
<code>marpa_r_earleme_complete()</code>
(see <a href="#marpa_005fr_005fearleme_005fcomplete">marpa_r_earleme_complete</a>)
or
<code>marpa_r_start_input()</code>
(see <a href="#marpa_005fr_005fstart_005finput">marpa_r_start_input</a>)
methods.
Recognizer per-symbol events have one
of the event types
<code>MARPA_EVENT_SYMBOL_COMPLETED</code>,
<code>MARPA_EVENT_SYMBOL_EXPECTED</code>,
<code>MARPA_EVENT_SYMBOL_NULLED</code>, and
<code>MARPA_EVENT_SYMBOL_PREDICTED</code>.
</p>
<hr>
<a name="Tentative-events"></a>
<div class="header">
<p>
Next: <a href="#Ambiguous-parses-and-events" accesskey="n" rel="next">Ambiguous parses and events</a>, Previous: <a href="#Recognizer-per_002dsymbol-events" accesskey="p" rel="prev">Recognizer per-symbol events</a>, Up: <a href="#Events" accesskey="u" rel="up">Events</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Tentative-events-1"></a>
<h3 class="section">25.9 Tentative events</h3>

<p>Recognizer per-symbol events are tentative.
The symbol instance that triggers them may not actually occur
in the parse.
</p>
<p>Right of the location of the event,
Libmarpa is totally unaware of what the actual input will be
&mdash; there is no
&quot;lookahead&quot;.
Therefore, if end location of the symbol instance for the event
is after the triggering parse location,
the symbol instance will reflect a <strong>possible</strong> input,
usually one of many <strong>possible</strong> inputs.
Of these possible outputs,
only one will become the actual output,
and that only if the parse is allowed to run that far.
</p>
<hr>
<a name="Ambiguous-parses-and-events"></a>
<div class="header">
<p>
Next: <a href="#Nulled-subtrees-and-events" accesskey="n" rel="next">Nulled subtrees and events</a>, Previous: <a href="#Tentative-events" accesskey="p" rel="prev">Tentative events</a>, Up: <a href="#Events" accesskey="u" rel="up">Events</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Ambiguous-parses-and-events-1"></a>
<h3 class="section">25.10 Ambiguous parses and events</h3>

<p>In an ambiguous parse,
tentative events
(see <a href="#Tentative-events">Tentative events</a>)
trigger for all of the parse trees.
User thinking in terms of only one of the parse trees,
perhaps because they are unaware of the
ambiguity, will sometimes find this unexpected.
</p>
<hr>
<a name="Nulled-subtrees-and-events"></a>
<div class="header">
<p>
Next: <a href="#Event-coincidence-of-symbol-instances" accesskey="n" rel="next">Event coincidence of symbol instances</a>, Previous: <a href="#Ambiguous-parses-and-events" accesskey="p" rel="prev">Ambiguous parses and events</a>, Up: <a href="#Events" accesskey="u" rel="up">Events</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Nulled-subtrees-and-events-1"></a>
<h3 class="section">25.11 Nulled subtrees and events</h3>

<p>As mentioned above
(see <a href="#Nullability-in-the-valuator">Nullability in the valuator</a>),
nulled subforests are,
for evaluation purposes,
pruned back to their topmost symbol.
This is <strong>not</strong> the case for events.
Events for every nulled symbol in the subforest
will trigger,
even if these symbols are pruned in the evaluation phase.
More precisely,
if
</p><ul>
<li> <code>X</code>@<code>j</code>-<code>j</code> is a nulled symbol instance,
</li><li> <code>X</code>@<code>j</code>-<code>j</code> derives
<code>Y</code>@<code>j</code>-<code>j</code>
(in which case <code>Y</code>@<code>j</code>-<code>j</code>
must also be a nulled symbol instance), and
</li><li> the event
<code>MARPA_EVENT_SYMBOL_NULLED</code> for symbol <code>Y</code>
is activated,
</li></ul>
<p>then
a <code>MARPA_EVENT_SYMBOL_NULLED</code> for symbol <code>Y</code>
will trigger at parse location <code>j</code>.
</p>
<hr>
<a name="Event-coincidence-of-symbol-instances"></a>
<div class="header">
<p>
Next: <a href="#Event-coincidence-of-symbols" accesskey="n" rel="next">Event coincidence of symbols</a>, Previous: <a href="#Nulled-subtrees-and-events" accesskey="p" rel="prev">Nulled subtrees and events</a>, Up: <a href="#Events" accesskey="u" rel="up">Events</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Event-coincidence-of-symbol-instances-1"></a>
<h3 class="section">25.12 Event coincidence of symbol instances</h3>

<p>We say that two event instances &ldquo;coincide&rdquo;
if they occur at the same parse location.
We say the two event instances are
<em>coincident same-symbol-instance event instances</em>
iff both event instances trigger at the same parse location
and both event instances are for the same symbol instance.
Since every event triggered by a single
symbol instance will be for the same symbol,
coincident events triggered by a single
symbol instance can differ only in their event type.
This event type will always be one of the
recognizer per-symbol events.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Nulled-and-completed-symbol-instances" accesskey="1">Nulled and completed symbol instances</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Nulled-and-predicted-symbol-instances" accesskey="2">Nulled and predicted symbol instances</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Nulled-and-expected-symbol-instances" accesskey="3">Nulled and expected symbol instances</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Completed-and-predicted-symbol-instances" accesskey="4">Completed and predicted symbol instances</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Completed-and-expected-symbol-instances" accesskey="5">Completed and expected symbol instances</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Predicted-and-expected-symbol-instances" accesskey="6">Predicted and expected symbol instances</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Nulled-and-completed-symbol-instances"></a>
<div class="header">
<p>
Next: <a href="#Nulled-and-predicted-symbol-instances" accesskey="n" rel="next">Nulled and predicted symbol instances</a>, Previous: <a href="#Event-coincidence-of-symbol-instances" accesskey="p" rel="prev">Event coincidence of symbol instances</a>, Up: <a href="#Event-coincidence-of-symbol-instances" accesskey="u" rel="up">Event coincidence of symbol instances</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Nulled-and-completed-symbol-instances-1"></a>
<h4 class="subsection">25.12.1 Nulled and completed symbol instances</h4>

<p>A symbol instance cannot trigger both
a <code>MARPA_EVENT_SYMBOL_NULLED</code>
and a <code>MARPA_EVENT_SYMBOL_COMPLETED</code> event
at the same location.
This is because a symbol instance must be zero-length
to trigger a <code>MARPA_EVENT_SYMBOL_NULLED</code> event,
but must be of non-zero length
to trigger a
<code>MARPA_EVENT_SYMBOL_COMPLETED</code>
event.
That is, if the symbol instance is
<code>sym</code>@<code>start</code>-<code>end</code>,
a <code>MARPA_EVENT_SYMBOL_NULLED</code> event can trigger only
if <code>start=end</code>,
while the
<code>MARPA_EVENT_SYMBOL_COMPLETED</code>
event
can trigger
only if <code>start &lt; end</code>.
</p>
<hr>
<a name="Nulled-and-predicted-symbol-instances"></a>
<div class="header">
<p>
Next: <a href="#Nulled-and-expected-symbol-instances" accesskey="n" rel="next">Nulled and expected symbol instances</a>, Previous: <a href="#Nulled-and-completed-symbol-instances" accesskey="p" rel="prev">Nulled and completed symbol instances</a>, Up: <a href="#Event-coincidence-of-symbol-instances" accesskey="u" rel="up">Event coincidence of symbol instances</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Nulled-and-predicted-symbol-instances-1"></a>
<h4 class="subsection">25.12.2 Nulled and predicted symbol instances</h4>

<p>A symbol instance cannot trigger both
a <code>MARPA_EVENT_SYMBOL_NULLED</code>
and a <code>MARPA_EVENT_SYMBOL_PREDICTED</code>
event at the same location.
This is because a symbol instance must be zero-length
to trigger a <code>MARPA_EVENT_SYMBOL_NULLED</code> event,
but only non-zero length symbols
will trigger a
<code>MARPA_EVENT_SYMBOL_PREDICTED</code>
event.
That is, if the symbol instance is
<code>sym</code>@<code>start</code>-<code>end</code>,
a <code>MARPA_EVENT_SYMBOL_NULLED</code> event can trigger only
if <code>start=end</code>,
while the
<code>MARPA_EVENT_SYMBOL_PREDICTED</code>
event
can trigger
only if <code>start &lt; end</code>.
</p>
<hr>
<a name="Nulled-and-expected-symbol-instances"></a>
<div class="header">
<p>
Next: <a href="#Completed-and-predicted-symbol-instances" accesskey="n" rel="next">Completed and predicted symbol instances</a>, Previous: <a href="#Nulled-and-predicted-symbol-instances" accesskey="p" rel="prev">Nulled and predicted symbol instances</a>, Up: <a href="#Event-coincidence-of-symbol-instances" accesskey="u" rel="up">Event coincidence of symbol instances</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Nulled-and-expected-symbol-instances-1"></a>
<h4 class="subsection">25.12.3 Nulled and expected symbol instances</h4>

<p>A symbol instance cannot trigger both
a <code>MARPA_EVENT_SYMBOL_NULLED</code>
and a <code>MARPA_EVENT_SYMBOL_EXPECTED</code>
event at the same location.
This is because a symbol instance must be zero-length
to trigger a <code>MARPA_EVENT_SYMBOL_NULLED</code> event,
but only terminal symbols
will trigger a
<code>MARPA_EVENT_SYMBOL_EXPECTED</code>
event,
and termnal symbols cannot be zero-length.
That is, if the symbol instance is
<code>sym</code>@<code>start</code>-<code>end</code>,
a <code>MARPA_EVENT_SYMBOL_NULLED</code> event will trigger only
if <code>start=end</code>,
while the
<code>MARPA_EVENT_SYMBOL_EXPECTED</code>
event
will trigger
only if <code>start &lt; end</code>.
</p>
<hr>
<a name="Completed-and-predicted-symbol-instances"></a>
<div class="header">
<p>
Next: <a href="#Completed-and-expected-symbol-instances" accesskey="n" rel="next">Completed and expected symbol instances</a>, Previous: <a href="#Nulled-and-expected-symbol-instances" accesskey="p" rel="prev">Nulled and expected symbol instances</a>, Up: <a href="#Event-coincidence-of-symbol-instances" accesskey="u" rel="up">Event coincidence of symbol instances</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Completed-and-predicted-symbol-instances-1"></a>
<h4 class="subsection">25.12.4 Completed and predicted symbol instances</h4>

<p>A symbol instance cannot trigger both
a <code>MARPA_EVENT_SYMBOL_COMPLETED</code>
and a <code>MARPA_EVENT_SYMBOL_PREDICTED</code>
event at the same location.
Call the location, <code>j</code>.
Coincident events with the types
<code>MARPA_EVENT_SYMBOL_COMPLETED</code>
and <code>MARPA_EVENT_SYMBOL_PREDICTED</code>
cannot be triggered by a single symbol instance
because the symbol instances
for <code>MARPA_EVENT_SYMBOL_COMPLETED</code>
and <code>MARPA_EVENT_SYMBOL_PREDICTED</code>
cannot be zero-length;
the symbol instance for the <code>MARPA_EVENT_SYMBOL_COMPLETED</code>
must end at <code>j</code>; and
the symbol instance for the <code>MARPA_EVENT_SYMBOL_PREDICTED</code>
must start at <code>j</code>.
That is, if the
<code>MARPA_EVENT_SYMBOL_COMPLETED</code> symbol instance is
<code>sym</code>@<code>c1</code>-<code>c2</code>
and the
<code>MARPA_EVENT_SYMBOL_PREDICTED</code> symbol instance is
<code>sym</code>@<code>p1</code>-<code>p2</code>
we must have all of
</p><ul>
<li> <code>c1&lt;c2</code>, because the length of
<code>MARPA_EVENT_SYMBOL_COMPLETED</code> symbol instance is non-zero;
</li><li> <code>c2=j</code>, because the
<code>MARPA_EVENT_SYMBOL_COMPLETED</code> symbol instance must end at
<code>j</code>; and
</li><li> <code>j=p1</code>, because the
<code>MARPA_EVENT_SYMBOL_PREDICTED</code> symbol instance must start at
<code>j</code>.
</li></ul>
<p>so that <code>c1 &lt; p1</code> and
the two instances
<code>sym</code>@<code>c1</code>-<code>c2</code> and
<code>sym</code>@<code>p1</code>-<code>p2</code>
must be distinct.
</p>
<hr>
<a name="Completed-and-expected-symbol-instances"></a>
<div class="header">
<p>
Next: <a href="#Predicted-and-expected-symbol-instances" accesskey="n" rel="next">Predicted and expected symbol instances</a>, Previous: <a href="#Completed-and-predicted-symbol-instances" accesskey="p" rel="prev">Completed and predicted symbol instances</a>, Up: <a href="#Event-coincidence-of-symbol-instances" accesskey="u" rel="up">Event coincidence of symbol instances</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Completed-and-expected-symbol-instances-1"></a>
<h4 class="subsection">25.12.5 Completed and expected symbol instances</h4>

<p>A symbol instance cannot trigger both
a <code>MARPA_EVENT_SYMBOL_COMPLETED</code>
and a <code>MARPA_EVENT_SYMBOL_EXPECTED</code>
event at the same location.
The reasoning is much the same as for the
case of <code>MARPA_EVENT_SYMBOL_COMPLETED</code>
and <code>MARPA_EVENT_SYMBOL_PREDICTED</code> events.
See <a href="#Completed-and-predicted-symbol-instances">Completed and predicted symbol instances</a>.
</p>
<p>Call the location, <code>j</code>.
Coincident events with the types
<code>MARPA_EVENT_SYMBOL_COMPLETED</code>
and <code>MARPA_EVENT_SYMBOL_PREDICTED</code>
cannot be triggered by a single symbol instance
because the symbol instances
for <code>MARPA_EVENT_SYMBOL_COMPLETED</code>
and <code>MARPA_EVENT_SYMBOL_EXPECTED</code>
cannot be zero-length;
the symbol instance for the <code>MARPA_EVENT_SYMBOL_COMPLETED</code>
must end at <code>j</code>; and
the symbol instance for the <code>MARPA_EVENT_SYMBOL_EXPECTED</code>
must start at <code>j</code>.
That is, if the
<code>MARPA_EVENT_SYMBOL_COMPLETED</code> symbol instance is
<code>sym</code>@<code>c1</code>-<code>c2</code>
and the
<code>MARPA_EVENT_SYMBOL_EXPECTED</code> symbol instance is
<code>sym</code>@<code>e1</code>-<code>e2</code>
we must have all of
</p><ul>
<li> <code>c1&lt;c2</code>, because the length of
<code>MARPA_EVENT_SYMBOL_COMPLETED</code> symbol instance is non-zero;
</li><li> <code>c2=j</code>, because the
<code>MARPA_EVENT_SYMBOL_COMPLETED</code> symbol instance must end at
<code>j</code>; and
</li><li> <code>j=e1</code>, because the
<code>MARPA_EVENT_SYMBOL_EXPECTED</code> symbol instance must start at
<code>j</code>.
</li></ul>
<p>so that <code>c1 &lt; e1</code> and
the two instances
<code>sym</code>@<code>c1</code>-<code>c2</code> and
<code>sym</code>@<code>e1</code>-<code>e2</code>
must be distinct.
</p>
<hr>
<a name="Predicted-and-expected-symbol-instances"></a>
<div class="header">
<p>
Previous: <a href="#Completed-and-expected-symbol-instances" accesskey="p" rel="prev">Completed and expected symbol instances</a>, Up: <a href="#Event-coincidence-of-symbol-instances" accesskey="u" rel="up">Event coincidence of symbol instances</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Predicted-and-expected-symbol-instances-1"></a>
<h4 class="subsection">25.12.6 Predicted and expected symbol instances</h4>

<p>The one case where a single symbol instance can trigger
events of two different types at the same parse location is
that of the <code>MARPA_EVENT_SYMBOL_PREDICTED</code>
and <code>MARPA_EVENT_SYMBOL_EXPECTED</code> events.
That is,
</p><ul>
<li> if <code>j</code> is a parse location;
</li><li> <code>sym</code> is the postdot symbol in an
Earley item in the Earley set at <code>j</code>;
</li><li> <code>sym</code> is a terminal; and
</li><li> both event subtypes are activated,
</li></ul>
<p>then both a
<code>MARPA_EVENT_SYMBOL_PREDICTED</code>
and a <code>MARPA_EVENT_SYMBOL_EXPECTED</code> event
will trigger at location <code>start</code>.
</p>
<hr>
<a name="Event-coincidence-of-symbols"></a>
<div class="header">
<p>
Next: <a href="#Marker-symbols" accesskey="n" rel="next">Marker symbols</a>, Previous: <a href="#Event-coincidence-of-symbol-instances" accesskey="p" rel="prev">Event coincidence of symbol instances</a>, Up: <a href="#Events" accesskey="u" rel="up">Events</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Event-coincidence-of-symbols-1"></a>
<h3 class="section">25.13 Event coincidence of symbols</h3>

<p>We say the two event instances are
<em>coincident same-symbol event instances</em>
iff both event instances trigger at the same parse location
and both event instances are for the same symbol.
Above (see <a href="#Event-coincidence-of-symbol-instances">Event coincidence of symbol instances</a>)
we looked at event instances which
trigger at the same parse location
and were for the same <strong>symbol instance</strong>.
In this section we have loosened the requirement,
so they events instances can be triggered by
multiple symbol instances,
as long as all the symbol instances
share the same symbol.
</p>
<p>Obviously every
coincident same-symbol event instance
is for the same symbol,
and therefore
coincident same-symbol event instances
can differ only in their event type.
This event type will always be one of the
recognizer per-symbol events.
</p>
<p>Same-symbol event instances can coincide
</p><ul>
<li> if one is of type <code>MARPA_EVENT_SYMBOL_PREDICTED</code> and
the other is of type <code>MARPA_EVENT_SYMBOL_COMPLETED</code>;
</li><li> if one of of type <code>MARPA_EVENT_SYMBOL_PREDICTED</code> and
the other is of type <code>MARPA_EVENT_SYMBOL_NULLED</code>;
</li><li> if one of of type <code>MARPA_EVENT_SYMBOL_COMPLETED</code> and
the other is of type <code>MARPA_EVENT_SYMBOL_NULLED</code>.
</li></ul>
<p>In fact, three same-symbol event instances can
coincide, where they are of types
<code>MARPA_EVENT_SYMBOL_PREDICTED</code>,
<code>MARPA_EVENT_SYMBOL_COMPLETED</code> and
<code>MARPA_EVENT_SYMBOL_NULLED</code>.
An example of the triggers for such a triple coincidence
is the set of symbol instances
<code>sym</code>@41-42,
<code>sym</code>@42-42, and
<code>sym</code>@42-43,
where
</p><ul>
<li> <code>sym</code>@41-42 can trigger
a <code>MARPA_EVENT_SYMBOL_COMPLETED</code> event
for symbol <code>sym</code> at parse location 42;
</li><li> <code>sym</code>@42-42 can trigger
a <code>MARPA_EVENT_SYMBOL_NULLED</code> event
for symbol <code>sym</code> at parse location 42;
</li><li> <code>sym</code>@42-43 can trigger
a <code>MARPA_EVENT_SYMBOL_PREDICTED</code> event
for symbol <code>sym</code> at parse location 42.
</li></ul>

<p>Earlier
(see <a href="#Predicted-and-expected-symbol-instances">Predicted and expected symbol instances</a>),
we saw that a single symbol instance
can trigger both
a <code>MARPA_EVENT_SYMBOL_EXPECTED</code> event instance and
a <code>MARPA_EVENT_SYMBOL_PREDICTED</code> event instance
at the same parse location.
Obviously then, the same symbol
can trigger
a <code>MARPA_EVENT_SYMBOL_EXPECTED</code> event instance and
a <code>MARPA_EVENT_SYMBOL_PREDICTED</code> event instance
at the same parse location.
</p>
<p>If the deprecated LHS terminals feature is not in use,
a <code>MARPA_EVENT_SYMBOL_EXPECTED</code> event instance and
a <code>MARPA_EVENT_SYMBOL_COMPLETED</code> event instance
cannot be same-symbol coincident.
This is because the symbol for the
<code>MARPA_EVENT_SYMBOL_COMPLETED</code> event instance
must be the LHS of a rule;
the symbol for the <code>MARPA_EVENT_SYMBOL_EXPECTED</code> event instance
must be a terminal;
and terminals cannot be the LHS of a rule.
Libmarpa has a feature that allows LHS terminals,
but use of this is strongly discouraged.
See <a href="#LHS-terminals">LHS terminals</a>.
</p>
<p>There are no circumstances under which
a <code>MARPA_EVENT_SYMBOL_EXPECTED</code> event instance and
a <code>MARPA_EVENT_SYMBOL_NULLED</code> event instance
can be same-symbol coincident.
This is because
the symbol for the <code>MARPA_EVENT_SYMBOL_NULLED</code> event instance
must be nulled;
the symbol for the <code>MARPA_EVENT_SYMBOL_EXPECTED</code> event instance
must be a terminal;
and terminals can never be nulled.
Not only can
a <code>MARPA_EVENT_SYMBOL_EXPECTED</code> event instance
not coincide with a same-symbol <code>MARPA_EVENT_SYMBOL_NULLED</code> event instance,
the two cannot occur in the same parse.
In fact,
a <code>MARPA_EVENT_SYMBOL_EXPECTED</code> event instance
and a same-symbol <code>MARPA_EVENT_SYMBOL_NULLED</code> event instance
cannot occur in any parse with the same base grammar.
</p>
<hr>
<a name="Marker-symbols"></a>
<div class="header">
<p>
Next: <a href="#Per_002drule-events" accesskey="n" rel="next">Per-rule events</a>, Previous: <a href="#Event-coincidence-of-symbols" accesskey="p" rel="prev">Event coincidence of symbols</a>, Up: <a href="#Events" accesskey="u" rel="up">Events</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Marker-symbols-1"></a>
<h3 class="section">25.14 Marker symbols</h3>

<p>A marker symbol is a nulling symbol introduced for
the purpose of &ldquo;marking&rdquo; a position in a rule.
If a <code>MARPA_EVENT_SYMBOL_NULLED</code> event is
activated for the marker symbol,
an event instance will be triggered whenever that
position in the rule is reached.
</p>
<p>For example, consider the rule
<a name="Rule-R1"></a></p><div class="display">
<pre class="display">     [ A ::= Y Z ].                  (R1)
</pre></div>
<p>If we replace <code>(R1)</code> with the following
rules
</p><div class="display">
<pre class="display">     [ Mk0 ::= ]
     [ Mk1 ::= ]
     [ Mk2 ::= ]
     [ A ::= Mk0 Y Mk1 Z Mk2 ].      (R2)
</pre></div>
<p>and activate
<code>MARPA_EVENT_SYMBOL_NULLED</code> events
for the marker symbols
(<code>Mk1</code>, <code>Mk2</code>, and <code>Mk3</code>),
then a <code>MARPA_EVENT_SYMBOL_NULLED</code> event instance
</p><ul>
<li> for <code>Mk0</code> will trigger at every location where <code>(R2)</code> is predicted;
</li><li> for <code>Mk1</code> will trigger at every location where the symbol <code>Y</code>
in rule <code>(R2)</code> has been recognized,
and the symbol <code>Z</code> is predicted;
</li><li> for <code>Mk2</code> will trigger at every location where <code>(R2)</code>
has been fully recognized, so that the entire RHS,
including both symbols <code>Y</code> and <code>Z</code>, has been recognized.
</li></ul>
<p>We can note that use of the marker <code>Mk0</code>
can be replaced by
declaring  <code>MARPA_EVENT_SYMBOL_PREDICTED</code> event
for symbol <code>A</code>.
Similarly,
use of the marker <code>Mk2</code>
can be replaced by
declaring  <code>MARPA_EVENT_SYMBOL_COMPLETED</code> event
for symbol <code>A</code>.
We discuss this more below.
See <a href="#Per_002drule-events">Per-rule events</a>.
</p>
<hr>
<a name="Per_002drule-events"></a>
<div class="header">
<p>
Previous: <a href="#Marker-symbols" accesskey="p" rel="prev">Marker symbols</a>, Up: <a href="#Events" accesskey="u" rel="up">Events</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Per_002drule-events-1"></a>
<h3 class="section">25.15 Per-rule events</h3>

<p>The event types are either global or per-symbol &mdash;
there are no per-rule events.
Nonetheless, the user can get the equivalent of per-rule
events in two ways,
both discussed previously
(see <a href="#Marker-symbols">Marker symbols</a>).
The competely general way is to use marker symbols.
</p>
<p>The other way is to
declare <code>MARPA_EVENT_SYMBOL_PREDICTED</code> and
<code>MARPA_EVENT_SYMBOL_COMPLETED</code> events
for the LHS of the rule.
This has two limitations:
First, it can only trigger events before the first RHS
symbol of the rule,
or after the rule&rsquo;s last RHS symbol.
Second,
the <code>MARPA_EVENT_SYMBOL_PREDICTED</code> and
<code>MARPA_EVENT_SYMBOL_COMPLETED</code> events
will trigger events for all rules with the same
LHS, which may not be what is wanted.
</p>
<a name="lim2Ex"></a><p>We illustrate the second limitation with an example,
which we will call <code>lim2Ex</code>.
In <code>lim2Ex</code>, we have the following:
</p><ul>
<li> The grammar includes these two rules:
<div class="display">
<pre class="display">     [ A ::= W X ]              (R3)
     [ A ::= Y Z ]              (R4)
</pre></div>
</li><li> A <code>MARPA_EVENT_SYMBOL_COMPLETED</code> event
is activated for symbol <code>A</code>.
</li></ul>

<p>Suppose we want an event to
trigger at, and only at, the place when rule <code>(R3)</code>
is fully recognized.
In <code>lim2Ex</code>,
the <code>MARPA_EVENT_SYMBOL_COMPLETED</code> event
for symbol <code>A</code>
triggers at the end of both rules <code>(R3)</code>
and <code>(R4)</code>.
The triggering at the end of rule <code>(R4)</code>
is problematic.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Workaround-with-a-dedicated-LHS-symbol" accesskey="1">Workaround with a dedicated LHS symbol</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Workaround-with-a-dedicated-LHS-symbol"></a>
<div class="header">
<p>
Previous: <a href="#Per_002drule-events" accesskey="p" rel="prev">Per-rule events</a>, Up: <a href="#Per_002drule-events" accesskey="u" rel="up">Per-rule events</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Workaround-with-a-dedicated-LHS-symbol-1"></a>
<h4 class="subsection">25.15.1 Workaround with a dedicated LHS symbol</h4>

<p>Most users will fix the second limitation
(see <a href="#lim2Ex">lim2Ex</a>)
by falling back
on marker symbols.
For those users who for some reason prefer to avoid this,
in this section we present
a workaround that is based on introducing a new symbol,
one dedicated to acting as the LHS of <code>(R3)</code>
of <code>lim2Ex</code>.
</p>
<p>We show the fix as another example,
one which we will call
<code>fixEx</code>.
<code>fixEx</code> is identical to
<code>lim2Ex</code> with
the following exceptions:
</p><ul>
<li> Rule <code>(R3)</code>
in <code>lim2Ex</code> is replaced with the following rules:
<div class="display">
<pre class="display">     [ A1 ::= W X ]             (R3a)
     [ A ::= A1 ]               (R3b)
</pre></div>
<p>In these two rules,
rule <code>(R3a)</code> is the replacement rule
for rule <code>(R3)</code> in <code>lim2Ex</code>,
and <code>A1</code> is the new LHS symbol,
which is dedicated to serving as the LHS
of rule <code>(R3a)</code>.
</p></li><li> A <code>MARPA_EVENT_SYMBOL_COMPLETED</code> event
is activated for symbol <code>A1</code>,
instead of for symbol <code>A</code>.
</li><li> Rule <code>(R3a)</code>
has the same semantics
as rule <code>(R3)</code> in <code>lim2Ex</code>,
the rule that it replaced.
</li><li> Rule <code>(R3b)</code> has pass-through semantics.
</li><li> The application code must be changed to look for
a <code>MARPA_EVENT_SYMBOL_COMPLETED</code> event
for symbol <code>A1</code>,
instead of symbol <code>A</code>.
</li></ul>
<p><code>fixEx</code> will accept the same language
as <code>lim2Ex</code>,
with the same semantics as <code>lim2Ex</code>.
A <code>MARPA_EVENT_SYMBOL_COMPLETED</code> event
will trigger at the end of <code>(R3a)</code>,
this time for symbol <code>A1</code>,
but at exactly the same parse location as it did
for symbol <code>A</code> in <code>lim2Ex</code>.
And a <code>MARPA_EVENT_SYMBOL_COMPLETED</code> event
will no longer trigger at the end of <code>(R4)</code>,
which is the fix we were looking for.
</p>
<hr>
<a name="Tracing-and-diagnosing-parses"></a>
<div class="header">
<p>
Next: <a href="#Error-methods-macros-and-codes" accesskey="n" rel="next">Error methods macros and codes</a>, Previous: <a href="#Events" accesskey="p" rel="prev">Events</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Tracing-and-diagnosing-parses-1"></a>
<h2 class="chapter">26 Tracing and diagnosing parses</h2>

<p>Libmarpa is very low-level,
and does not use strings to identify its objects.
Libmarpa is expected
to come with a upper level which uses strings
to name and/or identify the objects used in parsing,
in the process deciding
issues like naming conventions, ASCII-7 versus UTF-8, etc.
Based on those decisions,
the upper layer is expected to offer facilities
for tracking and displaying symbol names,
displaying rules,
tracking and displaying tokens,
and displaying progress items.
</p>
<p>It is possible to trace and diagnose parses without
an upper layer &ndash; a few programs in Libmarpa&rsquo;s test suite
do this.
Instead of using symbol names and expanding rules
into their LHS and RHS,
the user can keep track of symbol IDs and rule IDs.
But most people who have tried this would agree
that this is something that the user should go to great pains to
avoid.
</p>
<p>As a rule,
every application of Libmarpa should have an upper layer
with diagnostics.
If a pre-existing diagnostics layer is not used,
it should be one of the first things written &mdash;
it is very likely to be one of the first things needed.
</p>
<p>The rest of this chapter describes facilities that should be
offered in the layer handling grammar diagnostics.
Applications may want to allow these facilities at various
levels of verbosity.
Implementation suggestions are made,
focusing on what information
the facilities should display at the highest verbosity level.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Listing-symbols" accesskey="1">Listing symbols</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Listing-rules" accesskey="2">Listing rules</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Listing-Earley-sets" accesskey="3">Listing Earley sets</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Tracing-tokens" accesskey="4">Tracing tokens</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Listing-symbols"></a>
<div class="header">
<p>
Next: <a href="#Listing-rules" accesskey="n" rel="next">Listing rules</a>, Previous: <a href="#Tracing-and-diagnosing-parses" accesskey="p" rel="prev">Tracing and diagnosing parses</a>, Up: <a href="#Tracing-and-diagnosing-parses" accesskey="u" rel="up">Tracing and diagnosing parses</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Listing-symbols-1"></a>
<h3 class="section">26.1 Listing symbols</h3>

<p>The parse diagnostics should include a facility for naming symbols,
iand one for listing the symbols in a grammar, with their names.
The symbols will have IDs from 0 to the highest symbol ID,
which can be found using the
<code>marpa_g_highest_symbol_id()</code> method
(see <a href="#marpa_005fg_005fhighest_005fsymbol_005fid">marpa_g_highest_symbol_id</a>).
At the highest verbosity level,
in addition to the symbol name,
the symbol listing facility should display
</p><ul>
<li> the symbol ID;
</li><li> whether the symbol is accessible
(see <a href="#marpa_005fg_005fsymbol_005fis_005faccessible">marpa_g_symbol_is_accessible</a>);
</li><li> whether the symbol is nullable
(see <a href="#marpa_005fg_005fsymbol_005fis_005fnullable">marpa_g_symbol_is_nullable</a>);
</li><li> whether the symbol is nulling
(see <a href="#marpa_005fg_005fsymbol_005fis_005fnulling">marpa_g_symbol_is_nulling</a>);
</li><li> whether the symbol is productive
(see <a href="#marpa_005fg_005fsymbol_005fis_005fproductive">marpa_g_symbol_is_productive</a>);
</li><li> whether the symbol is the start symbol
(see <a href="#marpa_005fg_005fsymbol_005fis_005fstart">marpa_g_symbol_is_start</a>);
</li><li> whether the symbol is a terminal
(see <a href="#marpa_005fg_005fsymbol_005fis_005fterminal">marpa_g_symbol_is_terminal</a>);
</li><li> whether the symbol is a counted symbol
(see <a href="#marpa_005fg_005fsymbol_005fis_005fcounted">marpa_g_symbol_is_counted</a>); and
</li><li> the rank of the symbol
(see <a href="#marpa_005fg_005fsymbol_005frank">marpa_g_symbol_rank</a>).
</li></ul>

<hr>
<a name="Listing-rules"></a>
<div class="header">
<p>
Next: <a href="#Listing-Earley-sets" accesskey="n" rel="next">Listing Earley sets</a>, Previous: <a href="#Listing-symbols" accesskey="p" rel="prev">Listing symbols</a>, Up: <a href="#Tracing-and-diagnosing-parses" accesskey="u" rel="up">Tracing and diagnosing parses</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Listing-rules-1"></a>
<h3 class="section">26.2 Listing rules</h3>

<p>The parse diagnostics should include a facility for displaying
the rules in a grammar.
The rules will have IDs from 0 to the highest rule ID,
which can be found using the
<code>marpa_g_highest_rule_id()</code> method
(see <a href="#marpa_005fg_005fhighest_005frule_005fid">marpa_g_highest_rule_id</a>).
</p>
<p>It is up to the application whether to have names for rules.
In some grammar generators,
the LHS of a rule serves as its name,
but does not produce unique names for each rule in Libmarpa,
since many rules may have the same LHS.
Currently the most used upper layer for Libmarpa,
<code>Marpa::R2</code>, does not have rule names.
An application that does want to name its rules must
decide on a rule naming convention.
</p>
<p>At the highest verbosity level,
the rule listing facility should display
</p><ul>
<li> the rule ID;
</li><li> the LHS of the rule
(see <a href="#marpa_005fg_005frule_005flhs">marpa_g_rule_lhs</a>);
</li><li> the RHS of the rule, that is,
each RHS symbol
(see <a href="#marpa_005fg_005frule_005frhs">marpa_g_rule_rhs</a>)
for the length of the rule
(see <a href="#marpa_005fg_005frule_005flength">marpa_g_rule_length</a>);
</li><li> whether the rule is accessible
(see <a href="#marpa_005fg_005frule_005fis_005faccessible">marpa_g_rule_is_accessible</a>);
</li><li> whether the rule is nullable
(see <a href="#marpa_005fg_005frule_005fis_005fnullable">marpa_g_rule_is_nullable</a>);
</li><li> whether the rule is nulling
(see <a href="#marpa_005fg_005frule_005fis_005fnulling">marpa_g_rule_is_nulling</a>);
</li><li> whether the rule is productive
(see <a href="#marpa_005fg_005frule_005fis_005fproductive">marpa_g_rule_is_productive</a>);
</li><li> the rank of the rule
(see <a href="#marpa_005fg_005frule_005frank">marpa_g_rule_rank</a>);
</li><li> whether the rule is a sequence rule
(see <a href="#marpa_005fg_005fsequence_005fmin">marpa_g_sequence_min</a>);
</li><li> if the rule is a sequence rule,
the minimum count of the sequence
(see <a href="#marpa_005fg_005fsequence_005fmin">marpa_g_sequence_min</a>); and
</li><li> if the rule is a sequence rule,
the sequence separator, if any,
(see <a href="#marpa_005fg_005fsequence_005fseparator">marpa_g_sequence_separator</a>)
</li><li> if the rule is a sequence rule,
whether the rule uses proper separation,
(see <a href="#marpa_005fg_005frule_005fis_005fproper_005fseparation">marpa_g_rule_is_proper_separation</a>);
</li></ul>

<hr>
<a name="Listing-Earley-sets"></a>
<div class="header">
<p>
Next: <a href="#Tracing-tokens" accesskey="n" rel="next">Tracing tokens</a>, Previous: <a href="#Listing-rules" accesskey="p" rel="prev">Listing rules</a>, Up: <a href="#Tracing-and-diagnosing-parses" accesskey="u" rel="up">Tracing and diagnosing parses</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Listing-Earley-sets-1"></a>
<h3 class="section">26.3 Listing Earley sets</h3>

<p>The parse diagnostics should include a facility for displaying
Earley sets by Earley set location.
For each Earley item at a location,
the facility should display
</p><ul>
<li> the rule;
</li><li> the rule&rsquo;s dot position;
</li><li> the origin of the Earley item.
</li></ul>
<p>The &ldquo;progress reports&rdquo; methods of Libmarpa
are available for this purpose.
See <a href="#Progress-reports">Progress reports</a>.
</p>
<p>It is up to the application how to display rule and
dot position, but the most helpful way is usually to display
the LHS and RHS,
with a bullet or dot at the appropriate position in the RHS.
This is what is done when showing dotted rules in this document,
as for example in
</p><div class="display">
<pre class="display">    [ Y ::= C &bull; X ].
</pre></div>

<p>The current location of each Earley item may be displayed with the Earley item but,
since it is shared by the entire set of Earley items,
it can also be put in a header, or left implicit.
</p>
<p>We recall (see <a href="#Earlemes-and-Earley-set-IDs">Earlemes and Earley set IDs</a>) that
the Earley IDs range from 0 to <code>latest</code>, inclusive,
where <code>latest</code> is the latest Earley set.
See <a href="#The-latest-Earley-set">The latest Earley set</a>].
</p>
<p>The obvious way to display the Earley items is one at a time.
We call this the &ldquo;raw&rdquo; method of displaying an Earley set.
But we can also try to compact this listing by grouping together
Earley items that share a dotted rule
(and which therefore differ only in their origins).
We call this the &ldquo;compact&rdquo; method of displaying an Earley set.
<code>Marpa::R2</code> uses the compact method.
</p>
<p>To use the compact method,
we must be able to show an arbitrarily large number of origins compactly.
The following is an example line from
<code>Marpa::R2</code>&rsquo;s progress reports:
</p><div class="display">
<pre class="display">    F11 x12 @0...38-41 L1c1-L2c40 &lt;plain assignment&gt; -&gt; &rsquo;x&rsquo; &rsquo;=&rsquo; expression &bull;
</pre></div>
<p>In this example line, the following are true:
</p><ul>
<li> The &ldquo;F11&rdquo; indicates
indicates that the display line is for rule 11,
which is a completion.
The &ldquo;F&rdquo; indicates that the dot is in the &ldquo;final&rdquo; position.
</li><li> &ldquo;x12&rdquo;
indicates that the example line
represents 12 distinct Earley items.
</li><li> &ldquo;@0...38-41&rdquo;
states that the Earley items represented
have origins ranging from 0 to 38,
and that the current location for
the Earley items represented
in the example line is 41.
</li><li> &ldquo;L1c1-L2c40&rdquo; describes the line and column locations in the input &mdash;
the Earley items represented in
the example line
run from line 1, column 1 to line 2, column 40.
Line and column tracking is implemented at the <code>Marpa::R2</code> level.
</li><li> &ldquo;&lt;plain assignment&gt; -&gt; &rsquo;x&rsquo; &rsquo;=&rsquo; expression &bull;&rdquo;
indicates the dotted rule.
</li></ul>
<p>For more details on <code>Marpa::R2</code>&rsquo;s implementation of progress
reports, see
<a href="https://metacpan.org/dist/Marpa-R2/view/pod/Progress.pod">https://metacpan.org/dist/Marpa-R2/view/pod/Progress.pod</a>.
</p>
<p>The disadvantage of the compact representation of Earley sets
is that it is more complicated to read.
The disadvantage of the raw representation is that,
for ambiguous grammars, the number of Earley items can
be very large,
and therefore the listing of the Earley set
can be unmanageably long.
</p>
<hr>
<a name="Tracing-tokens"></a>
<div class="header">
<p>
Previous: <a href="#Listing-Earley-sets" accesskey="p" rel="prev">Listing Earley sets</a>, Up: <a href="#Tracing-and-diagnosing-parses" accesskey="u" rel="up">Tracing and diagnosing parses</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Tracing-tokens-1"></a>
<h3 class="section">26.4 Tracing tokens</h3>

<p>The parse diagnostics should include a facility for
displaying the token processing.
At the default verbosity level,
the facility should describe the token
passed to the
<code>marpa_r_alternative</code>
(see <a href="#marpa_005fr_005falternative">marpa_r_alternative</a>)
method call,
and specify the outcome of
the <code>marpa_r_alternative</code>
method call as
&ldquo;accepted&rdquo;, &ldquo;rejected&rdquo; or &ldquo;uncorrectable&rdquo;,
where
</p><ul>
<li> &ldquo;accepted&rdquo; means
that the <code>marpa_r_alternative()</code> call succeeded;
</li><li> &ldquo;rejected&rdquo; means
that the <code>marpa_r_alternative()</code> call failed,
but the failure is fully recoverable; and
</li><li> &ldquo;uncorrectable&rdquo; means
that the <code>marpa_r_alternative()</code> call failed,
but the failure is not fully recoverable.
</li></ul>
<p>The token tracing facility&rsquo;s reporting of rejected token
can vary by application.
For some applications, token rejection will not be
allowed, so that distinguishing between rejected
and uncorrectable tokens is pointless and unnecessary.
For other applications, such as those that use
the Ruby Slippers technique (see <a href="#Ruby-Slippers">Ruby Slippers</a>),
token rejection will be
a common occurrence in normal processing.
</p>
<p>At some verbosity level above the default,
after every
<code>marpa_r_earleme_complete()</code> method call
(see <a href="#marpa_005fr_005fearleme_005fcomplete">marpa_r_earleme_complete</a>)
the token tracing facility should list all the
expected tokens.
The <code>marpa_r_terminals_expected()</code>
(see <a href="#marpa_005fr_005fterminals_005fexpected">marpa_r_terminals_expected</a>) method call
is available for this purpose.
</p>
<hr>
<a name="Error-methods-macros-and-codes"></a>
<div class="header">
<p>
Next: <a href="#Technical-notes" accesskey="n" rel="next">Technical notes</a>, Previous: <a href="#Tracing-and-diagnosing-parses" accesskey="p" rel="prev">Tracing and diagnosing parses</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Error-methods_002c-macros-and-codes"></a>
<h2 class="chapter">27 Error methods, macros and codes</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Error-methods" accesskey="1">Error methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Error-Macros" accesskey="2">Error Macros</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#External-error-codes" accesskey="3">External error codes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Internal-error-codes" accesskey="4">Internal error codes</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Error-methods"></a>
<div class="header">
<p>
Next: <a href="#Error-Macros" accesskey="n" rel="next">Error Macros</a>, Previous: <a href="#Error-methods-macros-and-codes" accesskey="p" rel="prev">Error methods macros and codes</a>, Up: <a href="#Error-methods-macros-and-codes" accesskey="u" rel="up">Error methods macros and codes</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Error-methods-1"></a>
<h3 class="section">27.1 Error methods</h3>

<a name="marpa_005fg_005ferror"></a><dl>
<dt><a name="index-marpa_005fg_005ferror"></a>Accessor function: <em>Marpa_Error_Code</em> <strong>marpa_g_error</strong> <em>(     Marpa_Grammar <var>g</var>,     const char** <var>p_error_string</var>)</em></dt>
<dd>
<p>Allows the application to read the error code.
<var>p_error_string</var> is reserved for use by
the internals.
Applications should set it to <code>NULL</code>.
</p>
<p><strong>Return value</strong>: The current error code.
Always succeeds.
</p></dd></dl>

<a name="marpa_005fg_005ferror_005fclear"></a><dl>
<dt><a name="index-marpa_005fg_005ferror_005fclear"></a>Mutator function: <em>Marpa_Error_Code</em> <strong>marpa_g_error_clear</strong> <em>(     Marpa_Grammar <var>g</var> )</em></dt>
<dd>
<p>Sets the error code
to <code>MARPA_ERR_NONE</code>.
Not often used,
but now and then it can be useful
to force the error code to a known state.
</p>
<p><strong>Return value</strong>: <code>MARPA_ERR_NONE</code>.
Always succeeds.
</p></dd></dl>

<hr>
<a name="Error-Macros"></a>
<div class="header">
<p>
Next: <a href="#External-error-codes" accesskey="n" rel="next">External error codes</a>, Previous: <a href="#Error-methods" accesskey="p" rel="prev">Error methods</a>, Up: <a href="#Error-methods-macros-and-codes" accesskey="u" rel="up">Error methods macros and codes</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Error-Macros-1"></a>
<h3 class="section">27.2 Error Macros</h3>

<dl>
<dt><a name="index-MARPA_005fERRCODE_005fCOUNT"></a>Accessor macro: <em>int</em> <strong>MARPA_ERRCODE_COUNT</strong></dt>
<dd><p>The number of error codes.
All error codes, whether internal or external,
will be integers, non-negative but
strictly less than <code>MARPA_ERRCODE_COUNT</code>.
</p></dd></dl>

<hr>
<a name="External-error-codes"></a>
<div class="header">
<p>
Next: <a href="#Internal-error-codes" accesskey="n" rel="next">Internal error codes</a>, Previous: <a href="#Error-Macros" accesskey="p" rel="prev">Error Macros</a>, Up: <a href="#Error-methods-macros-and-codes" accesskey="u" rel="up">Error methods macros and codes</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="External-error-codes-1"></a>
<h3 class="section">27.3 External error codes</h3>

<p>This section lists the external error codes.
These are the only error codes that users
of the Libmarpa external interface should ever see.
Internal error codes are in their own section
(<a href="#Internal-error-codes">Internal error codes</a>).
</p>
<dl>
<dt><a name="index-MARPA_005fERR_005fNONE"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_NONE</strong></dt>
<dd><p>No error condition.
The error code is initialized to this value.
Methods that do not result in failure
sometimes reset the error code to <code>MARPA_ERR_NONE</code>.
<strong>Numeric value</strong>: 0.
<strong>Suggested message</strong>: &quot;No error&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fBAD_005fSEPARATOR"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_BAD_SEPARATOR</strong></dt>
<dd><p>A separator was specified for a sequence rule,
but its ID was not that
of a valid symbol.
<strong>Numeric value</strong>: 6.
<strong>Suggested message</strong>: &quot;Separator has invalid symbol ID&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fBEFORE_005fFIRST_005fTREE"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_BEFORE_FIRST_TREE</strong></dt>
<dd><p>A tree iterator is positioned before the first tree,
and the tree iterator was specified in a context where
the tree iterator must be positioned at or after
the first tree.
A newly created tree is positioned before the first
tree.
To position a newly created tree iterator to the first tree
use the
<code>marpa_t_next()</code>
method.
<strong>Numeric value</strong>: 91.
<strong>Suggested message</strong>: &quot;Tree iterator is before first tree&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fCOUNTED_005fNULLABLE"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_COUNTED_NULLABLE</strong></dt>
<dd><p>A &ldquo;counted&rdquo; symbol was found
that is also a nullable symbol.
A &ldquo;counted&rdquo; symbol is one that appears on the RHS
of a sequence rule.
If a symbol is nullable,
counting its occurrences becomes difficult.
Questions of definition and
problems of implementation arise.
At a minimum, a sequence with counted nullables
would be wildly
ambigious.
</p>
<p>Sequence rules are simply an optimized shorthand
for rules that can also be written in ordinary BNF.
If the equivalent of a sequence of nullables is
really what your application needs,
nothing in Libmarpa prevents you from specifying
that sequence
with ordinary BNF rules.
</p>
<p><strong>Numeric value</strong>: 8.
<strong>Suggested message</strong>: &quot;Nullable symbol on RHS of a sequence rule&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fDUPLICATE_005fRULE"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_DUPLICATE_RULE</strong></dt>
<dd><p>This error indicates an attempt to add a BNF rule that
is a duplicate of a BNF rule already in the grammar.
Two BNF rules are considered duplicates if
</p>
<ul>
<li> Both rules have the same left hand symbol, and
</li><li> Both rules have the same right hand symbols in the same order.
</li></ul>

<p>Duplication of sequence rules,
and duplication between BNF rules and sequence rules,
is dealt with by requiring that the LHS of a sequence rule
not be the LHS of any other rule.
</p>
<p><strong>Numeric value</strong>: 11.
<strong>Suggested message</strong>: &quot;Duplicate rule&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fDUPLICATE_005fTOKEN"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_DUPLICATE_TOKEN</strong></dt>
<dd><p>This error indicates an attempt to add a duplicate token.
A token is a duplicate if one already read at the same
earleme has the same symbol ID and the same length.
<strong>Numeric value</strong>: 12.
<strong>Suggested message</strong>: &quot;Duplicate token&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fYIM_005fCOUNT"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_YIM_COUNT</strong></dt>
<dd><p>This error code indicates that
an implementation-defined limit on the
number of Earley items per Earley set
was exceeded.
This limit is different from
the Earley item warning threshold,
an optional limit on the number
of Earley items in an Earley set,
which can be set by the application.
</p>
<p>The implementation-defined limit is very large,
at least 500,000,000 Earley items.
An application is unlikely ever to see this
error.
Libmarpa&rsquo;s use of memory
would almost certainly exceed the
limit imposed by the application environment
before this error occurs.
<strong>Numeric value</strong>: 13.
<strong>Suggested message</strong>: &quot;Maximum number of Earley items exceeded&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fEVENT_005fIX_005fNEGATIVE"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_EVENT_IX_NEGATIVE</strong></dt>
<dd><p>A negative event index was specified.
That is not allowed.
<strong>Numeric value</strong>: 15.
<strong>Suggested message</strong>: &quot;Negative event index&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fEVENT_005fIX_005fOOB"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_EVENT_IX_OOB</strong></dt>
<dd><p>An non-negative event index was specified,
but there is no event at that index.
Since the events are in sequence, this means it
was too large.
<strong>Numeric value</strong>: 16.
<strong>Suggested message</strong>: &quot;No event at that index&quot;.
</p></dd></dl>

<a name="MARPA_005fERR_005fGRAMMAR_005fHAS_005fCYCLE"></a><dl>
<dt><a name="index-MARPA_005fERR_005fGRAMMAR_005fHAS_005fCYCLE"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_GRAMMAR_HAS_CYCLE</strong></dt>
<dd><p>The grammar has a cycle.
Parsing using a grammar that contains a cycle is deprecated.
See <a href="#Cycles">Cycles</a>.
<strong>Numeric value</strong>: 17.
<strong>Suggested message</strong>: &quot;Grammar has cycle&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fHEADERS_005fDO_005fNOT_005fMATCH"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_HEADERS_DO_NOT_MATCH</strong></dt>
<dd><p>This error indicates that
Libmarpa was incorrectly built.
Libmarpa was compiled with headers that do not
match the rest of the code.
The solution is to find a correctly built
Libmarpa.
<strong>Numeric value</strong>: 98.
<strong>Suggested message</strong>: &quot;Internal error: Libmarpa was built incorrectly&quot;
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fI_005fAM_005fNOT_005fOK"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_I_AM_NOT_OK</strong></dt>
<dd><p>The Libmarpa base grammar is in a &ldquo;not ok&rdquo;
state.
Currently, the only way this can happen
is if Libmarpa memory is being overwritten.
<strong>Numeric value</strong>: 29.
<strong>Suggested message</strong>: &quot;Marpa is in a not OK state&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fINACCESSIBLE_005fTOKEN"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_INACCESSIBLE_TOKEN</strong></dt>
<dd><p>This error code indicates that
the token symbol is an inaccessible symbol &mdash; one that
cannot be reached from the start symbol.
Since the inaccessibility of a symbol is a property of the grammar,
this error code typically indicates an application error.
</p>
<p><strong>Numeric value</strong>: 18.
<strong>Suggested message</strong>: &quot;Token symbol is inaccessible&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fINVALID_005fBOOLEAN"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_INVALID_BOOLEAN</strong></dt>
<dd><p>A function was called that takes a boolean argument,
but the value of that argument was not either 0 or 1.
<strong>Numeric value</strong>: 22.
<strong>Suggested message</strong>: &quot;Argument is not boolean&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fINVALID_005fLOCATION"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_INVALID_LOCATION</strong></dt>
<dd><p>The location (Earley set ID) is not valid.
It may be invalid for one of two reasons:
</p><ul>
<li> It is negative,
and it is being used as the argument to a method
for which that negative value does not have a special meaning.
</li><li> It is after the latest Earley set.
</li></ul>

<p>For users of input models other than the standard one,
the term &ldquo;location&rdquo;, as used in association
with this error code,
means Earley set ID or Earley set ordinal.
In the standard input model, this will always
be identical with Libmarpa&rsquo;s other idea of
location, the earleme.
</p>
<p><strong>Numeric value</strong>: 25.
<strong>Suggested message</strong>: &quot;Location is not valid&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fINVALID_005fSTART_005fSYMBOL"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_INVALID_START_SYMBOL</strong></dt>
<dd><p>A start symbol was specified,
but its symbol ID is not that of a valid symbol.
<strong>Numeric value</strong>: 27.
<strong>Suggested message</strong>: &quot;Specified start symbol is not valid&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fINVALID_005fASSERTION_005fID"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_INVALID_ASSERTION_ID</strong></dt>
<dd><p>A method was called with an invalid assertion ID.
This is a assertion ID that not only does
not exist, but cannot exist.
Currently that means its value is less than zero.
<strong>Numeric value</strong>: 96.
<strong>Suggested message</strong>: &quot;Assertion ID is malformed&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fINVALID_005fRULE_005fID"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_INVALID_RULE_ID</strong></dt>
<dd><p>A method was called with an invalid rule ID.
This is a rule ID that not only does
not exist, but cannot exist.
Currently that means its value is less than zero.
<strong>Numeric value</strong>: 26.
<strong>Suggested message</strong>: &quot;Rule ID is malformed&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fINVALID_005fSYMBOL_005fID"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_INVALID_SYMBOL_ID</strong></dt>
<dd><p>A method was called with an invalid symbol ID.
This is a symbol ID that not only does
not exist, but cannot exist.
Currently that means its value is less than zero.
<strong>Numeric value</strong>: 28.
<strong>Suggested message</strong>: &quot;Symbol ID is malformed&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fMAJOR_005fVERSION_005fMISMATCH"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_MAJOR_VERSION_MISMATCH</strong></dt>
<dd><p>There was a mismatch in the major version number
between the requested version
of libmarpa, and the actual one.
<strong>Numeric value</strong>: 30.
<strong>Suggested message</strong>: &quot;Libmarpa major version number is a mismatch&quot;.
</p>
</dd></dl>
<dl>
<dt><a name="index-MARPA_005fERR_005fMICRO_005fVERSION_005fMISMATCH"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_MICRO_VERSION_MISMATCH</strong></dt>
<dd><p>There was a mismatch in the micro version number
between the requested version
of libmarpa, and the actual one.
<strong>Numeric value</strong>: 31.
<strong>Suggested message</strong>: &quot;Libmarpa micro version number is a mismatch&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fMINOR_005fVERSION_005fMISMATCH"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_MINOR_VERSION_MISMATCH</strong></dt>
<dd><p>There was a mismatch in the minor version number
between the requested version
of libmarpa, and the actual one.
<strong>Numeric value</strong>: 32.
<strong>Suggested message</strong>: &quot;Libmarpa minor version number is a mismatch&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fNO_005fEARLEY_005fSET_005fAT_005fLOCATION"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_NO_EARLEY_SET_AT_LOCATION</strong></dt>
<dd><p>A non-negative Earley set ID (also called an Earley set ordinal)
was specified,
but there is no corresponding Earley set.
Since the Earley set ordinals are in sequence,
this means that the specified ID is greater
than that of the latest Earley set.
<strong>Numeric value</strong>: 39.
<strong>Suggested message</strong>: &quot;Earley set ID is after latest Earley set&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fNOT_005fPRECOMPUTED"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_NOT_PRECOMPUTED</strong></dt>
<dd><p>The grammar is not precomputed,
and attempt was made to do something with it
that is not allowed for unprecomputed
grammars.
For example, a recognizer cannot be
created from a grammar until it is precomputed.
<strong>Numeric value</strong>: 34.
<strong>Suggested message</strong>: &quot;This grammar is not precomputed&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fNO_005fPARSE"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_NO_PARSE</strong></dt>
<dd><p>The application attempted to create a bocage
from a recognizer with no parse tree.
<strong>Numeric value</strong>: 41.
<strong>Suggested message</strong>: &quot;No parse&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fNO_005fRULES"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_NO_RULES</strong></dt>
<dd><p>A grammar that has no rules is being used
in a way that is not allowed.
Usually the problem is that the user is
trying to precompute the grammar.
<strong>Numeric value</strong>: 42.
<strong>Suggested message</strong>: &quot;This grammar does not have any rules&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fNO_005fSTART_005fSYMBOL"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_NO_START_SYMBOL</strong></dt>
<dd><p>The grammar has no start symbol,
and an attempt was made to perform an
operation that requires one.
Usually the problem is that the user is
trying to precompute the grammar.
<strong>Numeric value</strong>: 43.
<strong>Suggested message</strong>: &quot;This grammar has no start symbol&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fNO_005fSUCH_005fASSERTION_005fID"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_NO_SUCH_ASSERTION_ID</strong></dt>
<dd><p>A method was called with an assertion ID that is well-formed (a non-negative integer),
but the assertion does not exist.
<strong>Numeric value</strong>: 97.
<strong>Suggested message</strong>: &quot;No assertion with this ID exists&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fNO_005fSUCH_005fRULE_005fID"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_NO_SUCH_RULE_ID</strong></dt>
<dd><p>A method was called with a rule ID that is well-formed (a non-negative integer),
but the rule does not exist.
<strong>Numeric value</strong>: 89.
<strong>Suggested message</strong>: &quot;No rule with this ID exists&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fNO_005fSUCH_005fSYMBOL_005fID"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_NO_SUCH_SYMBOL_ID</strong></dt>
<dd><p>A method was called with a symbol ID that is well-formed (a non-negative integer),
but the symbol does not exist.
<strong>Numeric value</strong>: 90.
<strong>Suggested message</strong>: &quot;No symbol with this ID exists&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fNO_005fTOKEN_005fEXPECTED_005fHERE"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_NO_TOKEN_EXPECTED_HERE</strong></dt>
<dd><p>An attempt was made to read a token using <code>marpa_r_alternative</code>,
but no tokens were expected at this earleme location.
This can only happen in alternative input models.
See <a href="#marpa_005fr_005falternative">marpa_r_alternative()</a>.
</p>
<p><strong>Numeric value</strong>: 44.
<strong>Suggested message</strong>: &quot;No token is expected at this earleme location&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fNOT_005fA_005fSEQUENCE"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_NOT_A_SEQUENCE</strong></dt>
<dd><p>This error occurs in situations where a rule
is required to be a sequence,
and indicates that the rule of interest is,
in fact,
not a sequence.
</p>
<p><strong>Numeric value</strong>: 99.
<strong>Suggested message</strong>: &quot;Rule is not a sequence&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fNULLING_005fTERMINAL"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_NULLING_TERMINAL</strong></dt>
<dd><p>This error occurs only if LHS terminals feature is in use.
The LHS terminals feature is deprecated.
See <a href="#LHS-terminals">LHS terminals</a>.
<strong>Numeric value</strong>: 49.
<strong>Suggested message</strong>: &quot;A symbol is both terminal and nulling&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fORDER_005fFROZEN"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_ORDER_FROZEN</strong></dt>
<dd><p>The Marpa order object has been frozen.
If a Marpa order object is frozen, it cannot be
changed.
</p>
<p>Multiple tree iterators can share a Marpa order object,
but that order object is frozen after the first tree
iterator is created from it.
Applications can order an bocage in many ways,
but they must do so by creating multiple order objects.
</p>
<p><strong>Numeric value</strong>: 50.
<strong>Suggested message</strong>: &quot;The ordering is frozen&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fPARSE_005fEXHAUSTED"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_PARSE_EXHAUSTED</strong></dt>
<dd><p>The parse is exhausted.
<strong>Numeric value</strong>: 53.
<strong>Suggested message</strong>: &quot;The parse is exhausted&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fPARSE_005fTOO_005fLONG"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_PARSE_TOO_LONG</strong></dt>
<dd><p>The parse is too long.
The limit on the length of a parse is implementation
dependent, but it is very large,
at least 500,000,000 earlemes.
</p>
<p>In the standard input model,
Libmarpa&rsquo;s use of memory
would almost certainly exceed the
limit imposed by the application environment
before this error could occur.
If an application sees this error,
it almost certainly using one of the non-standard
input models.
</p>
<p>In the non-standard
input models,
this message will occur most often because
of an attempt to add a single extremely long token,
perhaps as a result of an application error.
It is also possible this error condition will
occur after the input of a large number
of long tokens.
</p>
<p><strong>Numeric value</strong>: 54.
<strong>Suggested message</strong>: &quot;This input would make the parse too long&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fPOINTER_005fARG_005fNULL"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_POINTER_ARG_NULL</strong></dt>
<dd><p>In a method that takes pointers as arguments,
one of the pointer arguments is <code>NULL</code>,
in a case where that is not allowed.
One such method is&nbsp;<code>marpa_r_progress_item()</code>.
<strong>Numeric value</strong>: 56.
<strong>Suggested message</strong>: &quot;An argument is null when it should not be&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fPRECOMPUTED"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_PRECOMPUTED</strong></dt>
<dd><p>An attempt was made to use a precomputed grammar
in a way that is not allowed.
Often this is an attempt to change the grammar.
Nearly every change to a grammar after
precomputation invalidates the precomputation,
and is therefore not allowed.
<strong>Numeric value</strong>: 57.
<strong>Suggested message</strong>: &quot;This grammar is precomputed&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fPROGRESS_005fREPORT_005fNOT_005fSTARTED"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_PROGRESS_REPORT_NOT_STARTED</strong></dt>
<dd><p>No recognizer progress report is currently active,
and an action has been attempted that
requires the progress report to be active.
One such action would be a
<code>marpa_r_progress_item()</code>
call.
<strong>Numeric value</strong>: 59.
<strong>Suggested message</strong>: &quot;No progress report has been started&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fPROGRESS_005fREPORT_005fEXHAUSTED"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_PROGRESS_REPORT_EXHAUSTED</strong></dt>
<dd><p>The progress report is &ldquo;exhausted&rdquo; &mdash; all its
items have been iterated through.
<strong>Numeric value</strong>: 58.
<strong>Suggested message</strong>: &quot;The progress report is exhausted&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fRANK_005fTOO_005fLOW"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_RANK_TOO_LOW</strong></dt>
<dd><p>A symbol or rule rank was specified that
was less than an implementation-defined minimum.
Implementations will always allow
ranks in the range between
-500,000,000 and 500,000,000.
<strong>Numeric value</strong>: 85.
<strong>Suggested message</strong>: &quot;Rule or symbol rank too low&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fRANK_005fTOO_005fHIGH"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_RANK_TOO_HIGH</strong></dt>
<dd><p>A symbol or rule rank was specified that
was greater than an implementation-defined maximum.
Implementations will always allow
ranks in the range between
-500,000,000 and 500,000,000.
<strong>Numeric value</strong>: 86.
<strong>Suggested message</strong>: &quot;Rule or symbol rank too high&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fRECCE_005fNOT_005fACCEPTING_005fINPUT"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_RECCE_NOT_ACCEPTING_INPUT</strong></dt>
<dd><p>The recognizer is not accepting input,
and the application has attempted something that
is inconsistent with that fact.
<strong>Numeric value</strong>: 60.
<strong>Suggested message</strong>: &quot;The recognizer is not accepting input&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fRECCE_005fNOT_005fSTARTED"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_RECCE_NOT_STARTED</strong></dt>
<dd><p>The recognizer has not been started.
and the application has attempted something that
is inconsistent with that fact.
<strong>Numeric value</strong>: 61.
<strong>Suggested message</strong>: &quot;The recognizer has not been started&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fRECCE_005fSTARTED"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_RECCE_STARTED</strong></dt>
<dd><p>The recognizer has been started.
and the application has attempted something that
is inconsistent with that fact.
<strong>Numeric value</strong>: 62.
<strong>Suggested message</strong>: &quot;The recognizer has been started&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fRHS_005fIX_005fNEGATIVE"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_RHS_IX_NEGATIVE</strong></dt>
<dd><p>The index of a RHS symbol was specified,
and it was negative.
That is not allowed.
<strong>Numeric value</strong>: 63.
<strong>Suggested message</strong>: &quot;RHS index cannot be negative&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fRHS_005fIX_005fOOB"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_RHS_IX_OOB</strong></dt>
<dd><p>A non-negative index of RHS symbol was specified,
but there is no symbol at that index.
Since the indexes are in sequence, this means the
index was greater than or equal to the rule length.
<strong>Numeric value</strong>: 64.
<strong>Suggested message</strong>: &quot;RHS index must be less than rule length&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fRHS_005fTOO_005fLONG"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_RHS_TOO_LONG</strong></dt>
<dd><p>An attempt was made to add a rule with too many
right hand side symbols.
The limit on the RHS symbol count is implementation
dependent, but it is very large,
at least 500,000,000 symbols.
Libmarpa&rsquo;s use of memory
would almost certainly exceed the
limit imposed by the application environment
before this error could occur.
<strong>Numeric value</strong>: 65.
<strong>Suggested message</strong>: &quot;The RHS is too long&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fSEQUENCE_005fLHS_005fNOT_005fUNIQUE"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_SEQUENCE_LHS_NOT_UNIQUE</strong></dt>
<dd><p>The LHS of a
sequence rule cannot be the LHS of any other rule,
whether a sequence rule or a BNF rule.
An attempt was made to violate this restriction.
<strong>Numeric value</strong>: 66.
<strong>Suggested message</strong>: &quot;LHS of sequence rule would not be unique&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fSTART_005fNOT_005fLHS"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_START_NOT_LHS</strong></dt>
<dd><p>The start symbol is not on the LHS on
any rule.
That means it could never match any possible input,
not even the null string.
This is likely to be a mistake in writing the grammar,
which can be fixed by rewriting the grammar.
<strong>Numeric value</strong>: 73.
<strong>Suggested message</strong>: &quot;Start symbol not on LHS of any rule&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fSYMBOL_005fIS_005fNOT_005fCOMPLETION_005fEVENT"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_SYMBOL_IS_NOT_COMPLETION_EVENT</strong></dt>
<dd><p>An attempt was made to use a symbol in
a way that requires it to be
set up for completion events,
but the symbol was
not set up for completion events.
This error can occur when
the application attempts to activate a completion
event in the recognizer for
a symbol that is not set up as a completion event.
<strong>Numeric value</strong>: 92.
<strong>Suggested message</strong>: &quot;Symbol is not set up for completion events&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fSYMBOL_005fIS_005fNOT_005fNULLED_005fEVENT"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_SYMBOL_IS_NOT_NULLED_EVENT</strong></dt>
<dd><p>An attempt was made to use a symbol in
a way that requires it to be
set up for nulled events,
but the symbol was not set up for nulled events.
This error can occur when
the application attempts to activate a nulled symbol
event in the recognizer for
a symbol that is not set up as a nulled event.
<strong>Numeric value</strong>: 93.
<strong>Suggested message</strong>: &quot;Symbol is not set up for nulled events&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fSYMBOL_005fIS_005fNOT_005fPREDICTION_005fEVENT"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_SYMBOL_IS_NOT_PREDICTION_EVENT</strong></dt>
<dd><p>An attempt was made to use a symbol in
a way that requires it to be
set up for prediction events,
but the symbol was not set up for prediction events.
This error can occur when
the application attempts to activate a prediction
event in the recognizer for
a symbol that is not set up as a prediction event.
<strong>Numeric value</strong>: 94.
<strong>Suggested message</strong>: &quot;Symbol is not set up for prediction events&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fSYMBOL_005fVALUED_005fCONFLICT"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_SYMBOL_VALUED_CONFLICT</strong></dt>
<dd><p>Unvalued symbols are a deprecated Marpa feature,
which may be avoided with
the
<code>marpa_g_force_valued()</code>
method.
An unvalued symbol may take on any value,
and therefore a symbol that is unvalued at some points
cannot safely to be used to contain a value at
others.
This error indicates that such an unsafe use is
being attempted.
<strong>Numeric value</strong>: 74.
<strong>Suggested message</strong>: &quot;Symbol is treated both as valued and unvalued&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fTERMINAL_005fIS_005fLOCKED"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_TERMINAL_IS_LOCKED</strong></dt>
<dd><p>An attempt was made to change the terminal status
of a symbol to a different value
after it was locked.
<strong>Numeric value</strong>: 75.
<strong>Suggested message</strong>: &quot;The terminal status of the symbol is locked&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fTOKEN_005fIS_005fNOT_005fTERMINAL"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_TOKEN_IS_NOT_TERMINAL</strong></dt>
<dd><p>A token was specified whose symbol ID is not
a terminal.
<strong>Numeric value</strong>: 76.
<strong>Suggested message</strong>: &quot;Token symbol must be a terminal&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fTOKEN_005fLENGTH_005fLE_005fZERO"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_TOKEN_LENGTH_LE_ZERO</strong></dt>
<dd><p>A token length was specified that is less than
or equal to zero.
Zero-length tokens are not allowed in Libmarpa.
<strong>Numeric value</strong>: 77.
<strong>Suggested message</strong>: &quot;Token length must greater than zero&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fTOKEN_005fTOO_005fLONG"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_TOKEN_TOO_LONG</strong></dt>
<dd><p>The token length is too long.
The limit on the length of a token
is implementation dependent, but it
is at least 500,000,000 earlemes.
Libmarpa&rsquo;s use of memory
would almost certainly exceed the
limit imposed by the application environment
before this error could occur.
<strong>Numeric value</strong>: 78.
<strong>Suggested message</strong>: &quot;Token is too long&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fTREE_005fEXHAUSTED"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_TREE_EXHAUSTED</strong></dt>
<dd><p>A Libmarpa parse tree iterator
is &ldquo;exhausted&rdquo;, that is,
it has no more parse trees.
<strong>Numeric value</strong>: 79.
<strong>Suggested message</strong>: &quot;Tree iterator is exhausted&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fTREE_005fPAUSED"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_TREE_PAUSED</strong></dt>
<dd><p>A Libmarpa tree is &ldquo;paused&rdquo;
and an operation was attempted that
is inconsistent with that fact.
Typically, this operation will be
a call of the
<code>marpa_t_next()</code>
method.
<strong>Numeric value</strong>: 80.
<strong>Suggested message</strong>: &quot;Tree iterator is paused&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fUNEXPECTED_005fTOKEN_005fID"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_UNEXPECTED_TOKEN_ID</strong></dt>
<dd><p>An attempt was made to read a token
where a token with that symbol ID is not
expected.
This message can also occur when an
attempt is made to read a token
at a location where no token is expected.
<strong>Numeric value</strong>: 81.
<strong>Suggested message</strong>: &quot;Unexpected token&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fUNPRODUCTIVE_005fSTART"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_UNPRODUCTIVE_START</strong></dt>
<dd><p>The start symbol is unproductive.
That means it could never match any possible input,
not even the null string.
This is likely to be a mistake in writing the grammar,
which can be fixed by rewriting the grammar.
<strong>Numeric value</strong>: 82.
<strong>Suggested message</strong>: &quot;Unproductive start symbol&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fVALUATOR_005fINACTIVE"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_VALUATOR_INACTIVE</strong></dt>
<dd><p>The valuator is inactive in a context where that
should not be the case.
<strong>Numeric value</strong>: 83.
<strong>Suggested message</strong>: &quot;Valuator inactive&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fVALUED_005fIS_005fLOCKED"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_VALUED_IS_LOCKED</strong></dt>
<dd><p>Unvalued symbols are a deprecated Marpa feature,
which may be avoided with
the
<code>marpa_g_force_valued()</code>
method.
See <a href="#marpa_005fg_005fforce_005fvalued">marpa_g_force_valued()</a>.
This error code
indicates that the valued status of a symbol is locked,
and an attempt was made
to change it to a status different from the
current one.
<strong>Numeric value</strong>: 84.
<strong>Suggested message</strong>: &quot;The valued status of the symbol is locked&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fSYMBOL_005fIS_005fNULLING"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_SYMBOL_IS_NULLING</strong></dt>
<dd><p>An attempt was made to do something with a nulling
symbol that is not allowed.
For example,
the ID of a nulling symbol cannot be an argument
to
<code>marpa_r_expected_symbol_event_set()</code>,
because it is not possible to create an &ldquo;expected symbol&rdquo; event
for a nulling symbol.
<strong>Numeric value</strong>: 87.
<strong>Suggested message</strong>: &quot;Symbol is nulling&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fSYMBOL_005fIS_005fUNUSED"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_SYMBOL_IS_UNUSED</strong></dt>
<dd><p>An attempt was made to do something with an unused symbol that is not allowed.
An &ldquo;unused&rdquo; symbol is a inaccessible or unproductive symbol.
For example,
the ID of a unused symbol cannot be an argument
to
<code>marpa_r_expected_symbol_event_set()</code>,
because it is not possible to create an &ldquo;expected symbol&rdquo; event
for an unused symbol.
<strong>Numeric value</strong>: 88.
<strong>Suggested message</strong>: &quot;Symbol is not used&quot;.
</p></dd></dl>

<hr>
<a name="Internal-error-codes"></a>
<div class="header">
<p>
Previous: <a href="#External-error-codes" accesskey="p" rel="prev">External error codes</a>, Up: <a href="#Error-methods-macros-and-codes" accesskey="u" rel="up">Error methods macros and codes</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Internal-error-codes-1"></a>
<h3 class="section">27.4 Internal error codes</h3>

<p>An internal error code may be one of two things:
First,
it can be an error code that
arises from an internal Libmarpa programming issue
(in other words, something happening in the code
that was not supposed to be able to happen.)
Second, it can be an error code that only occurs
when a method from Libmarpa&rsquo;s internal interface
is used.
Both kinds of internal error message share one common
trait &mdash; users of the Libmarpa&rsquo;s external interface
should never see them.
</p>
<p>Internal error messages
require someone with knowledge of the Libmarpa internals
to follow up on them.
They usually do not have descriptions or suggested messages.
</p>
<dl>
<dt><a name="index-MARPA_005fERR_005fAHFA_005fIX_005fNEGATIVE"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_AHFA_IX_NEGATIVE</strong></dt>
<dd><p><strong>Numeric value</strong>: 1.
</p></dd></dl>
<dl>
<dt><a name="index-MARPA_005fERR_005fAHFA_005fIX_005fOOB"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_AHFA_IX_OOB</strong></dt>
<dd><p><strong>Numeric value</strong>: 2.
</p></dd></dl>
<dl>
<dt><a name="index-MARPA_005fERR_005fANDID_005fNEGATIVE"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_ANDID_NEGATIVE</strong></dt>
<dd><p><strong>Numeric value</strong>: 3.
</p></dd></dl>
<dl>
<dt><a name="index-MARPA_005fERR_005fANDID_005fNOT_005fIN_005fOR"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_ANDID_NOT_IN_OR</strong></dt>
<dd><p><strong>Numeric value</strong>: 4.
</p></dd></dl>
<dl>
<dt><a name="index-MARPA_005fERR_005fANDIX_005fNEGATIVE"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_ANDIX_NEGATIVE</strong></dt>
<dd><p><strong>Numeric value</strong>: 5.
</p></dd></dl>
<dl>
<dt><a name="index-MARPA_005fERR_005fBOCAGE_005fITERATION_005fEXHAUSTED"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_BOCAGE_ITERATION_EXHAUSTED</strong></dt>
<dd><p><strong>Numeric value</strong>: 7.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fDEVELOPMENT"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_DEVELOPMENT</strong></dt>
<dd><p>&ldquo;Development&rdquo; errors were used heavily during
Libmarpa&rsquo;s development,
when it was not yet clear how precisely
to classify every error condition.
Unless they are using a developer&rsquo;s version,
users of the external interface
should never
see development errors.
</p>
<p>Development errors have an error string
associated with them.
The error string is a
short 7-bit ASCII error string
that describes the error.
<strong>Numeric value</strong>: 9.
<strong>Suggested message</strong>: &quot;Development error, see string&quot;.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fDUPLICATE_005fAND_005fNODE"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_DUPLICATE_AND_NODE</strong></dt>
<dd><p><strong>Numeric value</strong>: 10.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fYIM_005fID_005fINVALID"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_YIM_ID_INVALID</strong></dt>
<dd><p><strong>Numeric value</strong>: 14.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fINTERNAL"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_INTERNAL</strong></dt>
<dd><p>A &ldquo;catchall&rdquo; internal error.
<strong>Numeric value</strong>: 19.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fINVALID_005fAHFA_005fID"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_INVALID_AHFA_ID</strong></dt>
<dd><p>The AHFA ID was invalid.  There are no AHFAs
any more, so this message should not occur.
<strong>Numeric value</strong>: 20.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fINVALID_005fAIMID"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_INVALID_AIMID</strong></dt>
<dd><p>The AHM ID was invalid.  The term &ldquo;AIMID&rdquo;
is a legacy of earlier implementations and must
be kept for backward compatibility.
<strong>Numeric value</strong>: 21.
</p>
</dd></dl>
<dl>
<dt><a name="index-MARPA_005fERR_005fINVALID_005fIRLID"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_INVALID_IRLID</strong></dt>
<dd><p><strong>Numeric value</strong>: 23.
</p></dd></dl>
<dl>
<dt><a name="index-MARPA_005fERR_005fINVALID_005fNSYID"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_INVALID_NSYID</strong></dt>
<dd><p><strong>Numeric value</strong>: 24.
</p></dd></dl>
<dl>
<dt><a name="index-MARPA_005fERR_005fNOOKID_005fNEGATIVE"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_NOOKID_NEGATIVE</strong></dt>
<dd><p><strong>Numeric value</strong>: 33.
</p></dd></dl>
<dl>
<dt><a name="index-MARPA_005fERR_005fNOT_005fTRACING_005fCOMPLETION_005fLINKS"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_NOT_TRACING_COMPLETION_LINKS</strong></dt>
<dd><p><strong>Numeric value</strong>: 35.
</p></dd></dl>
<dl>
<dt><a name="index-MARPA_005fERR_005fNOT_005fTRACING_005fLEO_005fLINKS"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_NOT_TRACING_LEO_LINKS</strong></dt>
<dd><p><strong>Numeric value</strong>: 36.
</p></dd></dl>
<dl>
<dt><a name="index-MARPA_005fERR_005fNOT_005fTRACING_005fTOKEN_005fLINKS"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_NOT_TRACING_TOKEN_LINKS</strong></dt>
<dd><p><strong>Numeric value</strong>: 37.
</p></dd></dl>
<dl>
<dt><a name="index-MARPA_005fERR_005fNO_005fAND_005fNODES"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_NO_AND_NODES</strong></dt>
<dd><p><strong>Numeric value</strong>: 38.
</p></dd></dl>
<dl>
<dt><a name="index-MARPA_005fERR_005fNO_005fOR_005fNODES"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_NO_OR_NODES</strong></dt>
<dd><p><strong>Numeric value</strong>: 40.
</p></dd></dl>
<dl>
<dt><a name="index-MARPA_005fERR_005fNO_005fTRACE_005fYS"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_NO_TRACE_YS</strong></dt>
<dd><p><strong>Numeric value</strong>: 46.
</p></dd></dl>
<dl>
<dt><a name="index-MARPA_005fERR_005fNO_005fTRACE_005fPIM"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_NO_TRACE_PIM</strong></dt>
<dd><p><strong>Numeric value</strong>: 47.
</p></dd></dl>
<dl>
<dt><a name="index-MARPA_005fERR_005fNO_005fTRACE_005fYIM"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_NO_TRACE_YIM</strong></dt>
<dd><p><strong>Numeric value</strong>: 45.
</p></dd></dl>
<dl>
<dt><a name="index-MARPA_005fERR_005fNO_005fTRACE_005fSRCL"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_NO_TRACE_SRCL</strong></dt>
<dd><p><strong>Numeric value</strong>: 48.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fORID_005fNEGATIVE"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_ORID_NEGATIVE</strong></dt>
<dd><p><strong>Numeric value</strong>: 51.
</p></dd></dl>
<dl>
<dt><a name="index-MARPA_005fERR_005fOR_005fALREADY_005fORDERED"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_OR_ALREADY_ORDERED</strong></dt>
<dd><p><strong>Numeric value</strong>: 52.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fPIM_005fIS_005fNOT_005fLIM"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_PIM_IS_NOT_LIM</strong></dt>
<dd><p><strong>Numeric value</strong>: 55.
</p></dd></dl>

<dl>
<dt><a name="index-MARPA_005fERR_005fSOURCE_005fTYPE_005fIS_005fNONE"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_SOURCE_TYPE_IS_NONE</strong></dt>
<dd><p><strong>Numeric value</strong>: 70.
</p></dd></dl>
<dl>
<dt><a name="index-MARPA_005fERR_005fSOURCE_005fTYPE_005fIS_005fTOKEN"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_SOURCE_TYPE_IS_TOKEN</strong></dt>
<dd><p><strong>Numeric value</strong>: 71.
</p></dd></dl>
<dl>
<dt><a name="index-MARPA_005fERR_005fSOURCE_005fTYPE_005fIS_005fCOMPLETION"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_SOURCE_TYPE_IS_COMPLETION</strong></dt>
<dd><p><strong>Numeric value</strong>: 68.
</p></dd></dl>
<dl>
<dt><a name="index-MARPA_005fERR_005fSOURCE_005fTYPE_005fIS_005fLEO"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_SOURCE_TYPE_IS_LEO</strong></dt>
<dd><p><strong>Numeric value</strong>: 69.
</p></dd></dl>
<dl>
<dt><a name="index-MARPA_005fERR_005fSOURCE_005fTYPE_005fIS_005fAMBIGUOUS"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_SOURCE_TYPE_IS_AMBIGUOUS</strong></dt>
<dd><p><strong>Numeric value</strong>: 67.
</p></dd></dl>
<dl>
<dt><a name="index-MARPA_005fERR_005fSOURCE_005fTYPE_005fIS_005fUNKNOWN"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_SOURCE_TYPE_IS_UNKNOWN</strong></dt>
<dd><p><strong>Numeric value</strong>: 72.
</p></dd></dl>
<dl>
<dt><a name="index-MARPA_005fERR_005fRECCE_005fIS_005fINCONSISTENT"></a>Accessor macro: <em>int</em> <strong>MARPA_ERR_RECCE_IS_INCONSISTENT</strong></dt>
<dd><p><strong>Numeric value</strong>: 95.
<strong>Suggested message</strong>: &quot;The recognizer is inconsistent&quot;.
</p></dd></dl>

<hr>
<a name="Technical-notes"></a>
<div class="header">
<p>
Next: <a href="#Advanced-input-models" accesskey="n" rel="next">Advanced input models</a>, Previous: <a href="#Error-methods-macros-and-codes" accesskey="p" rel="prev">Error methods macros and codes</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Technical-notes-1"></a>
<h2 class="chapter">28 Technical notes</h2>

<p>This section contains technical notes that are
not necessary for the main presentation,
but which may be helpful or interesting.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Data-types-used-by-Libmarpa" accesskey="1">Data types used by Libmarpa</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Why-so-many-time-objects" accesskey="2">Why so many time objects</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Design-of-numbered-objects" accesskey="3">Design of numbered objects</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Trap-representations" accesskey="4">Trap representations</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Out_002dof_002dmemory-handling" accesskey="5">Out-of-memory handling</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Data-types-used-by-Libmarpa"></a>
<div class="header">
<p>
Next: <a href="#Why-so-many-time-objects" accesskey="n" rel="next">Why so many time objects</a>, Previous: <a href="#Technical-notes" accesskey="p" rel="prev">Technical notes</a>, Up: <a href="#Technical-notes" accesskey="u" rel="up">Technical notes</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Data-types-used-by-Libmarpa-1"></a>
<h3 class="section">28.1 Data types used by Libmarpa</h3>

<p>Libmarpa does not use any floating point data or strings.
All data are either integers or pointers.
</p>
<hr>
<a name="Why-so-many-time-objects"></a>
<div class="header">
<p>
Next: <a href="#Design-of-numbered-objects" accesskey="n" rel="next">Design of numbered objects</a>, Previous: <a href="#Data-types-used-by-Libmarpa" accesskey="p" rel="prev">Data types used by Libmarpa</a>, Up: <a href="#Technical-notes" accesskey="u" rel="up">Technical notes</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Why-so-many-time-objects_003f"></a>
<h3 class="section">28.2 Why so many time objects?</h3>

<p>Marpa is an aggressively multi-pass algorithm.
Marpa achieves its efficiency,
not in spite of making multiple
passes over the data, but because of it.
Marpa regularly substitutes
two fast O(<var>n</var>) passes for a single
O(<var>n</var> log <var>n</var>) pass.
Marpa&rsquo;s proliferation of time objects is in
keeping with its multi-pass approach.
</p>
<p>Bocage objects come at no cost,
even for unambiguous parses,
because the same pass that creates the bocage
also deals with other issues that are of major
significance for unambiguous parses.
It is the post-processing of the bocage pass
that enables Marpa to do both left-
and right-recursion in linear time.
</p>
<p>Of the various objects, the best
case for elimination is of the
ordering object.
In many cases, the ordering is trivial.
Either the parse is unambiguous, or the
application does not care about the order in
which parse trees are returned.
But while it would be easy to add an option
to bypass creation of an ordering object,
there is little to be gained from it.
When the ordering is trivial,
its overhead is very small &mdash;
essentially a handful of subroutine calls.
Many orderings accomplish nothing,
but these cost next to nothing.
</p>
<p>Tree objects come at minimal cost to unambiguous grammars,
because the same pass that allows iteration through multiple
parse trees does the tree traversal.
This eliminates much of the work that otherwise would
need to be done in
the valuation time object.
In the current implementation, the valuation time object
needs only to step through a sequence already determined
by the tree iterator.
</p>
<hr>
<a name="Design-of-numbered-objects"></a>
<div class="header">
<p>
Next: <a href="#Trap-representations" accesskey="n" rel="next">Trap representations</a>, Previous: <a href="#Why-so-many-time-objects" accesskey="p" rel="prev">Why so many time objects</a>, Up: <a href="#Technical-notes" accesskey="u" rel="up">Technical notes</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Numbered-objects-2"></a>
<h3 class="section">28.3 Numbered objects</h3>

<p>As the name suggests,
the choice was made to implement
numbered objects as integers,
and not as
pointers.
In standard-conformant C,
integers can be safely checked for validity,
while pointers cannot.
</p>
<p>There are efficiency tradeoffs between pointers and
integers but they are complicated,
and they go both ways.
Pointers can be faster, but integers can be used
as indexes into more than one data structure.
Which is actually faster depends on the design.
Integers allow for a more flexible design,
so that once the choice is settled on,
careful programming can make them a win,
possibly a very big one.
</p>
<p>The approach taken in Libmarpa was to settle,
from the outset,
on integers as the implementation for numbered
objects,
and to optimize on that basis.
The author concedes that it is
possible that
others redoing Libmarpa from scratch
might find that pointers are faster.
But the author is confident
that they will also discover,
on modern architectures,
that the lack of safe validity checking
is far too high a price to pay
for the difference in speed.
</p>
<hr>
<a name="Trap-representations"></a>
<div class="header">
<p>
Next: <a href="#Out_002dof_002dmemory-handling" accesskey="n" rel="next">Out-of-memory handling</a>, Previous: <a href="#Design-of-numbered-objects" accesskey="p" rel="prev">Design of numbered objects</a>, Up: <a href="#Technical-notes" accesskey="u" rel="up">Technical notes</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Trap-representations-1"></a>
<h3 class="section">28.4 Trap representations</h3>

<p>In order to be C89 conformant, an application
must initialize all locations that might be read.
This is because C89 allows
<a name="index-trap-representations"></a>
<em>trap representations</em>.
</p>
<p>A trap representation is a byte pattern in memory
that is not a valid value of some object type.
When read, the trap representation causes undefined behavior
according to the C89 standard.
Because of this undefined behavior
the application that allowed the read
is non-conformant to the C89 standard.
Trap representations are carefully defined and discussed in the C99 standard.
See <a href="#C99">C99</a>
</p>
<p>In real life, trap representations can occur when floating point values are
used: Some byte patterns that can occur in memory are not valid floating point
values, and can cause undefined behavior when read.
</p>
<p>Pointers raise the same issue although,
since pointers can be safely read as an integer,
some insist that an invalid pointer is not,
strictly speaking, a trap representation.
But there is no portable c89-conformant way of
testing the integer form of a pointer for validity,
so that the only way to guarantee C89 conformance
is to initialize the pointer, either to a valid pointer,
or to a known and therefore testable value, such as <code>NULL</code>.
</p>
<p>All this implies that, in order to claim c89-conformance,
an application must initialize all locations that might be read
to non-trap values.
For a stack implementation, this means that, as a practical matter,
all locations on the stack must be initialized.
</p>
<hr>
<a name="Out_002dof_002dmemory-handling"></a>
<div class="header">
<p>
Previous: <a href="#Trap-representations" accesskey="p" rel="prev">Trap representations</a>, Up: <a href="#Technical-notes" accesskey="u" rel="up">Technical notes</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Out_002dof_002dmemory-handling-1"></a>
<h3 class="section">28.5 Out-of-memory handling</h3>

<p>Modern operating systems
usually have an out-of-memory (OOM) killer as a component.
When an OOM killer is in use,
if an application or library is unable to allocate memory,
it usually will not be given an opportunity to handle this error.
See &ldquo;When malloc() Never Returns NULL &mdash; Reliability as an Illusion&rdquo;,
<a href="https://arxiv.org/pdf/2208.08484.pdf">https://arxiv.org/pdf/2208.08484.pdf</a>.
</p>
<hr>
<a name="Advanced-input-models"></a>
<div class="header">
<p>
Next: <a href="#Support" accesskey="n" rel="next">Support</a>, Previous: <a href="#Technical-notes" accesskey="p" rel="prev">Technical notes</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Advanced-input-models-1"></a>
<h2 class="chapter">29 Advanced input models</h2>

<p>In an earlier chapter, we introduced Libmarpa&rsquo;s concept of input,
and described its basic input models.
See <a href="#Input">Input</a>.
In this chapter we describe Libmarpa&rsquo;s advanced models of input.
These advanced input models have attracted considerable interest.
However, they have seen little actual use so far,
and for that reason we delayed their consideration until now.
</p>
<p>A Libmarpa input model is
<a name="index-advanced-input-model"></a>
<a name="index-input-model_002c-advanced"></a>
<em>advanced</em>
if it allows tokens of length other than 1.
The advanced input models are also called
<a name="index-variable_002dlength-token-input-model"></a>
<a name="index-input-model_002c-variable_002dlength-token"></a>
<em>variable-length token models</em>
because they allow the token
length to vary from the &ldquo;normal&rdquo; length of 1.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#The-dense-variable_002dlength-token-model" accesskey="1">The dense variable-length token model</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-fully-general-input-model" accesskey="2">The fully general input model</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#The-codepoint_002dper_002dearleme-model" accesskey="3">The codepoint-per-earleme model</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Converting-earleme-to-Earley-set-ID" accesskey="4">Converting earleme to Earley set ID</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="The-dense-variable_002dlength-token-model"></a>
<div class="header">
<p>
Next: <a href="#The-fully-general-input-model" accesskey="n" rel="next">The fully general input model</a>, Previous: <a href="#Advanced-input-models" accesskey="p" rel="prev">Advanced input models</a>, Up: <a href="#Advanced-input-models" accesskey="u" rel="up">Advanced input models</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="The-dense-variable_002dlength-token-model-1"></a>
<h3 class="section">29.1 The dense variable-length token model</h3>

<p>In the
<a name="index-dense-variable_002dlength-input-model"></a>
<a name="index-variable_002dlength-input-model_002c-dense"></a>
<a name="index-input-model_002c-dense-variable_002dlength"></a>
<em>dense variable-length model of input</em>,
one or more successful
calls of
<code>marpa_r_alternative()</code>
must be immediately previous
to every call to
<code>marpa_r_earleme_complete()</code>.
Note that,
for a variable-length input model to be &ldquo;dense&rdquo;
according to this definition,
at least one successful call
of <code>marpa_r_alternative()</code>
must be immediately previous to each call to
<code>marpa_r_earleme_complete()</code>.
Recall that, in this document, we say that a <code>marpa_r_alternative()</code> call is
&ldquo;immediately previous&rdquo; to a
<code>marpa_r_earleme_complete()</code> call
iff
that <code>marpa_r_earleme_complete()</code> call is
the first
<code>marpa_r_earleme_complete()</code> call after
the <code>marpa_r_alternative()</code> call.
</p>
<p>In the dense model of input,
after a successful call of
<code>marpa_r_alternative()</code>,
the earleme variables are as follows:
</p><ul>
<li> The furthest earleme will be
<code>max(old_f, old_c+length)</code>,
    <ul>
<li> where <code>old_f</code> is the furthest earleme
        before the call to <code>marpa_r_alternative()</code>,
    </li><li> <code>old_c</code> is the value of the current earleme
        before the call to <code>marpa_r_alternative()</code>, and
    </li><li> <code>length</code> is the length of the token read.
    </li></ul>
</li><li> <code>marpa_r_alternative()</code> never changes the
latest or current earleme.
</li></ul>

<p>In the dense variable-length model of input,
the following are also true:
</p>
<ul>
<li> The effect of the
<code>marpa_r_earleme_complete()</code>
mutator on the earleme variables
is the same as for the
basic models of input.
See <a href="#The-standard-model-of-input">The standard model of input</a>.

</li><li> the latest earleme is always the same as
the current earleme.
In fact,
the latest earleme and the current earleme
are always the same,
except in the fully general model of input.
</li></ul>

<hr>
<a name="The-fully-general-input-model"></a>
<div class="header">
<p>
Next: <a href="#The-codepoint_002dper_002dearleme-model" accesskey="n" rel="next">The codepoint-per-earleme model</a>, Previous: <a href="#The-dense-variable_002dlength-token-model" accesskey="p" rel="prev">The dense variable-length token model</a>, Up: <a href="#Advanced-input-models" accesskey="u" rel="up">Advanced input models</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="The-fully-general-input-model-1"></a>
<h3 class="section">29.2 The fully general input model</h3>

<p>In the
<a name="index-sparse-variable_002dlength-input-model"></a>
<a name="index-variable_002dlength-input-model_002c-sparse"></a>
<a name="index-input-model_002c-sparse-variable_002dlength"></a>
<em>sparse variable-length model of input</em>,
zero or more successful
calls of
<code>marpa_r_alternative()</code>
must be immediately previous
to every call to
<code>marpa_r_earleme_complete()</code>.
The sparse model is the dense variable-length model,
with its only restriction lifted &mdash;
the sparse variable-length input model
allows calls to
<code>marpa_r_earleme_complete()</code>
that are not immediately preceded by successful calls to
<code>marpa_r_alternative()</code>.
</p>
<p>Since it is unrestricted, the sparse input model
is Libmarpa&rsquo;s fully general input model.
Because of this,
it may be useful for us
to state the effect of mutators
on the earleme variables in detail,
even at the expense of some repetition.
</p>
<p>In the sparse input model,
<a name="index-empty-earleme"></a>
<a name="index-earleme_002c-empty"></a>
<em>empty earlemes</em>
are now possible.
An empty earleme is an earleme
with no tokens and no Earley set.
An empty earleme occurs iff
<code>marpa_r_earleme_complete()</code>
is called when there is no immediately previous
successful call to
<code>marpa_r_alternative()</code>.
The sparse model takes its name
from the fact that there may be earlemes with no
Earley set.
In the sparse model, Earley sets are &ldquo;sparsely&rdquo;
distributed among the earlemes.
</p>
<p>The latest earleme is the most recent non-empty earleme.
In other words, the latest earleme is the most recent
earleme with an Earley set at it.
In the dense input models,
the current earleme and the latest earleme were always
the same.
Because the sparse input models allow empty earlemes,
it becomes possible for the latest earleme
and the current earleme to differ.
The latest earleme must always be the earleme of an Earley set.
The current earleme is not necessarily the earleme of an Earley set.
</p>
<p>In the sparse model of input,
the effect on the earleme variables of
a successful call of the
<code>marpa_r_alternative()</code> mutator
is the same as for the dense model of input:
</p><ul>
<li> The furthest earleme will be
<code>max(old_f, old_c+length)</code>,
    <ul>
<li> where <code>old_f</code> is the furthest earleme
        before the call to <code>marpa_r_alternative()</code>,
    </li><li> <code>old_c</code> is the value of the current earleme
        before the call to <code>marpa_r_alternative()</code>, and
    </li><li> <code>length</code> is the length of the token read.
    </li></ul>
</li><li> <code>marpa_r_alternative()</code> never changes the
latest or current earleme.
</li></ul>

<p>In the sparse model,
when the earleme is not empty,
the effect of
a call to
<code>marpa_r_earleme_complete()</code>
on the earleme variables is the same as
in the dense and the basic models of input.
Specifically, the following will be true:
</p><ul>
<li> The current earleme will be advanced to <code>old_c+1</code>,
where <code>old_c</code> is the current earleme before the call.
</li><li> The latest earleme will be <code>old_c+1</code>, and therefore
will be equal to the current earleme.
</li><li> The value of the furthest earleme is never changed by
a call to
<code>marpa_r_earleme_complete()</code>.
</li></ul>

<p>For the sparse input model,
in the case of an empty earleme,
the effect of the
<code>marpa_r_earleme_complete()</code>
mutator on the earleme variables
is the following:
</p><ul>
<li> The current earleme will be advanced to <code>old_c+1</code>,
where <code>old_c</code> is the current earleme before the call.
</li><li> The latest earleme will remain at <code>old_l</code>,
where the latest earleme before the call is <code>old_l</code>.
This implies that the latest earleme will be less than
the current earleme.
</li><li> The furthest earleme is never changed by a call
to
<code>marpa_r_earleme_complete()</code>.
</li></ul>

<hr>
<a name="The-codepoint_002dper_002dearleme-model"></a>
<div class="header">
<p>
Next: <a href="#Converting-earleme-to-Earley-set-ID" accesskey="n" rel="next">Converting earleme to Earley set ID</a>, Previous: <a href="#The-fully-general-input-model" accesskey="p" rel="prev">The fully general input model</a>, Up: <a href="#Advanced-input-models" accesskey="u" rel="up">Advanced input models</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="The-codepoint_002dper_002dearleme-model-1"></a>
<h3 class="section">29.3 The codepoint-per-earleme model</h3>

<p>One variation of the fully general model is
the
<a name="index-one_002dcodepoint_002dper_002dearleme-input-model"></a>
<em>one-codepoint-per-earleme input model</em>,
usually called the
<a name="index-codepoint_002dper_002dearleme-input-model"></a>
<em>codepoint-per-earleme input model</em>.
</p>
<p>Most input models may be called
<a name="index-token_002dper_002dearleme-input-models"></a>
<em>token-per-earleme input models</em>.
That is, they are models in which every token
is exactly one earleme long.
</p>
<p>In the codepoint-per-earleme model, every codepoint will be treated as
being exactly one earleme in length.
If a token is more than one codepoint
in length, that token will span earlemes.
In the codepoint-per-earleme model,
tokens may be ambiguous, and they may overlap.
</p>
<p>When a codepoint-per-earleme model of input is used, there may be
many earlemes at which no tokens start. For example, in a straightforward
codepoint-per-earleme implementation of a grammar for a language that
allows comments, no tokens will start at any earlemes which correspond
to character locations inside a comment.
</p>
<p>Codepoint-per-earleme input model have seen a lot of use,
but mainly for experimental and toy grammars.
Their disadvantage is efficiency &mdash; the requirement of one call
of <code>marpa_r_alternative()</code> for each codepoint can make them
substantially more expensive than input models which allow multiple
codepoints per earleme.
</p>
<hr>
<a name="Converting-earleme-to-Earley-set-ID"></a>
<div class="header">
<p>
Previous: <a href="#The-codepoint_002dper_002dearleme-model" accesskey="p" rel="prev">The codepoint-per-earleme model</a>, Up: <a href="#Advanced-input-models" accesskey="u" rel="up">Advanced input models</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Converting-earleme-to-Earley-set-ID-1"></a>
<h3 class="section">29.4 Converting earleme to Earley set ID</h3>

<p>In the dense input models,
the earleme of every Earley set is equal
to the ID of that Earley set.
But, because of the sparse input models,
this is not true in the general case.
</p>
<p>For other applications
that want an earleme-to-ID mapping,
the most general method for converting earlemes to Earley set IDs
is to create a ID-to-earleme
array using the
<code>marpa_r_earleme()</code> method
(see <a href="#marpa_005fr_005fearleme">marpa_r_earleme</a>),
and invert it.
The resulting earleme-to-ID array will be sparse.
More precisely, where the function <code>earleme</code> maps IDs
to earlemes,
the value at index <code>ix</code> of the array should
be
</p><ul>
<li> <code>id</code>, if <code>earleme(id) = ix</code> for some <code>id</code>; and
</li><li> undefined, otherwise.
</li></ul>

<p>The Libmarpa interface does not provide a method
for earleme-to-ID conversion.
The input model is not known at the Libmarpa level,
so that an earleme-to-ID method would have to be
fully general.
A fully general earleme-to-ID method would be costly,
an cost which usually would be unnecessary.
For these reasons,
it&rsquo;s up to the application to create its own
earleme-to-conversion method,
if one is needed.
</p>
<p>Here are the alternatives:
</p><ul>
<li> Usually an
earleme-to-ID conversion method is not needed.
</li><li> If
an earleme-to-ID conversion method is needed,
and the sparse input model is not in use,
the Earley set ID and the earleme are always
equal, and the
earleme-to-ID conversion is trivial.
</li><li> If an earleme-to-ID conversion method is needed,
and a sparse input model is in use,
the application may be able to implement
an efficient earleme-to-ID conversion targeted
at that specific input model.
</li><li> If an earleme-to-ID conversion method is needed,
a sparse input model is in use,
and no efficient earleme-to-ID conversion targeted
at that specific input model seems to be available,
the general
earleme-to-ID conversion technique
described just above must be used.
</li></ul>

<hr>
<a name="Support"></a>
<div class="header">
<p>
Next: <a href="#Futures" accesskey="n" rel="next">Futures</a>, Previous: <a href="#Advanced-input-models" accesskey="p" rel="prev">Advanced input models</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Support-1"></a>
<h2 class="chapter">30 Support</h2>

<p>The &ldquo;updates&rdquo;
(<a href="https://github.com/jeffreykegler/libmarpa/blob/updated/UPDATES.md">https://github.com/jeffreykegler/libmarpa/blob/updated/UPDATES.md</a>)
document contains instructions for reporting
bugs, getting answers to questions, and other support.
</p>
<hr>
<a name="Futures"></a>
<div class="header">
<p>
Next: <a href="#Deprecated-techniques-and-methods" accesskey="n" rel="next">Deprecated techniques and methods</a>, Previous: <a href="#Support" accesskey="p" rel="prev">Support</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Futures-1"></a>
<h2 class="chapter">31 Futures</h2>

<p>This chapter is not about the current interface.
Instead, it discusses
changes or additions that might be made
to this document or
to the external interface in the future.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Nulling-versus-nulled" accesskey="1">Nulling versus nulled</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Document-pre_002dconditions-more-formally" accesskey="2">Document pre-conditions more formally</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Simpler-events-interface" accesskey="3">Simpler events interface</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Better-defined-ambiguity-metric" accesskey="4">Better defined ambiguity metric</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Report-item-traverser-should-be-a-time-object" accesskey="5">Report item traverser should be a time object</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Orthogonal-treatment-of-soft-failures" accesskey="6">Orthogonal treatment of soft failures</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Orthogonal-treatment-of-exhaustion" accesskey="7">Orthogonal treatment of exhaustion</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Furthest-earleme-values" accesskey="8">Furthest earleme values</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Additional-recoverable-failures-in-marpa_005fr_005falternative_0028_0029" accesskey="9">Additional recoverable failures in marpa_r_alternative()</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Untested-methods">Untested methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Nulling-versus-nulled"></a>
<div class="header">
<p>
Next: <a href="#Document-pre_002dconditions-more-formally" accesskey="n" rel="next">Document pre-conditions more formally</a>, Previous: <a href="#Futures" accesskey="p" rel="prev">Futures</a>, Up: <a href="#Futures" accesskey="u" rel="up">Futures</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Nulling-versus-nulled-1"></a>
<h3 class="section">31.1 Nulling versus nulled</h3>

<p>Currently we call a zero-length instance (aka tree node)
either a nulling instance or a nulled instance.
The use of &ldquo;nulling&rdquo; is for historic reasons and
arguably is confusing.
The symbol of a nulling instance is not necessarily
a nulling symbol &mdash; it might be a nullable symbol.
Usage of the term &ldquo;nulled&rdquo; is less confusing.
At this time, we continue to allow zero-length instances
to be called nulling instances because that terminology
is embedded in a lot of code and documents.
</p>
<hr>
<a name="Document-pre_002dconditions-more-formally"></a>
<div class="header">
<p>
Next: <a href="#Simpler-events-interface" accesskey="n" rel="next">Simpler events interface</a>, Previous: <a href="#Nulling-versus-nulled" accesskey="p" rel="prev">Nulling versus nulled</a>, Up: <a href="#Futures" accesskey="u" rel="up">Futures</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Document-pre_002dconditions-more-formally-1"></a>
<h3 class="section">31.2 Document pre-conditions more formally</h3>

<p>A more formal approach to documenting preconditions of
the methods is possible,
and may be helpful enough to repay any cost in
verbosity or complexity.
Dave Abrahams recommended I look at
<a href="https://www.boost.org/sgi/stl/">https://www.boost.org/sgi/stl/</a>
for one approach.
</p>
<hr>
<a name="Simpler-events-interface"></a>
<div class="header">
<p>
Next: <a href="#Better-defined-ambiguity-metric" accesskey="n" rel="next">Better defined ambiguity metric</a>, Previous: <a href="#Document-pre_002dconditions-more-formally" accesskey="p" rel="prev">Document pre-conditions more formally</a>, Up: <a href="#Futures" accesskey="u" rel="up">Futures</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Simpler-events-interface-1"></a>
<h3 class="section">31.3 Simpler events interface</h3>

<p>The events interface is unnecessarily complex.
A separate grammar method
for the activation and deactivation
of each event type is unnecessary.
See <a href="#Completion-events">Completion events</a>.
See <a href="#Symbol-nulled-events">Symbol nulled events</a>.
See <a href="#Prediction-events">Prediction events</a>.
</p>
<hr>
<a name="Better-defined-ambiguity-metric"></a>
<div class="header">
<p>
Next: <a href="#Report-item-traverser-should-be-a-time-object" accesskey="n" rel="next">Report item traverser should be a time object</a>, Previous: <a href="#Simpler-events-interface" accesskey="p" rel="prev">Simpler events interface</a>, Up: <a href="#Futures" accesskey="u" rel="up">Futures</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Better-defined-ambiguity-metric-1"></a>
<h3 class="section">31.4 Better defined ambiguity metric</h3>

<p>With experience, we are now in a position to define an
ambiguity metric that can be cheaply calculated,
and that might be of real use.
Preliminary notes are in the CWeb code.
</p>
<hr>
<a name="Report-item-traverser-should-be-a-time-object"></a>
<div class="header">
<p>
Next: <a href="#Orthogonal-treatment-of-soft-failures" accesskey="n" rel="next">Orthogonal treatment of soft failures</a>, Previous: <a href="#Better-defined-ambiguity-metric" accesskey="p" rel="prev">Better defined ambiguity metric</a>, Up: <a href="#Futures" accesskey="u" rel="up">Futures</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Report-item-traverser-should-be-a-time-object-1"></a>
<h3 class="section">31.5 Report item traverser should be a time object</h3>

<p>Right now, a report item traverser is a kind of &ldquo;subobject&rdquo;
of a recognizer.
It should be made into a full-fledged time object.
This will allow multiple report item traversers to be in
use at once,
allowing more aggressive use of this facility.
</p>
<hr>
<a name="Orthogonal-treatment-of-soft-failures"></a>
<div class="header">
<p>
Next: <a href="#Orthogonal-treatment-of-exhaustion" accesskey="n" rel="next">Orthogonal treatment of exhaustion</a>, Previous: <a href="#Report-item-traverser-should-be-a-time-object" accesskey="p" rel="prev">Report item traverser should be a time object</a>, Up: <a href="#Futures" accesskey="u" rel="up">Futures</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Orthogonal-treatment-of-soft-failures-1"></a>
<h3 class="section">31.6 Orthogonal treatment of soft failures</h3>

<p>The treatment of soft failure evolved along with this interface,
leaving traces of that evolution in the interface.
For example, soft failures should not set the error code,
but soft failure in
<code>marpa_r_progress_item()</code>
sets the error code to <code>MARPA_ERR_PROGRESS_REPORT_EXHAUSTED</code>.
See <a href="#marpa_005fr_005fprogress_005fitem">marpa_r_progress_item()</a>.
Similar, soft failure
<code>marpa_t_next()</code>
sets the error code to <code>MARPA_ERR_TREE_EXHAUSTED</code>.
These non-orthogonalities should be fixed someday.
</p>
<hr>
<a name="Orthogonal-treatment-of-exhaustion"></a>
<div class="header">
<p>
Next: <a href="#Furthest-earleme-values" accesskey="n" rel="next">Furthest earleme values</a>, Previous: <a href="#Orthogonal-treatment-of-soft-failures" accesskey="p" rel="prev">Orthogonal treatment of soft failures</a>, Up: <a href="#Futures" accesskey="u" rel="up">Futures</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Orthogonal-treatment-of-exhaustion-1"></a>
<h3 class="section">31.7 Orthogonal treatment of exhaustion</h3>

<p>The treatment of parse exhaustion is very awkward.
<code>marpa_r_start_input()</code> returns success on exhaustion,
while
<code>marpa_r_earleme_complete()</code> either returns success or
a hard failure, depending on circumstances.
See <a href="#marpa_005fr_005fearleme_005fcomplete">marpa_r_earleme_complete()</a>, and
<a href="#marpa_005fr_005fstart_005finput">marpa_r_start_input()</a>.
</p>
<p>Ideally the treatment should be simpler, more intuitive
and more orthogonal.
Better, perhaps, would be to always treat parse exhaustion
as a soft failure.
</p>
<hr>
<a name="Furthest-earleme-values"></a>
<div class="header">
<p>
Next: <a href="#Additional-recoverable-failures-in-marpa_005fr_005falternative_0028_0029" accesskey="n" rel="next">Additional recoverable failures in marpa_r_alternative()</a>, Previous: <a href="#Orthogonal-treatment-of-exhaustion" accesskey="p" rel="prev">Orthogonal treatment of exhaustion</a>, Up: <a href="#Futures" accesskey="u" rel="up">Futures</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Furthest-earleme-values-1"></a>
<h3 class="section">31.8 Furthest earleme values</h3>

<p><code>marpa_r_furthest_earleme</code> returns
<code>unsigned int</code>, which is non-orthogonal with
<code>marpa_r_current_earleme</code>.
This leaves no room for an failure return value,
which we deal with by not checking for failures.
The only important potential failure is calling
<code>marpa_r_furthest_earleme</code> when the furthest
earleme is an indeterminate value.
We eliminate this potential cause of failure by
regarding furthest earleme as having
been initialized when the recognizer was created,
which is another non-orthogonality with
<code>marpa_r_current_earleme</code>.
</p>
<p>All this might be fine, if something were gained, but in fact
nothing ever is gained.
The furthest
earleme, unless the parse fails, always becomes the current earleme,
and no use cases for extremely long variable-length tokens are envisioned,
so that current and furthest earleme should never be far apart.
Additionally, the additional values for the furthest earleme only come into
play if the length of parse causes the application to exceed
the memory limit imposed by modern application environments.
Summarizing, <code>marpa_r_furthest_earleme</code>,
should return an <code>int</code>,
like <code>marpa_r_current_earleme</code>,
and the non-orthogonalities should be eliminated.
</p>
<hr>
<a name="Additional-recoverable-failures-in-marpa_005fr_005falternative_0028_0029"></a>
<div class="header">
<p>
Next: <a href="#Untested-methods" accesskey="n" rel="next">Untested methods</a>, Previous: <a href="#Furthest-earleme-values" accesskey="p" rel="prev">Furthest earleme values</a>, Up: <a href="#Futures" accesskey="u" rel="up">Futures</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Additional-recoverable-failures-in-marpa_005fr_005falternative_0028_0029-1"></a>
<h3 class="section">31.9 Additional recoverable failures in marpa_r_alternative()</h3>

<p>Among the hard failures that
marpa_r_alternative() returns
are the error codes
<code>MARPA_ERR_DUPLICATE_TOKEN</code>,
<code>MARPA_ERR_NO_TOKEN_EXPECTED_HERE</code>
and <code>MARPA_ERR_INACCESSIBLE_TOKEN</code>.
These are currently irrecoverable.
They may in fact be fully recoverable,
but are not documented as such because this has not been
tested.
</p>
<p>At this writing,
we know of no applications that
attempt to recover from these errors.
It is possible that
these error codes may also be useable for the
techniques similar to the Ruby Slippers,
as of this writing, we know of no proposals
to use them in this way.
</p>
<hr>
<a name="Untested-methods"></a>
<div class="header">
<p>
Previous: <a href="#Additional-recoverable-failures-in-marpa_005fr_005falternative_0028_0029" accesskey="p" rel="prev">Additional recoverable failures in marpa_r_alternative()</a>, Up: <a href="#Futures" accesskey="u" rel="up">Futures</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Untested-methods-1"></a>
<h3 class="section">31.10 Untested methods</h3>

<p>The methods of this section are not in the external interface,
because they have not been adequately tested.
Their fate is uncertain.
Users should regard these methods
as unsupported.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Zero_002dwidth-assertion-methods" accesskey="1">Zero-width assertion methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Methods-for-revising-parses" accesskey="2">Methods for revising parses</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Zero_002dwidth-assertion-methods"></a>
<div class="header">
<p>
Next: <a href="#Methods-for-revising-parses" accesskey="n" rel="next">Methods for revising parses</a>, Previous: <a href="#Untested-methods" accesskey="p" rel="prev">Untested methods</a>, Up: <a href="#Untested-methods" accesskey="u" rel="up">Untested methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Zero_002dwidth-assertion-methods-1"></a>
<h4 class="subsection">31.10.1 Zero-width assertion methods</h4>

<a name="marpa_005fg_005fzwa_005fnew"></a><dl>
<dt><a name="index-marpa_005fg_005fzwa_005fnew"></a>Function: <em>Marpa_Assertion_ID</em> <strong>marpa_g_zwa_new</strong> <em>(     Marpa_Grammar <var>g</var>,     int <var>default_value</var>)</em></dt>
</dl>

<a name="marpa_005fg_005fzwa_005fplace"></a><dl>
<dt><a name="index-marpa_005fg_005fzwa_005fplace"></a>Function: <em>int</em> <strong>marpa_g_zwa_place</strong> <em>(     Marpa_Grammar <var>g</var>,     Marpa_Assertion_ID <var>zwaid</var>,     Marpa_Rule_ID <var>xrl_id</var>,     int <var>rhs_ix</var>)</em></dt>
</dl>

<a name="marpa_005fr_005fzwa_005fdefault"></a><dl>
<dt><a name="index-marpa_005fr_005fzwa_005fdefault"></a>Function: <em>int</em> <strong>marpa_r_zwa_default</strong> <em>(     Marpa_Recognizer <var>r</var>,     Marpa_Assertion_ID <var>zwaid</var>)</em></dt>
<dd>
<p>On success, returns previous default value of the assertion.
</p></dd></dl>

<a name="marpa_005fr_005fzwa_005fdefault_005fset"></a><dl>
<dt><a name="index-marpa_005fr_005fzwa_005fdefault_005fset"></a>Function: <em>int</em> <strong>marpa_r_zwa_default_set</strong> <em>(     Marpa_Recognizer <var>r</var>,     Marpa_Assertion_ID <var>zwaid</var>,     int <var>default_value</var>)</em></dt>
<dd>
<p>Changes default value to <var>default_value</var>.
On success, returns previous default value of the assertion.
</p></dd></dl>

<a name="marpa_005fg_005fhighest_005fzwa_005fid"></a><dl>
<dt><a name="index-marpa_005fg_005fhighest_005fzwa_005fid"></a>Function: <em>Marpa_Assertion_ID</em> <strong>marpa_g_highest_zwa_id</strong> <em>(     Marpa_Grammar <var>g</var> )</em></dt>
</dl>

<hr>
<a name="Methods-for-revising-parses"></a>
<div class="header">
<p>
Previous: <a href="#Zero_002dwidth-assertion-methods" accesskey="p" rel="prev">Zero-width assertion methods</a>, Up: <a href="#Untested-methods" accesskey="u" rel="up">Untested methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Methods-for-revising-parses-1"></a>
<h4 class="subsection">31.10.2 Methods for revising parses</h4>

<a name="marpa_005fr_005fclean"></a><dl>
<dt><a name="index-marpa_005fr_005fclean"></a>Function: <em>Marpa_Earleme</em> <strong>marpa_r_clean</strong> <em>(     Marpa_Recognizer <var>r</var>)</em></dt>
<dd>
<p>Allows an application to &ldquo;change its mind&rdquo; about a parse,
rejecting rules previously recognized or predicted,
and terminals previously scanned.
This method is untested and its fate is uncertain.
</p>
</dd></dl>

<hr>
<a name="Deprecated-techniques-and-methods"></a>
<div class="header">
<p>
Next: <a href="#History-of-the-Marpa-algorithm" accesskey="n" rel="next">History of the Marpa algorithm</a>, Previous: <a href="#Futures" accesskey="p" rel="prev">Futures</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Deprecated-techniques-and-methods-1"></a>
<h2 class="chapter">32 Deprecated techniques and methods</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#LHS-terminals" accesskey="1">LHS terminals</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Valued-and-unvalued-symbols" accesskey="2">Valued and unvalued symbols</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Cycles" accesskey="3">Cycles</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="LHS-terminals"></a>
<div class="header">
<p>
Next: <a href="#Valued-and-unvalued-symbols" accesskey="n" rel="next">Valued and unvalued symbols</a>, Previous: <a href="#Deprecated-techniques-and-methods" accesskey="p" rel="prev">Deprecated techniques and methods</a>, Up: <a href="#Deprecated-techniques-and-methods" accesskey="u" rel="up">Deprecated techniques and methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="LHS-terminals-1"></a>
<h3 class="section">32.1 LHS terminals</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Overview-of-LHS-terminals" accesskey="1">Overview of LHS terminals</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Motivation-of-LHS-terminals" accesskey="2">Motivation of LHS terminals</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#LHS-terminal-methods" accesskey="3">LHS terminal methods</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Precomputation-and-LHS-terminals" accesskey="4">Precomputation and LHS terminals</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Nulling-terminals" accesskey="5">Nulling terminals</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Overview-of-LHS-terminals"></a>
<div class="header">
<p>
Next: <a href="#Motivation-of-LHS-terminals" accesskey="n" rel="next">Motivation of LHS terminals</a>, Previous: <a href="#LHS-terminals" accesskey="p" rel="prev">LHS terminals</a>, Up: <a href="#LHS-terminals" accesskey="u" rel="up">LHS terminals</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Overview-of-LHS-terminals-1"></a>
<h4 class="subsection">32.1.1 Overview of LHS terminals</h4>

<p>The user creates LHS terminals with the
<code>marpa_g_symbol_is_terminal_set()</code>
method.
See <a href="#marpa_005fg_005fsymbol_005fis_005fterminal_005fset">marpa_g_symbol_is_terminal_set()</a>.
If the <code>marpa_g_symbol_is_terminal_set()</code>
method is never called for a grammar,
then LHS terminals are not
<a name="index-LHS-terminals-in-use"></a>
<a name="index-in-use-_0028LHS-terminals_0029"></a>
<em>in use</em>
for any time object with that grammar as its
base grammar.
</p>
<hr>
<a name="Motivation-of-LHS-terminals"></a>
<div class="header">
<p>
Next: <a href="#LHS-terminal-methods" accesskey="n" rel="next">LHS terminal methods</a>, Previous: <a href="#Overview-of-LHS-terminals" accesskey="p" rel="prev">Overview of LHS terminals</a>, Up: <a href="#LHS-terminals" accesskey="u" rel="up">LHS terminals</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Motivation-of-LHS-terminals-1"></a>
<h4 class="subsection">32.1.2 Motivation of LHS terminals</h4>

<p>Recall that a terminal symbol is a symbol that
may appear in the input.
Traditionally,
all LHS symbols, as well as
the start symbol, must be non-terminals.
By default, this is Marpa&rsquo;s behavior.
</p>
<p>In a departure from tradition,
Marpa had a feature that allowed the user to eliminate the distinction
between terminals and non-terminals.
This feature is now deprecated.
</p>
<p>When LHS terminals are in use,
a terminal
can appear on the LHS of one or more rules,
and can be be the start symbol.
Note however,
that terminals can never be zero length.
</p>
<p>The basis of the LHS terminals feature
was that,
while sharp division between terminals
and non-terminals was
a useful simplification for proving theorems,
it was not essential in practice.
In the UNIX &ldquo;toolkit&rdquo; tradition,
the practice has been to include even awkward,
dangerous tools with no known use, in the toolkit.
The philosophy was that empowering the user who
discovers new techniques is more important
than playing nanny to the toolkit&rsquo;s users.
</p>
<p>LHS symbols
could be used to bypass,
or &ldquo;short circuit&rdquo;, the rules on whose LHS they occur.
Short circuiting rules, it was thought,
might prove helpful in debugging, or have other applications.
</p>
<p>But, a decade after the release of Libmarpa,
no uses for LHS symbols have
emerged.
And they do introduce many new corner cases
into the code and complicate the API documentation.
</p>
<hr>
<a name="LHS-terminal-methods"></a>
<div class="header">
<p>
Next: <a href="#Precomputation-and-LHS-terminals" accesskey="n" rel="next">Precomputation and LHS terminals</a>, Previous: <a href="#Motivation-of-LHS-terminals" accesskey="p" rel="prev">Motivation of LHS terminals</a>, Up: <a href="#LHS-terminals" accesskey="u" rel="up">LHS terminals</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="LHS-terminal-methods-1"></a>
<h4 class="subsection">32.1.3 LHS terminal methods</h4>

<p>The
<a name="index-terminal-status-_0028of-a-symbol_0029"></a>
<em>terminal status</em>
of a symbol
is a boolean, which is true iff the symbol
is a terminal.
The terminal status of a symbol is
<a name="index-locked-terminal-status"></a>
<em>locked</em>
iff the terminal status of that symbol cannot be changed.
</p>
<a name="marpa_005fg_005fsymbol_005fis_005fterminal_005fset"></a><dl>
<dt><a name="index-marpa_005fg_005fsymbol_005fis_005fterminal_005fset"></a>Mutator function: <em>int</em> <strong>marpa_g_symbol_is_terminal_set</strong> <em>(     Marpa_Grammar <var>g</var>,     Marpa_Symbol_ID <var>sym_id</var>,  int <var>value</var>)</em></dt>
<dd>
<p>On success, does the following:
</p><ul>
<li> Sets the terminal status of the symbol
in grammar <var>g</var>
with symbol ID <var>sym_id</var>
to <var>value</var>.
To be used as an input symbol
in the
<code>marpa_r_alternative()</code>
method,
a symbol must be a terminal.
</li><li> Locks
the terminal status of symbol <var>sym_id</var>.
</li><li> Returns <var>value</var>.
</li></ul>

<p>Hard fails with error code <code>MARPA_ERR_TERMINAL_IS_LOCKED</code>
if the symbol with <var>sym_id</var>
is locked,
and the terminal status
of the symbol with <var>sym_id</var>
is not equal to <var>value</var>.
Also hard fails if
<var>value</var> is not a boolean or if <var>g</var> is precomputed.
</p>
<p><strong>Return value</strong>:
On success, <var>value</var>, which will be 1 or 0.
On soft failure, -1.
On hard failure, -2.
</p>
</dd></dl>

<hr>
<a name="Precomputation-and-LHS-terminals"></a>
<div class="header">
<p>
Next: <a href="#Nulling-terminals" accesskey="n" rel="next">Nulling terminals</a>, Previous: <a href="#LHS-terminal-methods" accesskey="p" rel="prev">LHS terminal methods</a>, Up: <a href="#LHS-terminals" accesskey="u" rel="up">LHS terminals</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Precomputation-and-LHS-terminals-1"></a>
<h4 class="subsection">32.1.4 Precomputation and LHS terminals</h4>

<p>On success,
<code>marpa_g_precompute()</code>
sets and locks the terminal status of every symbol.
More precisely,
</p><ul>
<li> let the symbol be <code>x</code>;
</li><li> let the terminal status of <code>x</code> when
<code>marpa_g_precompute()</code> was called
be <code>v_before</code>; and
</li><li> let the terminal status of <code>x</code> when
<code>marpa_g_precompute()</code> returns success
be <code>v_after</code>.
</li></ul>

<p>The effect of the successful call of
<code>marpa_g_precompute()</code> will be as follows:
</p><ul>
<li> If terminal status of <code>x</code>
is locked when
<code>marpa_g_precompute()</code> was called,
then <code>v_after = v_before</code>.
</li><li> If terminal status of <code>x</code>
is not locked, and <code>x</code> appears on
the LHS of some rule
then <code>v_after</code> is false.
</li><li> If terminal status of <code>x</code>
is not locked, and <code>x</code> does not appear on
the LHS of any rule
then <code>v_after</code> is true.
</li></ul>
<p>The terminal status of all symbols is locked
after a successful call to
<code>marpa_g_precompute()</code>.
See <a href="#marpa_005fg_005fprecompute">marpa_g_precompute()</a>.
</p>
<hr>
<a name="Nulling-terminals"></a>
<div class="header">
<p>
Previous: <a href="#Precomputation-and-LHS-terminals" accesskey="p" rel="prev">Precomputation and LHS terminals</a>, Up: <a href="#LHS-terminals" accesskey="u" rel="up">LHS terminals</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Nulling-terminals-1"></a>
<h4 class="subsection">32.1.5 Nulling terminals</h4>

<p>When LHS terminals are not in use, nulling terminals
cannot occur,
and applications need not take them in account.
This is because, in order to be nullable,
a symbol must appear on the LHS of a nullable rule.
Without LHS terminals, therefore, no terminals can
ever be either nullable or nulling.
</p>
<p>Things become more complicated if LHS terminals are allowed.
In that case nulling terminals can be created,
and Libmarpa must take measures to prevent a recognizer from being
created for a grammar with nulling terminals.
Libmarpa will not allow a recognizer to be created from a grammar
with nulling terminals because they are a logical contradiction.
A terminal is (by definition) a symbol which can appear in the input,
and a nulling symbol, by definition, cannot appear in the input.
</p>
<p>Libmarpa&rsquo;s <code>marpa_g_precompute</code> method
fails with the error code <code>MARPA_ERR_NULLING_TERMINAL</code>
if it detects nulling terminals during precomputation.
The error code <code>MARPA_ERR_NULLING_TERMINAL</code>
is library-recoverable.
See <a href="#marpa_005fg_005fprecompute">marpa_g_precompute()</a>.
</p>
<p>Libmarpa&rsquo;s <code>marpa_g_precompute</code> method
also triggers
one <code>MARPA_EVENT_NULLING_TERMINAL</code> event
for every nulling terminal in the grammar.
This implies that
one or more <code>MARPA_EVENT_NULLING_TERMINAL</code> events
occur iff
<code>marpa_g_precompute</code> fails
with error code <code>MARPA_ERR_NULLING_TERMINAL</code>.
</p>
<hr>
<a name="Valued-and-unvalued-symbols"></a>
<div class="header">
<p>
Next: <a href="#Cycles" accesskey="n" rel="next">Cycles</a>, Previous: <a href="#LHS-terminals" accesskey="p" rel="prev">LHS terminals</a>, Up: <a href="#Deprecated-techniques-and-methods" accesskey="u" rel="up">Deprecated techniques and methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Valued-and-unvalued-symbols-1"></a>
<h3 class="section">32.2 Valued and unvalued symbols</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#What-unvalued-symbols-were" accesskey="1">What unvalued symbols were</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Grammar-methods-dealing-with-unvalued-symbols" accesskey="2">Grammar methods dealing with unvalued symbols</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Registering-semantics-in-the-valuator" accesskey="3">Registering semantics in the valuator</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="What-unvalued-symbols-were"></a>
<div class="header">
<p>
Next: <a href="#Grammar-methods-dealing-with-unvalued-symbols" accesskey="n" rel="next">Grammar methods dealing with unvalued symbols</a>, Previous: <a href="#Valued-and-unvalued-symbols" accesskey="p" rel="prev">Valued and unvalued symbols</a>, Up: <a href="#Valued-and-unvalued-symbols" accesskey="u" rel="up">Valued and unvalued symbols</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="What-unvalued-symbols-were-1"></a>
<h4 class="subsection">32.2.1 What unvalued symbols were</h4>

<p>Libmarpa symbols can have values,
which is the traditional way of doing semantics.
Libmarpa also allows symbols to be unvalued.
An
<a name="index-unvalued-symbol"></a>
<a name="index-symbol_002c-unvalued"></a>
<em>unvalued</em>
symbol is one whose value
is unpredictable from instance to instance.
If a symbol is unvalued, we sometimes say that it
has &ldquo;whatever&rdquo; semantics.
</p>
<p>Situations where the semantics can tolerate unvalued symbols
are surprisingly frequent.
For example, the top-level of many languages is a series
of major units, all of whose semantics are typically accomplished
via side effects.
The compiler is typically indifferent to the actual value produced
by these major units, and tracking them is a waste of time.
Similarly, the value of the separators in a list is typically
ignored.
</p>
<p>Rules are unvalued if and only if their LHS symbols
are unvalued.
When rules and symbols are unvalued,
Libmarpa optimizes their evaluation.
</p>
<p>It is in principle unsafe to check the value
of a symbol if it can be unvalued.
For this reason,
once a symbol has been treated as valued,
Libmarpa marks it as valued.
Similarly,
once a symbol has been treated as unvalued,
Libmarpa marks it as unvalued.
Once marked, a symbol&rsquo;s valued status is
<a name="index-locked-value-status-_0028of-a-symbol_0029"></a>
<a name="index-value-status_002c-locked-_0028of-a-symbol_0029"></a>
<em>locked</em>
and cannot be changed later.
</p>
<p>The valued status of terminals is marked the first
time they are read.
</p>
<p>Unvalued symbols may be used in combination with
another deprecated feature, LHS terminals.
See <a href="#LHS-terminals">LHS terminals</a>.
The valued status of LHS symbols must be explicitly
marked by the application when initializing the
valuator &mdash; this is Libmarpa&rsquo;s equivalent of
registering a callback.
</p>
<p>The valued status of a LHS terminal
will be locked in the recognizer
if it is used as a terminal,
and the symbol&rsquo;s use as a rule LHS
in the valuator must be
consistent with the recognizer&rsquo;s valued marking.
LHS terminals are disabled by default.
</p>
<p>Marpa reports an error when a symbol&rsquo;s use
conflicts with its locked valued status.
Doing so usually saves the Libmarpa user
some tricky debugging further down the road.
</p>
<hr>
<a name="Grammar-methods-dealing-with-unvalued-symbols"></a>
<div class="header">
<p>
Next: <a href="#Registering-semantics-in-the-valuator" accesskey="n" rel="next">Registering semantics in the valuator</a>, Previous: <a href="#What-unvalued-symbols-were" accesskey="p" rel="prev">What unvalued symbols were</a>, Up: <a href="#Valued-and-unvalued-symbols" accesskey="u" rel="up">Valued and unvalued symbols</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Grammar-methods-dealing-with-unvalued-symbols-1"></a>
<h4 class="subsection">32.2.2 Grammar methods dealing with unvalued symbols</h4>

<a name="marpa_005fg_005fsymbol_005fis_005fvalued_005fset"></a><dl>
<dt><a name="index-marpa_005fg_005fsymbol_005fis_005fvalued_005fset"></a>Function: <em>int</em> <strong>marpa_g_symbol_is_valued_set</strong> <em>(     Marpa_Grammar <var>g</var>,     Marpa_Symbol_ID <var>symbol_id</var>,     int value)</em></dt>
<dd><a name="marpa_005fg_005fsymbol_005fis_005fvalued"></a></dd><dt><a name="index-marpa_005fg_005fsymbol_005fis_005fvalued"></a>Function: <em>int</em> <strong>marpa_g_symbol_is_valued</strong> <em>(     Marpa_Grammar <var>g</var>,     Marpa_Symbol_ID <var>symbol_id</var>)</em></dt>
<dd>
<p>These methods, respectively, set
and query the &ldquo;valued status&rdquo; of a symbol.
Once set to a value with the
<code>marpa_g_symbol_is_valued_set()</code>
method,
the valued status of a symbol is &ldquo;locked&rdquo; at that value.
It cannot thereafter be changed.
Subsequent calls to
<code>marpa_g_symbol_is_valued_set()</code>
for the same <var>sym_id</var> will fail,
leaving <var>sym_id</var>&rsquo;s valued status unchanged,
unless <var>value</var> is the same as the locked-in value.
</p>
<p><strong>Return value</strong>: On success, 1 if the symbol <var>symbol_id</var>
is valued after the call, 0 if not.
If the valued status is locked and <var>value</var>
is different from the current status, -2.
If <var>value</var> is not 0 or 1;
or on other hard failure, -2.
</p>
</dd></dl>

<hr>
<a name="Registering-semantics-in-the-valuator"></a>
<div class="header">
<p>
Previous: <a href="#Grammar-methods-dealing-with-unvalued-symbols" accesskey="p" rel="prev">Grammar methods dealing with unvalued symbols</a>, Up: <a href="#Valued-and-unvalued-symbols" accesskey="u" rel="up">Valued and unvalued symbols</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Registering-semantics-in-the-valuator-1"></a>
<h4 class="subsection">32.2.3 Registering semantics in the valuator</h4>

<p>By default, Libmarpa&rsquo;s valuator objects
assume that
non-terminal symbols have
no semantics.
The archetypal application will need to register
symbols that contain semantics.
The primary method for doing this is
<code>marpa_v_symbol_is_valued()</code>.
Applications will typically register semantics by rule,
and these applications will find
the
<code>marpa_v_rule_is_valued()</code>
method more convenient.
</p>
<a name="marpa_005fv_005fsymbol_005fis_005fvalued_005fset"></a><dl>
<dt><a name="index-marpa_005fv_005fsymbol_005fis_005fvalued_005fset"></a>Function: <em>int</em> <strong>marpa_v_symbol_is_valued_set</strong> <em>(     Marpa_Value <var>v</var>,     Marpa_Symbol_ID <var>sym_id</var>,     int <var>status</var> )</em></dt>
<dd><a name="marpa_005fv_005fsymbol_005fis_005fvalued"></a></dd><dt><a name="index-marpa_005fv_005fsymbol_005fis_005fvalued"></a>Function: <em>int</em> <strong>marpa_v_symbol_is_valued</strong> <em>(     Marpa_Value <var>v</var>,     Marpa_Symbol_ID <var>sym_id</var> )</em></dt>
<dd>
<p>These methods, respectively,
set and query
the valued status of symbol <var>sym_id</var>.
<code>marpa_v_symbol_is_valued_set()</code>
will set
the valued status to
the value of
its <var>status</var> argument.
A valued status of 1 indicates that the symbol is valued.
A valued status of 0 indicates that the symbol is unvalued.
If the valued status is locked,
an attempt to change to a status different from the
current one will fail
(error code <code>MARPA_ERR_VALUED_IS_LOCKED</code>).
</p>
<p><strong>Return value</strong>:  On success, the valued status <strong>after</strong>
the call.
If <var>value</var> is not either 0 or 1,
or on other hard failure, -2.
</p></dd></dl>

<a name="marpa_005fv_005frule_005fis_005fvalued_005fset"></a><dl>
<dt><a name="index-marpa_005fv_005frule_005fis_005fvalued_005fset"></a>Function: <em>int</em> <strong>marpa_v_rule_is_valued_set</strong> <em>(     Marpa_Value <var>v</var>,     Marpa_Rule_ID <var>rule_id</var>,     int <var>status</var> )</em></dt>
<dd><a name="marpa_005fv_005frule_005fis_005fvalued"></a></dd><dt><a name="index-marpa_005fv_005frule_005fis_005fvalued"></a>Function: <em>int</em> <strong>marpa_v_rule_is_valued</strong> <em>(     Marpa_Value <var>v</var>,     Marpa_Rule_ID <var>rule_id</var> )</em></dt>
<dd>
<p>These methods, respectively,
set and query
the valued status
for the LHS symbol of rule <var>rule_id</var>.
<code>marpa_v_rule_is_valued_set()</code>
sets
the valued status to the value
of its <var>status</var> argument.
</p>
<p>A valued status of 1 indicates that the symbol is valued.
A valued status of 0 indicates that the symbol is unvalued.
If the valued status is locked,
an attempt to change it to a status different from the
current one will fail
with error code <code>MARPA_ERR_VALUED_IS_LOCKED</code>.
</p>
<p>Rules have no valued status of their own.
The valued status of a rule
is always that of its LHS symbol.
These methods are conveniences &mdash; they
save the application the trouble of looking
up the rule&rsquo;s LHS.
</p>
<p><strong>Return value</strong>:  On success, the valued status of the
rule <var>rule_id</var>&rsquo;s LHS symbol <strong>after</strong>
the call.
If <var>value</var> is not either 0 or 1,
or on other hard failure, -2.
</p></dd></dl>

<a name="marpa_005fv_005fvalued_005fforce"></a><dl>
<dt><a name="index-marpa_005fv_005fvalued_005fforce"></a>Function: <em>int</em> <strong>marpa_v_valued_force</strong> <em>(     Marpa_Value <var>v</var>)</em></dt>
<dd>
<p>This methods locks the valued status of all symbols
to 1, so that all symbols will always be valued.
Hard fails if this is not possible, for example because one of
the grammar&rsquo;s symbols already is locked at a valued
status of 0.
</p>
<p><strong>Return value</strong>: On success, a non-negative integer.
On hard failure, returns -2,
and sets the error code to an appropriate
value, which will never be
<code>MARPA_ERR_NONE</code>.
</p>
</dd></dl>

<hr>
<a name="Cycles"></a>
<div class="header">
<p>
Previous: <a href="#Valued-and-unvalued-symbols" accesskey="p" rel="prev">Valued and unvalued symbols</a>, Up: <a href="#Deprecated-techniques-and-methods" accesskey="u" rel="up">Deprecated techniques and methods</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Cycles-1"></a>
<h3 class="section">32.3 Cycles</h3>

<p>A cycle is a case in a grammar where a string
non-trvially derives itself.
Marpa will parse grammars with cycles,
but this is deprecated.
Applications should treat cycles
as mistakes on the part of the writer of the grammar,
and not attempt to parse with grammars that contain cycles.
</p>
<p>If Marpa is used to parse an input that causes a cycle,
it will limit the cycle to a single loop,
so that only a finite number of parse trees is returned.
Again, parsing with cycles is deprecated.
</p>
<p>For more on cycles, see
</p><ul>
<li> <a href="#marpa_005fg_005fhas_005fcycle">marpa_g_has_cycle()</a>;
</li><li> <a href="#marpa_005fg_005frule_005fis_005floop">marpa_g_rule_is_loop()</a>;
</li><li> the discussion on the
<code>MARPA_ERR_GRAMMAR_HAS_CYCLE</code>
and <code>MARPA_EVENT_LOOP_RULES</code> events
in <a href="#marpa_005fg_005fprecompute">marpa_g_precompute()</a>;
</li><li> <a href="#MARPA_005fEVENT_005fLOOP_005fRULES">MARPA_EVENT_LOOP_RULES</a>; and
</li><li> <a href="#MARPA_005fERR_005fGRAMMAR_005fHAS_005fCYCLE">MARPA_ERR_GRAMMAR_HAS_CYCLE</a>.
</li></ul>

<hr>
<a name="History-of-the-Marpa-algorithm"></a>
<div class="header">
<p>
Next: <a href="#Annotated-bibliography" accesskey="n" rel="next">Annotated bibliography</a>, Previous: <a href="#Deprecated-techniques-and-methods" accesskey="p" rel="prev">Deprecated techniques and methods</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="History-of-the-Marpa-algorithm-1"></a>
<h2 class="chapter">33 History of the Marpa algorithm</h2>

<p>This chapter is a quick summary of the most important
events in Marpa&rsquo;s development.
My &ldquo;timeline&rdquo; of the major events in parsing theory
has a much broader scope,
and also includes more detail
about Marpa&rsquo;s development.
See <a href="#Parsing-timeline">Parsing timeline</a>.
</p>
<ul>
<li> <strong>1970</strong>:
Jay Earley invents the algorithm that now bears his
name
See <a href="#Earley-1970">Earley 1970</a>.

</li><li> <strong>1991</strong>:
Joop Leo describes a way to modify Earley&rsquo;s algorithm so that it
runs in O(n) time for all LR-regular
grammars.
See <a href="#Leo-1991">Leo 1991</a>.
LR-regular is a vast class of grammars, including all the
LR(k) grammars, all grammars parseable with recursive descent,
and regular expressions.
LR-regular can safely be thought of as including all grammars
in practical use today, and then some.

</li><li> <strong>2002</strong>:
Aycock and Horspool describe a way to do LR(0)
precomputation
for Earley&rsquo;s algorithm.
See <a href="#Aycock-and-Horspool-2002">Aycock and Horspool 2002</a>.
Their method makes Earley&rsquo;s faster in most
practical situations, but not all.
In particular, right-recursion remains quadratic in
the Aycock and Horspool algorithm.
Worst case is no better than Earley&rsquo;s.
Leo is unaware of Aycock and Horspool&rsquo;s work
and Aycock and Horspool seem unaware of Leo.

</li><li> <strong>2010</strong>:
Marpa combines the Leo and Aycock-Horspool
algorithms
in the process making significant
changes to both of them.
See <a href="#Marpa-theory-paper">Marpa theory paper</a>.
The result preserves the
best features of both
and tackles the many remaining
implementation issues.

</li></ul>

<hr>
<a name="Annotated-bibliography"></a>
<div class="header">
<p>
Next: <a href="#Acknowledgements" accesskey="n" rel="next">Acknowledgements</a>, Previous: <a href="#History-of-the-Marpa-algorithm" accesskey="p" rel="prev">History of the Marpa algorithm</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Annotated-bibliography-1"></a>
<h2 class="chapter">34 Annotated bibliography</h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Aho-and-Ullman-1972" accesskey="1">Aho and Ullman 1972</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Aycock-and-Horspool-2002" accesskey="2">Aycock and Horspool 2002</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#C89" accesskey="3">C89</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#C99" accesskey="4">C99</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Dominus-2005" accesskey="5">Dominus 2005</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Earley-1970" accesskey="6">Earley 1970</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Grune-and-Jacobs-1990" accesskey="7">Grune and Jacobs 1990</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Grune-and-Jacobs-2008" accesskey="8">Grune and Jacobs 2008</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Marpa-theory-paper" accesskey="9">Marpa theory paper</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Kegler-2023">Kegler 2023</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Parsing-timeline">Parsing timeline</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Leo-1991">Leo 1991</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Scott-2008">Scott 2008</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Wikipedia-BNF-article">Wikipedia BNF article</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Aho-and-Ullman-1972"></a>
<div class="header">
<p>
Next: <a href="#Aycock-and-Horspool-2002" accesskey="n" rel="next">Aycock and Horspool 2002</a>, Previous: <a href="#Annotated-bibliography" accesskey="p" rel="prev">Annotated bibliography</a>, Up: <a href="#Annotated-bibliography" accesskey="u" rel="up">Annotated bibliography</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Aho-and-Ullman-1972-1"></a>
<h3 class="section">34.1 Aho and Ullman 1972</h3>

<p><em>The Theory of Parsing, Translation and Compiling, Volume I: Parsing</em>
by Alfred Aho and Jeffrey Ullman
(Prentice-Hall: Englewood Cliffs, New Jersey, 1972).
I think this was the
standard source for Earley&rsquo;s algorithm for decades.
It certainly was <strong>my</strong> standard source.
The account of Earley&rsquo;s algorithm is on pages 320-330.
</p>
<hr>
<a name="Aycock-and-Horspool-2002"></a>
<div class="header">
<p>
Next: <a href="#C89" accesskey="n" rel="next">C89</a>, Previous: <a href="#Aho-and-Ullman-1972" accesskey="p" rel="prev">Aho and Ullman 1972</a>, Up: <a href="#Annotated-bibliography" accesskey="u" rel="up">Annotated bibliography</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Aycock-and-Horspool-2002-1"></a>
<h3 class="section">34.2 Aycock and Horspool 2002</h3>

<p>Marpa is based on ideas from
John Aycock and R.
Nigel Horspool&rsquo;s &ldquo;Practical Earley Parsing&rdquo;, <em>The Computer Journal</em>,
Vol. 45, No. 6, 2002, pp. 620-630.
The idea of doing LR(0)
precomputation for
Earley&rsquo;s general parsing algorithm
(see <a href="#Earley-1970">Earley 1970</a>),
and Marpa&rsquo;s approach to handling nullable symbols and rules,
both came from this article.
</p>
<p>The Aycock and Horspool paper
summarizes Earley&rsquo;s very nicely and is
available on the web: <a href="http://www.cs.uvic.ca/~nigelh/Publications/PracticalEarleyParsing.pdf">http://www.cs.uvic.ca/~nigelh/Publications/PracticalEarleyParsing.pdf</a>.
Unlike Earley&rsquo;s 1970 paper
(see <a href="#Earley-1970">Earley 1970</a>),
Aycock and Horspool 2002 is <strong>not</strong> easy reading.
I have been following
this particular topic on and off for years
and nonetheless found this paper very heavy going.
</p>
<hr>
<a name="C89"></a>
<div class="header">
<p>
Next: <a href="#C99" accesskey="n" rel="next">C99</a>, Previous: <a href="#Aycock-and-Horspool-2002" accesskey="p" rel="prev">Aycock and Horspool 2002</a>, Up: <a href="#Annotated-bibliography" accesskey="u" rel="up">Annotated bibliography</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="C89-standard"></a>
<h3 class="section">34.3 C89 standard</h3>

<p>Libmarpa is written to conform to the C89 standard.
This can be found online at
<a href="https://web.archive.org/web/20200909074736/https://www.pdf-archive.com/2014/10/02/ansi-iso-9899-1990-1/ansi-iso-9899-1990-1.pdf">https://web.archive.org/web/20200909074736/https://www.pdf-archive.com/2014/10/02/ansi-iso-9899-1990-1/ansi-iso-9899-1990-1.pdf</a>.
</p>
<hr>
<a name="C99"></a>
<div class="header">
<p>
Next: <a href="#Dominus-2005" accesskey="n" rel="next">Dominus 2005</a>, Previous: <a href="#C89" accesskey="p" rel="prev">C89</a>, Up: <a href="#Annotated-bibliography" accesskey="u" rel="up">Annotated bibliography</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="C99-standard"></a>
<h3 class="section">34.4 C99 standard</h3>

<p>The C99 standard clarifies the C89 standard in many respects.
It can be found online at
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf</a>.
</p>
<hr>
<a name="Dominus-2005"></a>
<div class="header">
<p>
Next: <a href="#Earley-1970" accesskey="n" rel="next">Earley 1970</a>, Previous: <a href="#C99" accesskey="p" rel="prev">C99</a>, Up: <a href="#Annotated-bibliography" accesskey="u" rel="up">Annotated bibliography</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Dominus-2005-1"></a>
<h3 class="section">34.5 Dominus 2005</h3>

<p>Although my approach to parsing is not influenced
by Mark Jason Dominus&rsquo;s <em>Higher Order Perl</em>,
Mark&rsquo;s treatment of parsing is an excellent introduction to parsing,
especially in a Perl context.
His focus on just about every other technique <strong>except</strong>
general BNF parsing is pretty much standard, and
will help a beginner understand how unconventional
Marpa&rsquo;s approach is.
</p>
<p>Both Mark&rsquo;s Perl and his English are examples of good writing,
and the book is dense with insights.
Mark&rsquo;s discussion on memoization in Chapter 3 is the
best I&rsquo;ve seen.
I wish I&rsquo;d bought his book earlier in my coding.
</p>
<p>Mark&rsquo;s book is available on-line.
You can download chapter-by-chapter or the whole thing at once,
and you can take your pick of his original sources or PDF,
at <a href="http://hop.perl.plover.com/book/">http://hop.perl.plover.com/book/</a>.
A PDF of the parsing chapter is at <a href="http://hop.perl.plover.com/book/pdf/08Parsing.pdf">http://hop.perl.plover.com/book/pdf/08Parsing.pdf</a>.
</p>
<hr>
<a name="Earley-1970"></a>
<div class="header">
<p>
Next: <a href="#Grune-and-Jacobs-1990" accesskey="n" rel="next">Grune and Jacobs 1990</a>, Previous: <a href="#Dominus-2005" accesskey="p" rel="prev">Dominus 2005</a>, Up: <a href="#Annotated-bibliography" accesskey="u" rel="up">Annotated bibliography</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Earley-1970-1"></a>
<h3 class="section">34.6 Earley 1970</h3>

<p>Of
Jay Earley&rsquo;s papers on his general parsing algorithm,
the most readily available
is &ldquo;An efficient context-free parsing algorithm&rdquo;,
<em>Communications of the Association for Computing Machinery</em>,
13:2:94-102, 1970.
</p>
<p>Ordinarily, I&rsquo;d not bother pointing out 35-year old nits
in a brilliant and historically important article.
But more than a few people treat this article as not just the first word in Earley
parsing, but the last as well.
Many implementations of Earley&rsquo;s algorithm come, directly and
unaltered, from his paper.
These implementers and their users need to be aware of two issues.
</p>
<p>First, the recognition engine itself, as described, has a serious bug.
There&rsquo;s an easy fix, but one that greatly slows down an algorithm
whose main problem, in its original form, was speed.
This issue is well laid out by
Aycock and Horspool
in their article.
See <a href="#Aycock-and-Horspool-2002">Aycock and Horspool 2002</a>.
</p>
<p>Second,
according to Tomita there is a mistake in the parse
tree representation.
See page 153 of <a href="#Grune-and-Jacobs-1990">Grune and Jacobs 1990</a>,
page 210 of <a href="#Grune-and-Jacobs-2008">Grune and Jacobs 2008</a>,
and the bibliography entry for Earley 1970 in <a href="#Grune-and-Jacobs-2008">Grune and Jacobs 2008</a>.
In the printed edition of the 2008 bibliography, the entry is on page 578,
and on the web
(<a href="ftp://ftp.cs.vu.nl/pub/dick/PTAPG_2nd_Edition/CompleteList.pdf">ftp://ftp.cs.vu.nl/pub/dick/PTAPG_2nd_Edition/CompleteList.pdf</a>),
it&rsquo;s on pp. 583-584.
My methods for producing parse results
from Earley sets do not come from Earley 1970,
so I am taking Tomita&rsquo;s word on this one.
</p>
<hr>
<a name="Grune-and-Jacobs-1990"></a>
<div class="header">
<p>
Next: <a href="#Grune-and-Jacobs-2008" accesskey="n" rel="next">Grune and Jacobs 2008</a>, Previous: <a href="#Earley-1970" accesskey="p" rel="prev">Earley 1970</a>, Up: <a href="#Annotated-bibliography" accesskey="u" rel="up">Annotated bibliography</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Grune-and-Jacobs-1990-1"></a>
<h3 class="section">34.7 Grune and Jacobs 1990</h3>

<p><em>Parsing Techniques: A Practical Guide</em>,
by Dick Grune and
Ceriel Jacobs,
(Ellis Horwood Limited: Chichester, West Sussex, England,
1990).
This book is available on the Web: <a href="http://dickgrune.com/Books/PTAPG_1st_Edition/">http://dickgrune.com/Books/PTAPG_1st_Edition/</a>
</p>
<hr>
<a name="Grune-and-Jacobs-2008"></a>
<div class="header">
<p>
Next: <a href="#Marpa-theory-paper" accesskey="n" rel="next">Marpa theory paper</a>, Previous: <a href="#Grune-and-Jacobs-1990" accesskey="p" rel="prev">Grune and Jacobs 1990</a>, Up: <a href="#Annotated-bibliography" accesskey="u" rel="up">Annotated bibliography</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Grune-and-Jacobs-2008-1"></a>
<h3 class="section">34.8 Grune and Jacobs 2008</h3>

<p><em>Parsing Techniques: A Practical Guide</em>,
by Dick Grune and
Ceriel Jacobs,
2nd Edition.
(Springer: New York NY, 2008).
This is the most authoritative and comprehensive introduction
to parsing I know of.
In theory it requires no mathematics, only a programming background,
but even so it is moderately difficult reading.
</p>
<p>This is the second edition of Grune and Jacobs&rsquo;s survey
of parsing methods.
See <a href="#Grune-and-Jacobs-1990">Grune and Jacobs 1990</a>.
The bibliography for this book is available in enlarged form
on the web: <a href="ftp://ftp.cs.vu.nl/pub/dick/PTAPG_2nd_Edition/CompleteList.pdf">ftp://ftp.cs.vu.nl/pub/dick/PTAPG_2nd_Edition/CompleteList.pdf</a>.
</p>
<hr>
<a name="Marpa-theory-paper"></a>
<div class="header">
<p>
Next: <a href="#Kegler-2023" accesskey="n" rel="next">Kegler 2023</a>, Previous: <a href="#Grune-and-Jacobs-2008" accesskey="p" rel="prev">Grune and Jacobs 2008</a>, Up: <a href="#Annotated-bibliography" accesskey="u" rel="up">Annotated bibliography</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Marpa-theory-paper-1"></a>
<h3 class="section">34.9 Marpa theory paper</h3>

<p>My writeup of the theory behind Marpa,
with proofs of correctness and of my complexity claims,
was first made public in 2013.
It was updated in 2023,
and can be found on <code>arxiv.org</code> (<a href="https://arxiv.org/abs/1910.08129">https://arxiv.org/abs/1910.08129</a>).
</p>
<hr>
<a name="Kegler-2023"></a>
<div class="header">
<p>
Next: <a href="#Parsing-timeline" accesskey="n" rel="next">Parsing timeline</a>, Previous: <a href="#Marpa-theory-paper" accesskey="p" rel="prev">Marpa theory paper</a>, Up: <a href="#Annotated-bibliography" accesskey="u" rel="up">Annotated bibliography</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Kegler-2023-1"></a>
<h3 class="section">34.10 Kegler 2023</h3>

<p>This theory-oriented paper expands on
the Marpa theory paper (see <a href="#Marpa-theory-paper">Marpa theory paper</a>).
It gives a detailed treatment of Marpa&rsquo;s
use of the Aycock-Horspool algorithm,
and Marpa&rsquo;s handling of nullables
It was originally announced in 2023,
and can be found on <code>arxiv.org</code> (<a href="https://arxiv.org/abs/2303.04093">https://arxiv.org/abs/2303.04093</a>).
</p>
<hr>
<a name="Parsing-timeline"></a>
<div class="header">
<p>
Next: <a href="#Leo-1991" accesskey="n" rel="next">Leo 1991</a>, Previous: <a href="#Kegler-2023" accesskey="p" rel="prev">Kegler 2023</a>, Up: <a href="#Annotated-bibliography" accesskey="u" rel="up">Annotated bibliography</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Parsing-timeline-1"></a>
<h3 class="section">34.11 Parsing timeline</h3>

<p>Far more popular than my Marpa theory paper is my
<em>Parsing: a timeline</em>.
This is a detailed history of parsing theory,
and is available online:
<a href="https://jeffreykegler.github.io/personal/timeline_v3">https://jeffreykegler.github.io/personal/timeline_v3</a>.
</p>
<hr>
<a name="Leo-1991"></a>
<div class="header">
<p>
Next: <a href="#Scott-2008" accesskey="n" rel="next">Scott 2008</a>, Previous: <a href="#Parsing-timeline" accesskey="p" rel="prev">Parsing timeline</a>, Up: <a href="#Annotated-bibliography" accesskey="u" rel="up">Annotated bibliography</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Leo-1991-1"></a>
<h3 class="section">34.12 Leo 1991</h3>

<p>Marpa&rsquo;s handling of right-recursion uses the ideas in
Joop M.I.M. Leo&rsquo;s
&ldquo;A General Context-Free Parsing Algorithm Running in Linear
Time on Every LR(k) Grammar Without Using Lookahead&rdquo;,
<em>Theoretical Computer Science</em>,
Vol. 82, No. 1, 1991, pp 165-176.
This is a difficult paper.
It is available online at
<a href="http://www.sciencedirect.com/science/article/pii/030439759190180A">http://www.sciencedirect.com/science/article/pii/030439759190180A</a>,
click the PDF icon at the top left.
</p>
<hr>
<a name="Scott-2008"></a>
<div class="header">
<p>
Next: <a href="#Wikipedia-BNF-article" accesskey="n" rel="next">Wikipedia BNF article</a>, Previous: <a href="#Leo-1991" accesskey="p" rel="prev">Leo 1991</a>, Up: <a href="#Annotated-bibliography" accesskey="u" rel="up">Annotated bibliography</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Scott-2008-1"></a>
<h3 class="section">34.13 Scott 2008</h3>

<p>One of our most important data structures is what we call a &ldquo;bocage&rdquo;.
Prof. Scott&rsquo;s work preceded ours,
and her SPPF structure is our bocage in all essential respects,
so much so that her excellent writeup serves perfectly
as documentation for the bocage:
Scott, Elizabeth.
&ldquo;SPPF-style parsing from Earley recognisers.&rdquo;
Electronic Notes in Theoretical Computer Science 203.2 (2008): 53-67,
<a href="https://dinhe.net/~aredridel/.notmine/PDFs/Parsing/SCOTT%2C%20Elizabeth%20-%20SPPF-Style%20Parsing%20From%20Earley%20Recognizers.pdf">https://dinhe.net/~aredridel/.notmine/PDFs/Parsing/SCOTT%2C%20Elizabeth%20-%20SPPF-Style%20Parsing%20From%20Earley%20Recognizers.pdf</a>.
</p>
<hr>
<a name="Wikipedia-BNF-article"></a>
<div class="header">
<p>
Previous: <a href="#Scott-2008" accesskey="p" rel="prev">Scott 2008</a>, Up: <a href="#Annotated-bibliography" accesskey="u" rel="up">Annotated bibliography</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Wikipedia-BNF-article-1"></a>
<h3 class="section">34.14 Wikipedia BNF article</h3>

<p>Wikipedia&rsquo;s article on Backus-Naur form is
<a href="http://en.wikipedia.org/wiki/Backus-Naur_form">http://en.wikipedia.org/wiki/Backus-Naur_form</a>.
It&rsquo;s a great place to start if you don&rsquo;t know the
basics of grammars and parsing.
As Wikipedia points out,
BNF might better be called Panini-Backus Form.
The grammarian Panini
gave a precise description of Sanskrit
more than 23 centuries earlier in India
using a similar notation.
</p>
<hr>
<a name="Acknowledgements"></a>
<div class="header">
<p>
Next: <a href="#Index-of-terms" accesskey="n" rel="next">Index of terms</a>, Previous: <a href="#Annotated-bibliography" accesskey="p" rel="prev">Annotated bibliography</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Acknowledgements-1"></a>
<h2 class="chapter">35 Acknowledgements</h2>

<blockquote>
<p>Beggar that I am, I am even poor in thanks; but I thank you;
and sure, dear friends, my thanks are too dear a halfpenny.
</p></blockquote>
<div align="center">&mdash; <em>Hamlet, Act 2, scene 2</em>
</div>
<p>This section is to thank those who have assisted us,
not just with Libmarpa,
but with the Marpa project as a whole.
Many people have helped us in many ways,
and it is risky
to single out one of them.
But
Ron Savage was a very aggressive early adopter of Marpa,
went on to maintain a Marpa web site and FAQ,
and provided generous financial support.
</p>
<p>Two other very early supporters were
Peter Stuifzand and Ruslan Zakirov.
Peter Stuifzand invented the &ldquo;Stuifzand interface&rdquo;,
the prototype on which Marpa&rsquo;s SLIF interface is based.
Ruslan Zakirov started, and agreed to moderate,
the &ldquo;Marpa parser&rdquo; mailing list.
A list of the other contributions to Marpa that Ron, Peter, and Ruslan Z. made
over the years would be very long.
</p>
<p>Larry Wall provided wise and experienced advice which saved us much trouble.
Larry&rsquo;s openness to new ideas has been
a major encouragement,
and his insight into the relationship between
&ldquo;natural language&rdquo; and computer language
has been a major influence.
Randal Schwartz, Allison Randal and Patrick Michaud were also generous with their
very valuable time.
</p>
<p>At perlmonks.org,
answers from
chromatic, Corion, dragonchild,
jdporter, samtregar and Juerd were helpful.
In writing an early, &ldquo;pure Perl&rdquo; version of Marpa, I benefited from studying
the work of Francois Desarmenien (<code>Parse::Yapp</code>),
Damian Conway (<code>Parse::RecDescent</code>) and
Graham Barr (<code>Scalar::Util</code>).
Adam Kennedy patiently instructed me
in module writing,
both on the finer points and
on issues about which I really should have known better.
</p>
<p>Jean-Damien Durand&rsquo;s assistance included several ambitious
Marpa applications,
as well as the Windows port of Marpa.
Deyan Ginev provided advice on LaTeX and
on deeper matters which proved essential.
Lenz Moritz quietly and effectively maintained our IRC channel.
Andrew Rodland stood in for Jeffrey Kegler as the face of Marpa
when it was needed,
and his TAP parser, which used one Marpa grammar that fed
another, was a major inspiration for the SLIF.
Ruslan Shvedov provided many hours of assistance,
including contributing linguistic insights into details of code testing,
creating a test suite for Libmarpa,
making major contributions to the Perl test suite,
helping with my implementation of ASF&rsquo;s,
and assisting me in writing documentation.
Luc St-Louis moderated the Marpa IRC channel,
saving Jeffrey time,
and the channel&rsquo;s other users from having to put up with Jeffrey who,
as a moderator,
could be too heavy-handed.
An anonymous member of the Hoon community was generous
financially.
</p>
<p>Additional help came from
Dave Abrahams,
Mohammad S Anwar,
Lukas Atkinson,
Peter Blackson,
Domingo Alvarez Duarte,
Anton Dyudin,
B. Fraser,
Zaki Mughal,
Omar Roth,
Arsen Shnurkov,
Aria Stewart,
Flaviu Tomas,
and David Whitten.
</p>
<p>Finally, my thanks to all those who participated
in the discussions on perlmonk.org,
on the &ldquo;Marpa parser&rdquo; mailing list,
and on the #marpa IRC channel.
It is hard to describe how important
informed and constructive feedback
is to a lone laborer on
a complex and large project like Marpa,
and I greatly appreciate all
those who participated.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#An-apology" accesskey="1">An apology</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="An-apology"></a>
<div class="header">
<p>
Previous: <a href="#Acknowledgements" accesskey="p" rel="prev">Acknowledgements</a>, Up: <a href="#Acknowledgements" accesskey="u" rel="up">Acknowledgements</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="An-apology-1"></a>
<h3 class="section">35.1 An apology</h3>

<p>We feared that these acknowledgements would
become an exhibition of our negligence and ingratitude,
and at least to some degree this has turned out to be the case.
There were plans for things to be better.
We took care to thank those who helped us
in Marpa&rsquo;s IRC channel,
thinking that we could use the channel&rsquo;s backlog
as a source for these notices.
</p>
<p>The European Union (EU) had other ideas.
In 2018, the EU passed the
General Data Protection Regulation (GDPR),
which suddenly brought our plans to nought.
Under the GDPR,
logs like that for Marpa&rsquo;s IRC channel could not possibly be made
conformant in a way that kept their administrators safe from
legal action.
In theory this applied to similar, highly-profitable databases maintained
by large corporations,
as much as it did to the volunteers
generously maintaining the backlog for our IRC channel.
In practice large corporations have been able to largely neutralize the GDPR,
deftly parrying most enforcement,
with their worst possible outcome being a cost-of-doing-business fine.
For the typical volunteer, however, even winning a legal action is ruinous,
given the costs.
</p>
<p>Whether or not some were aware of
GDPR&rsquo;s highly discriminatory effects
when it was being drafted,
the realization of the GDPR&rsquo;s practical implications
for volunteer-driven open source effort
came to our community very abruptly,
and after it was already in effect.
Our backlogging was done in EU jurisdiction,
and no measure to save our IRC backlogs
could be taken
without exposing innocent and generous volunteers
to almost certainly disastrous legal action.
My notes for these acknkowledgements
needed to be cobbled together from other sources.
</p>
<hr>
<a name="Index-of-terms"></a>
<div class="header">
<p>
Previous: <a href="#Acknowledgements" accesskey="p" rel="prev">Acknowledgements</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="#Index-of-terms" title="Index" rel="index">Index</a>]</p>
</div>
<a name="Index-of-terms-1"></a>
<h2 class="unnumbered">Index of terms</h2>

<p>This index is of terms that are used in a special sense in
this document.
Not every use of these terms is indexed &mdash;
only those uses that are in some way defining.
</p>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Index-of-terms_df_symbol-1"><b>@</b></a>
 &nbsp; 
<br>
<a class="summary-letter" href="#Index-of-terms_df_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-H"><b>H</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-L"><b>L</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-N"><b>N</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-U"><b>U</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-V"><b>V</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-W"><b>W</b></a>
 &nbsp; 
</td></tr></table>
<table class="index-df" border="0">
<tr><td></td><th align="left">Index Entry</th><td>&nbsp;</td><th align="left"> Section</th></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-of-terms_df_symbol-1">@</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0040_002dnotation-for-nulled-instance">@-notation for nulled instance</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0040_002dnotation-for-rule-instance">@-notation for rule instance</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0040_002dnotation-for-sequence-instance">@-notation for sequence instance</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-_0040_002dnotation-for-symbol-instance">@-notation for symbol instance</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-of-terms_df_letter-A">A</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-accessible-rule">accessible rule</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-accessible-symbol">accessible symbol</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-activated-event-subtype">activated event subtype</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Events-overview">Events overview</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-active-_0028valuator_0029">active (valuator)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Valuator-constructor">Valuator constructor</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-active-parse">active parse</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exhaustion">Exhaustion</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-advanced-input-model">advanced input model</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Advanced-input-models">Advanced input models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-advanced-models-of-input">advanced models of input</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-basic-models-of-input">The basic models of input</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ambiguous">ambiguous</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ambiguity">Ambiguity</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ancestor">ancestor</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ancestor-_0028object_0029">ancestor (object)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Time-objects">Time objects</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ancestor_002c-proper">ancestor, proper</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ancestor_002c-trivial">ancestor, trivial</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ancestry_002drecoverable-hard-failure">ancestry-recoverable hard failure</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ancestry_002drecoverable-hard-failure">Ancestry-recoverable hard failure</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-application">application</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-definitions">Miscellaneous definitions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-application-behavior">application behavior</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Application-and-diagnostic-behavior">Application and diagnostic behavior</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-application-environment">application environment</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-definitions">Miscellaneous definitions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-application-environment-limit">application environment limit</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-definitions">Miscellaneous definitions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-applications_002c-exhaustion_002dhating">applications, exhaustion-hating</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exhaustion">Exhaustion</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-applications_002c-exhaustion_002dloving">applications, exhaustion-loving</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exhaustion">Exhaustion</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-archetypal-Libmarpa-application">archetypal Libmarpa application</a>:</td><td>&nbsp;</td><td valign="top"><a href="#About-the-overviews">About the overviews</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-at-_0028a-location_002c-wrt-a-symbol_0029">at (a location, wrt a symbol)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-of-terms_df_letter-B">B</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-base-_0028object_0029">base (object)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Time-objects">Time objects</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-base-grammarbase-grammar-_0028of-a-time-object_0029">base grammar (of a time object)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Time-objects">Time objects</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-basic-models-of-input">basic models of input</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-basic-models-of-input">The basic models of input</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-behavior_002c-application">behavior, application</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Application-and-diagnostic-behavior">Application and diagnostic behavior</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-behavior_002c-diagnostic">behavior, diagnostic</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Application-and-diagnostic-behavior">Application and diagnostic behavior</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BNF">BNF</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rules">Rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-BNF-node">BNF node</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-boolean">boolean</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-definitions">Miscellaneous definitions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-boolean-value">boolean value</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-definitions">Miscellaneous definitions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-bottom_002dup-traversal">bottom-up traversal</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Traversal">Traversal</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-of-terms_df_letter-C">C</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-child-_0028of-a-node_0029">child (of a node)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-child-objectchild-object-_0028of-a-time-object_0029">child object (of a time object)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Time-objects">Time objects</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-children-_0028of-a-node_0029">children (of a node)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-codepoint_002dper_002dearleme-input-model">codepoint-per-earleme input model</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-codepoint_002dper_002dearleme-model">The codepoint-per-earleme model</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-completed-dotted-rule">completed dotted rule</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Earley-items">Earley items</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-completed-Earley-item">completed Earley item</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Earley-items">Earley items</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-completion-_0028dotted-rule_0029">completion (dotted rule)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Earley-items">Earley items</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-completion-_0028Earley-item_0029">completion (Earley item)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Earley-items">Earley items</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-context_002dfree-grammar">context-free grammar</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rules">Rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-counted-symbol">counted symbol</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Sequence-methods">Sequence methods</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-current-location-_0028in-an-Earley-item_0029">current location (in an Earley item)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Earley-items">Earley items</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-current-vertex-_0028of-a-progress-report-traverser_0029">current vertex (of a progress report traverser)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Progress-reports">Progress reports</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cycle">cycle</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recursion-and-cycles">Recursion and cycles</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-cycle_002dfree">cycle-free</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recursion-and-cycles">Recursion and cycles</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-of-terms_df_letter-D">D</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-declared-event-subtype">declared event subtype</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Events-overview">Events overview</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dense-variable_002dlength-input-model">dense variable-length input model</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-dense-variable_002dlength-token-model">The dense variable-length token model</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-depth_002dfirst-traversal">depth-first traversal</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Traversal">Traversal</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-derivation">derivation</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Derivations">Derivations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-derivation-step">derivation step</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Derivations">Derivations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-derivation_002c-leftmost">derivation, leftmost</a>:</td><td>&nbsp;</td><td valign="top"><a href="#An-example-tree">An example tree</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-derivation_002c-rightmost">derivation, rightmost</a>:</td><td>&nbsp;</td><td valign="top"><a href="#An-example-tree">An example tree</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-derives">derives</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Derivations">Derivations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-derives_002c-directly">derives, directly</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Derivations">Derivations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-descendant">descendant</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-descendant-_0028object_0029">descendant (object)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Time-objects">Time objects</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-descendant_002c-proper">descendant, proper</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-descendant_002c-trivial">descendant, trivial</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-diagnostic-behavior">diagnostic behavior</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Application-and-diagnostic-behavior">Application and diagnostic behavior</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-directly-derives">directly derives</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Derivations">Derivations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dot-position">dot position</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Earley-items">Earley items</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-dotted-rule">dotted rule</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Earley-items">Earley items</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-of-terms_df_letter-E">E</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-earleme">earleme</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Earlemes-and-Earley-set-IDs">Earlemes and Earley set IDs</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-earleme_002c-current">earleme, current</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-current-earleme">The current earleme</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-earleme_002c-empty">earleme, empty</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-fully-general-input-model">The fully general input model</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-earleme_002c-furthest">earleme, furthest</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-furthest-earleme">The furthest earleme</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-earleme_002c-latest">earleme, latest</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-latest-earleme">The latest earleme</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Earley-item">Earley item</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Earley-items">Earley items</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Earley-item-warning-threshold">Earley item warning threshold</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Other-parse-status-methods">Other parse status methods</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Earley-set-ID">Earley set ID</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Earlemes-and-Earley-set-IDs">Earlemes and Earley set IDs</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Earley-set_002c-latest">Earley set, latest</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-latest-Earley-set">The latest Earley set</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-empty-earleme">empty earleme</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-fully-general-input-model">The fully general input model</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-empty-rule">empty rule</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rules">Rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-empty-rule-1">empty rule</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rules">Rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-empty-sentence">empty sentence</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nulling">Nulling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-empty-string">empty string</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nulling">Nulling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-end-of-file">end of file</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Determining-EOP-from-EOI">Determining EOP from EOI</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-end-of-input">end of input</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Determining-EOP-from-EOI">Determining EOP from EOI</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-end-of-parse">end of parse</a>:</td><td>&nbsp;</td><td valign="top"><a href="#End-of-parse">End of parse</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-end-of-string">end of string</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Determining-EOP-from-EOI">Determining EOP from EOI</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-environment-limit">environment limit</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-definitions">Miscellaneous definitions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-environment_002c-application">environment, application</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-definitions">Miscellaneous definitions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-EOF">EOF</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Determining-EOP-from-EOI">Determining EOP from EOI</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-EOI">EOI</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Determining-EOP-from-EOI">Determining EOP from EOI</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-EOP">EOP</a>:</td><td>&nbsp;</td><td valign="top"><a href="#End-of-parse">End of parse</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-EOS">EOS</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Determining-EOP-from-EOI">Determining EOP from EOI</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-evaluate-_0028a-parse-run_0029">evaluate (a parse run)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Semantics-terms">Semantics terms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-evaluate-_0028a-tree_0029">evaluate (a tree)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Semantics-terms">Semantics terms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-evaluate-_0028an-input-string_0029">evaluate (an input string)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Semantics-terms">Semantics terms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-event-queue">event queue</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Events-overview">Events overview</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-event_002c-global">event, global</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Events-overview">Events overview</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-event_002c-per_002dsymbol">event, per-symbol</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Events-overview">Events overview</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-event_002dsafe-_0028method_0029">event-safe (method)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Events-overview">Events overview</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-event_002dtriggering-_0028method_0029">event-triggering (method)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Events-overview">Events overview</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-events_002c-recognizer-per_002dsymbol">events, recognizer per-symbol</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recognizer-per_002dsymbol-events">Recognizer per-symbol events</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exhausted-parse">exhausted parse</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exhaustion">Exhaustion</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exhaustion-on-failure">exhaustion on failure</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exhaustion">Exhaustion</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exhaustion-on-success">exhaustion on success</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exhaustion">Exhaustion</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exhaustion_002dhating-applications">exhaustion-hating applications</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exhaustion">Exhaustion</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-exhaustion_002dloving-applications">exhaustion-loving applications</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exhaustion">Exhaustion</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-expected-symbol">expected symbol</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Earley-items">Earley items</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-explicit-event-type">explicit event type</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Events-overview">Events overview</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-of-terms_df_letter-F">F</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-failure">failure</a>:</td><td>&nbsp;</td><td valign="top"><a href="#User-non_002dconformity-to-specified-behavior">User non-conformity to specified behavior</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-failure_002c-ancestry_002drecoverable-hard">failure, ancestry-recoverable hard</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ancestry_002drecoverable-hard-failure">Ancestry-recoverable hard failure</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-failure_002c-fully-recoverable-hard">failure, fully recoverable hard</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Fully-recoverable-hard-failure">Fully recoverable hard failure</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-failure_002c-hard">failure, hard</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Classifying-failure">Classifying failure</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-failure_002c-irrecoverable-hard">failure, irrecoverable hard</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Irrecoverable-hard-failure">Irrecoverable hard failure</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-failure_002c-Libmarpa-application-programming">failure, Libmarpa application programming</a>:</td><td>&nbsp;</td><td valign="top"><a href="#User-non_002dconformity-to-specified-behavior">User non-conformity to specified behavior</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-failure_002c-library_002drecoverable-hard">failure, library-recoverable hard</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Library_002drecoverable-hard-failure">Library-recoverable hard failure</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-failure_002c-memory-allocation">failure, memory allocation</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Memory-allocation-failure">Memory allocation failure</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-failure_002c-partially-recoverable-hard">failure, partially recoverable hard</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Partially-recoverable-hard-failure">Partially recoverable hard failure</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-failure_002c-soft">failure, soft</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Classifying-failure">Classifying failure</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-failure_002c-soft-1">failure, soft</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Soft-failure">Soft failure</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-failure_002c-undetected">failure, undetected</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Undetected-failure">Undetected failure</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-forest">forest</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-frozen-ordering">frozen ordering</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Freezing-the-ordering">Freezing the ordering</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-fully-recoverable-hard-failure">fully recoverable hard failure</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Fully-recoverable-hard-failure">Fully recoverable hard failure</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-of-terms_df_letter-G">G</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-global-event">global event</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Events-overview">Events overview</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-global-event-1">global event</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Events-overview">Events overview</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-grammar">grammar</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-of-terms_df_letter-H">H</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-hard-failure">hard failure</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Classifying-failure">Classifying failure</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hard-failure_002c-ancestry_002drecoverable">hard failure, ancestry-recoverable</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ancestry_002drecoverable-hard-failure">Ancestry-recoverable hard failure</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hard-failure_002c-fully-recoverable">hard failure, fully recoverable</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Fully-recoverable-hard-failure">Fully recoverable hard failure</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hard-failure_002c-irrecoverable">hard failure, irrecoverable</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Irrecoverable-hard-failure">Irrecoverable hard failure</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hard-failure_002c-library_002drecoverable">hard failure, library-recoverable</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Library_002drecoverable-hard-failure">Library-recoverable hard failure</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-hard-failure_002c-partially-recoverable">hard failure, partially recoverable</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Partially-recoverable-hard-failure">Partially recoverable hard failure</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-of-terms_df_letter-I">I</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-ID-_0028of-an-Earley-set_0029">ID (of an Earley set)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Earlemes-and-Earley-set-IDs">Earlemes and Earley set IDs</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-iff">iff</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-definitions">Miscellaneous definitions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-immediately-previous-_0028to-a-marpa_005fr_005fearleme_005fcomplete_0028_0029-call_0029">immediately previous (to a <code>marpa_r_earleme_complete()</code> call)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-standard-model-of-input">The standard model of input</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-implicit-event-type">implicit event type</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Events-overview">Events overview</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-in-use-_0028LHS-terminals_0029">in use (LHS terminals)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Overview-of-LHS-terminals">Overview of LHS terminals</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-inaccessible-rule">inaccessible rule</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-inaccessible-symbol">inaccessible symbol</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-inactive-_0028valuator_0029">inactive (valuator)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Stepping-through-the-valuator">Stepping through the valuator</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-indeterminate-value">indeterminate value</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-definitions">Miscellaneous definitions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-indirect">indirect</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Derivations">Derivations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-infinitely-ambiguous">infinitely ambiguous</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recursion-and-cycles">Recursion and cycles</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input">input</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input-1">input</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input-model_002c-advanced">input model, advanced</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Advanced-input-models">Advanced input models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input-model_002c-dense-variable_002dlength">input model, dense variable-length</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-dense-variable_002dlength-token-model">The dense variable-length token model</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input-model_002c-sparse-variable_002dlength">input model, sparse variable-length</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-fully-general-input-model">The fully general input model</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input-model_002c-variable_002dlength-token">input model, variable-length token</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Advanced-input-models">Advanced input models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input-sentence">input sentence</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input-text">input text</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input_002c-advanced-models-of">input, advanced models of</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-basic-models-of-input">The basic models of input</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-input_002c-basic-models-of">input, basic models of</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-basic-models-of-input">The basic models of input</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-instance">instance</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-instance-_0028of-a-symbol_0029">instance (of a symbol)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-instance-_0028of-a-symbol_0029-1">instance (of a symbol)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-irrecoverable-hard-failure">irrecoverable hard failure</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Irrecoverable-hard-failure">Irrecoverable hard failure</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-iterator_002c-parse-tree">iterator, parse tree</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tree-overview">Tree overview</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-of-terms_df_letter-L">L</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-labeled-ordered-tree">labeled ordered tree</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-labeled-ordered-tree-node">labeled ordered tree node</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-language">language</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-language-1">language</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Derivations">Derivations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-latest-Earley-set">latest Earley set</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-latest-Earley-set">The latest Earley set</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-leaf-_0028node_0029">leaf (node)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-leaf-node">leaf node</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-left-hand-side">left hand side</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rules">Rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-left_002drecursive">left-recursive</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recursion-and-cycles">Recursion and cycles</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-leftmost-derivation">leftmost derivation</a>:</td><td>&nbsp;</td><td valign="top"><a href="#An-example-tree">An example tree</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-length">length</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-length-1">length</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Derivations">Derivations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-length-_0028of-a-node_0029">length (of a node)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-length_002c-rule">length, rule</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rules">Rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lexeme">lexeme</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lexer">lexer</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lexical-analysis">lexical analysis</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lexical-analyzer">lexical analyzer</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-lexing">lexing</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LHS">LHS</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rules">Rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LHS-_0028of-a-rule-node_0029">LHS (of a rule node)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-LHS-terminals-in-use">LHS terminals in use</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Overview-of-LHS-terminals">Overview of LHS terminals</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Libmarpa-application-programming-failure">Libmarpa application programming failure</a>:</td><td>&nbsp;</td><td valign="top"><a href="#User-non_002dconformity-to-specified-behavior">User non-conformity to specified behavior</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Libmarpa-application-programming-success">Libmarpa application programming success</a>:</td><td>&nbsp;</td><td valign="top"><a href="#User-non_002dconformity-to-specified-behavior">User non-conformity to specified behavior</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Libmarpa-application_002c-archetypal">Libmarpa application, archetypal</a>:</td><td>&nbsp;</td><td valign="top"><a href="#About-the-overviews">About the overviews</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-library_002drecoverable-hard-failure">library-recoverable hard failure</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Library_002drecoverable-hard-failure">Library-recoverable hard failure</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-limit_002c-application-environment">limit, application environment</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-definitions">Miscellaneous definitions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-limit_002c-environment">limit, environment</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-definitions">Miscellaneous definitions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-locked-terminal-status">locked terminal status</a>:</td><td>&nbsp;</td><td valign="top"><a href="#LHS-terminal-methods">LHS terminal methods</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-locked-value-status-_0028of-a-symbol_0029">locked value status (of a symbol)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#What-unvalued-symbols-were">What unvalued symbols were</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-of-terms_df_letter-M">M</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-matches">matches</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Derivations">Derivations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-matches-1">matches</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Derivations">Derivations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-max_0028x_002cy_0029">max(x,y)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-definitions">Miscellaneous definitions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-memory-allocation-failure">memory allocation failure</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Memory-allocation-failure">Memory allocation failure</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-method">method</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-definitions">Miscellaneous definitions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-models-of-input_002c-advanced">models of input, advanced</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-basic-models-of-input">The basic models of input</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-models-of-input_002c-basic">models of input, basic</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-basic-models-of-input">The basic models of input</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-of-terms_df_letter-N">N</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-next-vertex-_0028of-a-progress-report-traverser_0029">next vertex (of a progress report traverser)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Progress-reports">Progress reports</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-node-_0028of-a-tree_0029">node (of a tree)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-node-length">node length</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-node_002c-labeled-ordered-tree">node, labeled ordered tree</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-node_002c-root">node, root</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-node_002c-start">node, start</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-non_002dempty">non-empty</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nulling">Nulling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-non_002dnullable">non-nullable</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nulling">Nulling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-non_002dnullable-1">non-nullable</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nulling">Nulling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-non_002dnulling">non-nulling</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nulling">Nulling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-non_002dnulling-1">non-nulling</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nulling">Nulling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-non_002dtrivial">non-trivial</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Derivations">Derivations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-null-derivation">null derivation</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nulling">Nulling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-null-parse">null parse</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nulling">Nulling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-null-vertex">null vertex</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Progress-reports">Progress reports</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nullable-rule">nullable rule</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nulling">Nulling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nullable-symbol">nullable symbol</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nulling">Nulling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nulled-_0028of-a-symbol_0029">nulled (of a symbol)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nulled-node">nulled node</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nulled-symbol-instance">nulled symbol instance</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nulling-node">nulling node</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nulling-rule">nulling rule</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nulling">Nulling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-nulling-symbol">nulling symbol</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nulling">Nulling</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-of-terms_df_letter-O">O</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-one_002dcodepoint_002dper_002dearleme-input-model">one-codepoint-per-earleme input model</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-codepoint_002dper_002dearleme-model">The codepoint-per-earleme model</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-ordering_002c-frozen">ordering, frozen</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Freezing-the-ordering">Freezing the ordering</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-origin-_0028in-an-Earley-item_0029">origin (in an Earley item)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Earley-items">Earley items</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-our">our</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-definitions">Miscellaneous definitions</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-of-terms_df_letter-P">P</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-parent-_0028wrt-a-node_0029">parent (wrt a node)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parent-objectparent-object-_0028of-a-time-object_0029">parent object (of a time object)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Time-objects">Time objects</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parse-_0028aka-parse-forest_0029">parse (aka parse forest)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parse-_0028aka-parse-run_0029">parse (aka parse run)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parse-_0028aka-parse-tree_0029">parse (aka parse tree)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parse-_0028forest_0029">parse (forest)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parse-exhaustion-on-failure">parse exhaustion on failure</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exhaustion">Exhaustion</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parse-exhaustion-on-success">parse exhaustion on success</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exhaustion">Exhaustion</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parse-forest">parse forest</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parse-tree">parse tree</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tree-overview">Tree overview</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parse-tree-iterator">parse tree iterator</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tree-overview">Tree overview</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parse_002c-active">parse, active</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exhaustion">Exhaustion</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parse_002c-exhausted">parse, exhausted</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Exhaustion">Exhaustion</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-parser">parser</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-partially-recoverable-hard-failure">partially recoverable hard failure</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Partially-recoverable-hard-failure">Partially recoverable hard failure</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-pause-_0028a-parent-tree-iterator_0029">pause (a parent tree iterator)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Valuator-constructor">Valuator constructor</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-per_002dsymbol-event">per-symbol event</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Events-overview">Events overview</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-per_002dsymbol-event-1">per-symbol event</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Events-overview">Events overview</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-postdot-symbol-_0028of-a-dotted-rule_0029">postdot symbol (of a dotted rule)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Earley-items">Earley items</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-postdot-symbol-_0028of-an-Earley-item_0029">postdot symbol (of an Earley item)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Earley-items">Earley items</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-postorder-traversal">postorder traversal</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Traversal">Traversal</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-predicted-dotted-rule">predicted dotted rule</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Earley-items">Earley items</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-predicted-Earley-item">predicted Earley item</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Earley-items">Earley items</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prediction-_0028dotted-rule_0029">prediction (dotted rule)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Earley-items">Earley items</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-prediction-_0028Earley-item_0029">prediction (Earley item)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Earley-items">Earley items</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-previous-_0028to-a-marpa_005fr_005fearleme_005fcomplete_0028_0029-call_0029_002c-immediately">previous (to a <code>marpa_r_earleme_complete()</code> call), immediately</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-standard-model-of-input">The standard model of input</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-produces">produces</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Derivations">Derivations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-productive-rule">productive rule</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-productive-symbol">productive symbol</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-progress-report-item">progress report item</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Progress-reports">Progress reports</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-progress-report-traverser">progress report traverser</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Progress-reports">Progress reports</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-proper-ancestor">proper ancestor</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-proper-descendant">proper descendant</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-of-terms_df_letter-R">R</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-raw-input">raw input</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-reachable-rule">reachable rule</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-reachable-symbol">reachable symbol</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recognizer">recognizer</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recognizer-per_002dsymbol-events">recognizer per-symbol events</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recognizer-per_002dsymbol-events">Recognizer per-symbol events</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-recursive">recursive</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recursion-and-cycles">Recursion and cycles</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-report-item">report item</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Progress-reports">Progress reports</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-RHS">RHS</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rules">Rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-RHS-_0028of-a-rule-node_0029">RHS (of a rule node)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-right-hand-side">right hand side</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rules">Rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-right_002drecursive">right-recursive</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recursion-and-cycles">Recursion and cycles</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rightmost-derivation">rightmost derivation</a>:</td><td>&nbsp;</td><td valign="top"><a href="#An-example-tree">An example tree</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-root-node">root node</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-Ruby-Slippers">Ruby Slippers</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Recognizer-life-cycle-mutators">Recognizer life cycle mutators</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule">rule</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule-creation-methods">rule creation methods</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rule-methods">Rule methods</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule-creation-methods-1">rule creation methods</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Sequence-methods">Sequence methods</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule-length">rule length</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rules">Rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule-node">rule node</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-accessible">rule, accessible</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-inaccessible">rule, inaccessible</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-nullable">rule, nullable</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nulling">Nulling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-nulling">rule, nulling</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Nulling">Nulling</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-productive">rule, productive</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-reachable">rule, reachable</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-unproductive">rule, unproductive</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-unreachable">rule, unreachable</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-rule_002c-useless">rule, useless</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-of-terms_df_letter-S">S</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-scanner">scanner</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-scanning">scanning</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-semantics">semantics</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-semantics-1">semantics</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Semantics-terms">Semantics terms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sentence">sentence</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sentential-form">sentential form</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sequence-node">sequence node</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sequence-rule">sequence rule</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Rules">Rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-soft-failure">soft failure</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Classifying-failure">Classifying failure</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-soft-failure-1">soft failure</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Soft-failure">Soft failure</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-sparse-variable_002dlength-input-model">sparse variable-length input model</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-fully-general-input-model">The fully general input model</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-start-node">start node</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-step">step</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Derivations">Derivations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-step-_0028of-a-valuator_0029">step (of a valuator)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Stepping-through-the-valuator">Stepping through the valuator</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-step-type">step type</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Stepping-through-the-valuator">Stepping through the valuator</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-step-type_002c-valuator">step type, valuator</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Stepping-through-the-valuator">Stepping through the valuator</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-string">string</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-subtree">subtree</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-success">success</a>:</td><td>&nbsp;</td><td valign="top"><a href="#User-non_002dconformity-to-specified-behavior">User non-conformity to specified behavior</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-success_002c-Libmarpa-application-programming">success, Libmarpa application programming</a>:</td><td>&nbsp;</td><td valign="top"><a href="#User-non_002dconformity-to-specified-behavior">User non-conformity to specified behavior</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-successful">successful</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Derivations">Derivations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-symbol">symbol</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-symbol-instance_002c-nulled">symbol instance, nulled</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-symbol-string">symbol string</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-symbol-string-input">symbol string input</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-symbol-string-input-1">symbol string input</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-symbol_002c-accessible">symbol, accessible</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-symbol_002c-counted">symbol, counted</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Sequence-methods">Sequence methods</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-symbol_002c-inaccessible">symbol, inaccessible</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-symbol_002c-productive">symbol, productive</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-symbol_002c-reachable">symbol, reachable</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-symbol_002c-unproductive">symbol, unproductive</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-symbol_002c-unreachable">symbol, unreachable</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-symbol_002c-unvalued">symbol, unvalued</a>:</td><td>&nbsp;</td><td valign="top"><a href="#What-unvalued-symbols-were">What unvalued symbols were</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-symbol_002c-useless">symbol, useless</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-of-terms_df_letter-T">T</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-terminal-node">terminal node</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-terminal-status-_0028of-a-symbol_0029">terminal status (of a symbol)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#LHS-terminal-methods">LHS terminal methods</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-token-node">token node</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-token-stream">token stream</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-token_002dper_002dearleme-input-models">token-per-earleme input models</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-codepoint_002dper_002dearleme-model">The codepoint-per-earleme model</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tokens">tokens</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-trap-representations">trap representations</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trap-representations">Trap representations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-trap-value">trap value</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-definitions">Miscellaneous definitions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-traverse">traverse</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Traversal">Traversal</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-traverser_002c-progress-report">traverser, progress report</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Progress-reports">Progress reports</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tree">tree</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tree-1">tree</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Tree-overview">Tree overview</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tree-node">tree node</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tree-node_002c-labeled-ordered">tree node, labeled ordered</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-tree_002c-labeled-ordered">tree, labeled ordered</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-trivial-ancestor">trivial ancestor</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-trivial-derivation">trivial derivation</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Derivations">Derivations</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-trivial-descendant">trivial descendant</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Trees">Trees</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-of-terms_df_letter-U">U</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-unambiguous">unambiguous</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Ambiguity">Ambiguity</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-undefined-behavior">undefined behavior</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-definitions">Miscellaneous definitions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-undetected-failure">undetected failure</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Undetected-failure">Undetected failure</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-unproductive-rule">unproductive rule</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-unproductive-symbol">unproductive symbol</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-unreachable">unreachable</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-unreachable-rule">unreachable rule</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-unreachable-symbol">unreachable symbol</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-unspecified-behavior">unspecified behavior</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-definitions">Miscellaneous definitions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-unspecified-value">unspecified value</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-definitions">Miscellaneous definitions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-unvalued-symbol">unvalued symbol</a>:</td><td>&nbsp;</td><td valign="top"><a href="#What-unvalued-symbols-were">What unvalued symbols were</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-us">us</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-definitions">Miscellaneous definitions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-useless-rule">useless rule</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-useless-symbol">useless symbol</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Useless-rules">Useless rules</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-user">user</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-definitions">Miscellaneous definitions</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-of-terms_df_letter-V">V</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-valuator">valuator</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Value-overview">Value overview</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-valuator-step">valuator step</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Stepping-through-the-valuator">Stepping through the valuator</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-valuator-step-type">valuator step type</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Stepping-through-the-valuator">Stepping through the valuator</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-value">value</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Parsing-theory-preliminaries">Parsing theory preliminaries</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-value-1">value</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Semantics-terms">Semantics terms</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-value-status_002c-locked-_0028of-a-symbol_0029">value status, locked (of a symbol)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#What-unvalued-symbols-were">What unvalued symbols were</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-value_002c-boolean">value, boolean</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-definitions">Miscellaneous definitions</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variable_002dlength-input-model_002c-dense">variable-length input model, dense</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-dense-variable_002dlength-token-model">The dense variable-length token model</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variable_002dlength-input-model_002c-sparse">variable-length input model, sparse</a>:</td><td>&nbsp;</td><td valign="top"><a href="#The-fully-general-input-model">The fully general input model</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-variable_002dlength-token-input-model">variable-length token input model</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Advanced-input-models">Advanced input models</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-vertex_002c-current-_0028of-a-progress-report-traverser_0029">vertex, current (of a progress report traverser)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Progress-reports">Progress reports</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-vertex_002c-next-_0028of-a-progress-report-traverser_0029">vertex, next (of a progress report traverser)</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Progress-reports">Progress reports</a></td></tr>
<tr><td></td><td valign="top"><a href="#index-vertex_002c-null">vertex, null</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Progress-reports">Progress reports</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
<tr><th><a name="Index-of-terms_df_letter-W">W</a></th><td></td><td></td></tr>
<tr><td></td><td valign="top"><a href="#index-we">we</a>:</td><td>&nbsp;</td><td valign="top"><a href="#Miscellaneous-definitions">Miscellaneous definitions</a></td></tr>
<tr><td colspan="4"> <hr></td></tr>
</table>
<table><tr><th valign="top">Jump to: &nbsp; </th><td><a class="summary-letter" href="#Index-of-terms_df_symbol-1"><b>@</b></a>
 &nbsp; 
<br>
<a class="summary-letter" href="#Index-of-terms_df_letter-A"><b>A</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-B"><b>B</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-C"><b>C</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-D"><b>D</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-E"><b>E</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-F"><b>F</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-G"><b>G</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-H"><b>H</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-I"><b>I</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-L"><b>L</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-M"><b>M</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-N"><b>N</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-O"><b>O</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-P"><b>P</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-R"><b>R</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-S"><b>S</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-T"><b>T</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-U"><b>U</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-V"><b>V</b></a>
 &nbsp; 
<a class="summary-letter" href="#Index-of-terms_df_letter-W"><b>W</b></a>
 &nbsp; 
</td></tr></table>

<div class="footnote">
<hr>
<h4 class="footnotes-heading">Footnotes</h4>

<h3><a name="FOOT1" href="#DOCF1">(1)</a></h3>
<p>Those interested in details of notation
    may notice that we
    include current location in the Earley item
    tuple, contrary to the tradition.
    We develop our notation more formally,
    and explain our reasons
    for the deviation from tradition,
    on pages 5-7 of
    <a href="https://arxiv.org/abs/2303.04093v1">https://arxiv.org/abs/2303.04093v1</a>.
</p>
</div>
<hr>



</body>
</html>
